{{>header}}
<style>
  header.header {
    display: none !important;
  }

  footer.footer {
    display: none !important;
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
  }
</style>

<section class="showcase-page">
  <!-- Loading State - Full FitGlue Experience -->
  <div id="showcase-loading" class="showcase-loading">
    <!-- Animated background gradient -->
    <div class="loading-bg-gradient"></div>

    <div class="loading-content">
      <!-- Animated logo -->
      <div class="loading-logo">
        <span class="loading-logo-fit">Fit</span><span class="loading-logo-glue">Glue</span>
      </div>

      <!-- Premium multi-ring spinner -->
      <div class="loading-spinner-container">
        <div class="loading-spinner-ring"></div>
        <div class="loading-spinner-ring loading-spinner-ring-2"></div>
        <div class="loading-spinner-ring loading-spinner-ring-3"></div>
      </div>

      <!-- Rotating funny messages -->
      <p id="loading-message" class="loading-message">Loading activity...</p>
    </div>
  </div>

  <!-- Error State -->
  <div id="showcase-error" class="showcase-error" style="display: none;">
    <div class="error-icon">üèÉüèÉ‚Äç‚ôÇÔ∏èüèÉ‚Äç‚ôÄÔ∏è</div>
    <h1>This Activity Got Away!</h1>
    <p id="error-message">Looks like this showcase sprinted off before we could catch it.</p>
    <p class="error-subtitle">It may have expired, or perhaps the link has a typo.</p>
    <a href="/" class="btn btn-primary">Explore FitGlue</a>
  </div>

  <!-- Fullscreen Chart Modal -->
  <div id="chart-modal" class="chart-modal" style="display: none;">
    <div class="chart-modal-backdrop"></div>
    <div class="chart-modal-content glass-card">
      <div class="chart-modal-header">
        <h2 id="chart-modal-title"></h2>
        <button class="chart-modal-close" onclick="closeChartModal()">‚úï</button>
      </div>
      <div class="chart-modal-body">
        <canvas id="chart-modal-canvas"></canvas>
      </div>
    </div>
  </div>

  <!-- Success State -->
  <div id="showcase-content" class="showcase-content" style="display: none;">

    <!-- Hero Header -->
    <div class="showcase-hero">
      <h1 id="activity-title" class="showcase-title"></h1>
      <div id="owner-attribution" class="owner-attribution" style="display: none;"></div>
      <div class="showcase-meta">
        <span id="activity-type" class="activity-type-badge"></span>
        <span id="activity-source" class="activity-source"></span>
        <span id="activity-date" class="activity-date"></span>
      </div>
      <!-- User-provided description - prominent display -->
      <div id="user-description" class="user-description" style="display: none;"></div>
    </div>

    <!-- Stats Grid - Hero Cards -->
    <div id="stats-section" class="stats-grid" style="display: none;"></div>

    <!-- Hybrid Race Breakdown - PRIORITY POSITION for race activities -->
    <div id="hybrid-race-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üèÅ Race Breakdown</h2>
        <span id="hybrid-race-name" class="section-subtitle"></span>
      </div>
      <div id="hybrid-race-bars" class="hybrid-race-bars"></div>
      <div id="hybrid-race-total" class="hybrid-race-total"></div>
    </div>

    <!-- Map Section -->
    <div id="map-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üó∫Ô∏è Route</h2>
      </div>
      <div id="activity-map" class="activity-map"></div>
    </div>

    <!-- Heart Rate Graph -->
    <div id="hr-graph-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ù§Ô∏è Heart Rate</h2>
        <button class="expand-chart-btn" onclick="openChartModal('hr', '‚ù§Ô∏è Heart Rate')" title="Expand">‚õ∂</button>
      </div>
      <div class="hr-summary" id="hr-summary"></div>
      <div class="chart-container">
        <canvas id="hr-chart"></canvas>
      </div>
    </div>

    <!-- Elevation Graph -->
    <div id="elevation-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚õ∞Ô∏è Elevation</h2>
        <button class="expand-chart-btn" onclick="openChartModal('elevation', '‚õ∞Ô∏è Elevation')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="elevation-chart"></canvas>
      </div>
    </div>

    <!-- Pace Graph -->
    <div id="pace-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ö° Pace</h2>
        <button class="expand-chart-btn" onclick="openChartModal('pace', '‚ö° Pace')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="pace-chart"></canvas>
      </div>
    </div>

    <!-- Power Graph -->
    <div id="power-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ö° Power</h2>
        <button class="expand-chart-btn" onclick="openChartModal('power', '‚ö° Power')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="power-chart"></canvas>
      </div>
    </div>

    <!-- Cadence Graph -->
    <div id="cadence-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>ü¶∂ Cadence</h2>
        <button class="expand-chart-btn" onclick="openChartModal('cadence', 'ü¶∂ Cadence')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="cadence-chart"></canvas>
      </div>
    </div>

    <!-- Speed Graph -->
    <div id="speed-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üöÄ Speed</h2>
        <button class="expand-chart-btn" onclick="openChartModal('speed', 'üöÄ Speed')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="speed-chart"></canvas>
      </div>
    </div>

    <!-- Description Sections (parsed from enricher output) -->
    <div id="description-sections-container" style="display: none;"></div>

    <!-- Muscle Activation Heatmap -->
    <div id="muscle-activation-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üî• Muscle Activation</h2>
        <span class="section-subtitle">Visual breakdown of muscle engagement</span>
      </div>
      <div class="muscle-heatmap-container">
        <div id="muscle-heatmap-container" class="muscle-heatmap-inner"></div>
      </div>
    </div>

    <!-- Strength Sets / Exercises -->
    <div id="exercises-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üí™ Exercises</h2>
        <span id="exercise-count" class="section-subtitle"></span>
      </div>
      <div id="exercise-list" class="exercise-list"></div>
    </div>


    <!-- Tags -->
    <div id="tags-section" class="showcase-section" style="display: none;">
      <div id="activity-tags" class="activity-tags"></div>
    </div>

    <!-- Enrichments Applied (Premium Feature) - MOVED TO BOTTOM -->
    <div id="enrichments-section" class="showcase-section" style="display: none;">
      <div class="section-header">
        <h2>üöÄ Boosters Applied</h2>
        <span class="section-subtitle">FitGlue Boosters applied to this activity</span>
      </div>
      <div id="enrichment-badges" class="enrichment-list"></div>
    </div>

    <!-- CTA - MOVED TO BOTTOM -->
    <div id="showcase-cta" class="showcase-cta glass-card">
      <div class="cta-content">
        <h3>Want to enhance your own activities?</h3>
        <p>FitGlue automatically enriches your workouts with muscle heatmaps, heart rate data, and beautiful
          summaries.</p>
      </div>
      <a href="/" class="btn btn-primary btn-lg btn-glow">Try FitGlue Free</a>
    </div>

    <!-- Footer Attribution -->
    <div id="showcase-attribution" class="showcase-attribution">
      <span>Powered by</span>
      <a href="/" class="fitglue-logo">
        <span class="fit">Fit</span><span class="glue">Glue</span>
      </a>
    </div>
  </div>
</section>
</main>

<!-- External Dependencies -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>

<style>
  /* ========================================
     SHOWCASE PAGE - WORLD CLASS DESIGN
     ======================================== */

  .showcase-page {
    min-height: 100vh;
    background: linear-gradient(180deg, #0a0a0a 0%, #1a0a20 50%, #0a0a0a 100%);
    padding: 0;
  }

  .showcase-loading {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0A0A0A;
    z-index: 9999;
    overflow: hidden;
  }

  /* Animated background gradient */
  .loading-bg-gradient {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(ellipse at 20% 20%, rgba(255, 27, 141, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(157, 78, 221, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 50%, rgba(76, 201, 240, 0.03) 0%, transparent 70%);
    animation: loading-bg-pulse 4s ease-in-out infinite;
  }

  @keyframes loading-bg-pulse {

    0%,
    100% {
      opacity: 0.6;
      transform: scale(1);
    }

    50% {
      opacity: 1;
      transform: scale(1.05);
    }
  }

  /* Content container */
  .loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    animation: loading-fade-in 0.6s ease-out;
    z-index: 1;
  }

  @keyframes loading-fade-in {
    from {
      opacity: 0;
      transform: translateY(10px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Logo styling */
  .loading-logo {
    font-size: clamp(2.5rem, 8vw, 4rem);
    font-weight: 900;
    letter-spacing: -0.02em;
    display: flex;
    gap: 0;
  }

  .loading-logo-fit {
    background: linear-gradient(135deg, #FF1B8D 0%, #FF6BB3 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: loading-logo-shimmer 2s ease-in-out infinite;
  }

  .loading-logo-glue {
    background: linear-gradient(135deg, #9D4EDD 0%, #C77DFF 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: loading-logo-shimmer 2s ease-in-out infinite 0.15s;
  }

  @keyframes loading-logo-shimmer {

    0%,
    100% {
      opacity: 0.9;
      filter: brightness(1);
    }

    50% {
      opacity: 1;
      filter: brightness(1.2);
    }
  }

  /* Premium multi-ring spinner */
  .loading-spinner-container {
    position: relative;
    width: 60px;
    height: 60px;
  }

  .loading-spinner-ring {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 3px solid transparent;
    border-top-color: #FF1B8D;
    animation: spin 1.2s cubic-bezier(0.5, 0.1, 0.5, 0.9) infinite;
  }

  .loading-spinner-ring-2 {
    inset: 6px;
    border-top-color: #9D4EDD;
    animation-duration: 1.8s;
    animation-direction: reverse;
  }

  .loading-spinner-ring-3 {
    inset: 12px;
    border-top-color: #4CC9F0;
    animation-duration: 2.4s;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  /* Message styling */
  .loading-message {
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.5);
    font-weight: 500;
    letter-spacing: 0.01em;
    min-height: 1.5em;
    transition: opacity 0.3s ease;
  }

  .loading-message.fade-out {
    opacity: 0;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes shimmer {
    to {
      background-position: 200% center;
    }
  }

  @keyframes pulse {

    0%,
    100% {
      transform: scale(1);
    }

    50% {
      transform: scale(1.05);
    }
  }

  @keyframes glow {

    0%,
    100% {
      box-shadow: 0 0 20px rgba(255, 27, 141, 0.4);
    }

    50% {
      box-shadow: 0 0 40px rgba(255, 27, 141, 0.8);
    }
  }

  /* Error State */
  .showcase-error {
    text-align: center;
    max-width: 500px;
    margin: 15vh auto 0;
    padding: 2rem;
    background: rgba(30, 30, 40, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
  }

  .error-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
  }

  .showcase-error h1 {
    font-size: clamp(1.5rem, 4vw, 2.2rem);
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .showcase-error p {
    font-size: 1rem;
    color: #aaa;
    margin-bottom: 0.5rem;
  }

  .error-subtitle {
    font-size: 0.875rem !important;
    opacity: 0.7;
    margin-bottom: 1.5rem !important;
  }

  /* Content Container - No bounding box on mobile */
  .showcase-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
    animation: fadeInUp 0.6s ease-out;
  }

  @media (min-width: 768px) {
    .showcase-content {
      padding: 0 2rem;
    }
  }

  /* ========================================
     HERO SECTION
     ======================================== */
  .showcase-hero {
    text-align: center;
    padding: 3rem 1rem 2rem;
    margin-bottom: 1.5rem;
    position: relative;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 24px;
    overflow: hidden;
  }

  /* Dark overlay for text readability when banner is present */
  .showcase-hero.has-banner {
    min-height: 350px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .showcase-hero.has-banner::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.4);
    z-index: 0;
  }

  .showcase-hero.has-banner>* {
    position: relative;
    z-index: 1;
  }

  .showcase-title {
    font-size: clamp(2.5rem, 8vw, 4rem);
    font-weight: 900;
    margin-bottom: 1rem;
    background: linear-gradient(90deg,
        #FF1B8D 0%,
        #9D4EDD 25%,
        #fff 50%,
        #9D4EDD 75%,
        #FF1B8D 100%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    line-height: 1.1;
    animation: shimmer 3s linear infinite;
    text-shadow: 0 0 60px rgba(255, 27, 141, 0.3);
  }

  .showcase-meta {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  /* User-provided description - big, bold, beautiful */
  .user-description {
    margin-top: 1.5rem;
    padding: 0 1rem;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    font-size: 1.25rem;
    font-style: italic;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
    line-height: 1.6;
    position: relative;
  }

  .user-description::before {
    content: '"';
    font-size: 3rem;
    font-family: Georgia, serif;
    position: absolute;
    left: -0.5rem;
    top: -0.5rem;
    opacity: 0.3;
    color: #9D4EDD;
  }

  /* Compact sections container - horizontal stacking */
  .compact-sections-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
  }

  .compact-sections-row .description-section-card {
    flex: 1 1 280px;
    max-width: 400px;
    min-width: 250px;
  }

  @media (max-width: 600px) {
    .compact-sections-row .description-section-card {
      flex: 1 1 100%;
      max-width: 100%;
    }
  }

  .owner-attribution {
    font-size: 1.1rem;
    color: #aaa;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }

  .owner-name {
    font-weight: 700;
    color: #fff;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .owner-link {
    text-decoration: none;
    cursor: pointer;
    transition: filter 0.2s ease;
  }

  .owner-link:hover {
    filter: brightness(1.3);
  }

  .activity-type-badge {
    background: linear-gradient(135deg, #4CC9F0, #9D4EDD);
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-weight: 700;
    font-size: 0.875rem;
    color: white;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    box-shadow: 0 4px 15px rgba(76, 201, 240, 0.3);
  }

  .activity-source,
  .activity-date {
    color: #aaa;
    font-size: 0.875rem;
  }

  /* ========================================
     HERO STATS GRID
     ======================================== */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
    padding: 0;
  }

  .stat-card {
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    padding: 1.5rem 1rem;
    text-align: center;
    transition: all 0.3s ease;
    animation: fadeInUp 0.6s ease-out backwards;
  }

  .stat-card:nth-child(1) {
    animation-delay: 0.1s;
  }

  .stat-card:nth-child(2) {
    animation-delay: 0.15s;
  }

  .stat-card:nth-child(3) {
    animation-delay: 0.2s;
  }

  .stat-card:nth-child(4) {
    animation-delay: 0.25s;
  }

  .stat-card:nth-child(5) {
    animation-delay: 0.3s;
  }

  .stat-card:hover {
    transform: translateY(-4px);
    border-color: rgba(255, 27, 141, 0.4);
    box-shadow: 0 10px 40px rgba(255, 27, 141, 0.2);
  }

  .stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
  }

  .stat-value {
    font-size: clamp(1.75rem, 5vw, 2.5rem);
    font-weight: 900;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    line-height: 1.2;
  }

  .stat-label {
    font-size: 0.75rem;
    color: #aaa;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-top: 0.25rem;
  }

  /* ========================================
     GLASS CARDS
     ======================================== */
  .glass-card {
    background: rgba(30, 30, 40, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    animation: fadeInUp 0.6s ease-out backwards;
  }

  .showcase-section {
    margin-bottom: 1.5rem;
  }

  .section-header {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .section-header h2 {
    font-size: 1.25rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
    color: #fff;
  }

  .section-subtitle {
    font-size: 0.875rem;
    color: #aaa;
  }

  /* Expand Chart Button */
  .expand-chart-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    padding: 0.4rem 0.6rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .expand-chart-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  /* Fullscreen Chart Modal */
  .chart-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }

  .chart-modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
  }

  .chart-modal-content {
    position: relative;
    width: calc(100vw - 2rem);
    height: calc(100vh - 2rem);
    max-width: none;
    max-height: none;
    padding: 1.5rem;
    animation: modalSlideIn 0.3s ease;
  }

  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: scale(0.95) translateY(20px);
    }

    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .chart-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
  }

  .chart-modal-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #fff;
  }

  .chart-modal-close {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.25rem;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .chart-modal-close:hover {
    background: rgba(255, 100, 100, 0.3);
    border-color: rgba(255, 100, 100, 0.5);
  }

  .chart-modal-body {
    height: calc(90vh - 120px);
    min-height: 400px;
  }

  .chart-modal-body canvas {
    width: 100% !important;
    height: 100% !important;
  }

  /* ========================================
     MAP
     ======================================== */
  .activity-map {
    height: 300px;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* Custom Leaflet Theming */
  .leaflet-container {
    background: #1a1a2e;
  }

  .leaflet-tile {
    filter: saturate(0.3) brightness(0.6) hue-rotate(200deg);
  }

  /* Route Thumbnail */
  .route-thumbnail-container {
    position: relative;
    margin-bottom: 1rem;
  }

  .route-thumbnail {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .expand-map-btn {
    display: block;
    width: 100%;
    margin-top: 0.75rem;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.2), rgba(255, 27, 141, 0.2));
    border: 1px solid rgba(157, 78, 221, 0.4);
    border-radius: 12px;
    color: #fff;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .expand-map-btn:hover {
    border-color: rgba(255, 27, 141, 0.6);
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.3), rgba(255, 27, 141, 0.3));
    transform: translateY(-2px);
  }

  /* ========================================
     ROUTE THUMBNAIL
     ======================================== */
  .route-thumbnail-container {
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .route-thumbnail-image {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(255, 27, 141, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .route-thumbnail-image:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.4);
  }

  .route-thumbnail-hint {
    font-size: 0.875rem;
    color: #aaa;
    margin-top: 0.5rem;
    font-style: italic;
  }

  /* ========================================
     MUSCLE ACTIVATION HEATMAP
     ======================================== */
  .muscle-heatmap-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 16px;
  }

  .muscle-heatmap-inner {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }

  .muscle-heatmap-inner svg,
  .muscle-heatmap-image {
    max-width: 100%;
    height: auto;
    max-height: 500px;
    filter: drop-shadow(0 0 20px rgba(255, 27, 141, 0.3));
  }

  @media (min-width: 768px) {

    .muscle-heatmap-inner svg,
    .muscle-heatmap-image {
      max-height: 600px;
    }
  }

  /* Route thumbnail SVG styling */
  .route-thumbnail-container svg.route-thumbnail-image {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(255, 27, 141, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .route-thumbnail-container svg.route-thumbnail-image:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.4);
  }

  /* ========================================
     CHARTS
     ======================================== */
  .chart-container {
    position: relative;
    height: 200px;
    width: 100%;
  }

  .hr-summary {
    display: flex;
    justify-content: space-around;
    margin-bottom: 1rem;
    text-align: center;
  }

  .hr-stat-mini {
    display: flex;
    flex-direction: column;
  }

  .hr-value-mini {
    font-size: 1.5rem;
    font-weight: 800;
    color: #ff6b6b;
  }

  .hr-label-mini {
    font-size: 0.75rem;
    color: #aaa;
    text-transform: uppercase;
  }

  /* ========================================
     DESCRIPTION
     ======================================== */
  .activity-description {
    background: rgba(0, 0, 0, 0.3);
    padding: 1.25rem;
    border-radius: 16px;
    white-space: pre-wrap;
    font-family: inherit;
    font-size: 1rem;
    color: #fff;
    line-height: 1.7;
    overflow-x: auto;
    border: 1px solid rgba(255, 255, 255, 0.05);
    margin: 0;
  }

  /* Description Section Cards (parsed from enricher output) */
  .description-section-card {
    animation: fadeInUp 0.5s ease-out backwards;
  }

  #description-sections-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  /* ========================================
     EXERCISES
     ======================================== */
  .exercise-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .exercise-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 1rem 1.25rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 16px;
    border-left: 4px solid #4CC9F0;
    transition: all 0.2s ease;
  }

  .exercise-item:hover {
    background: rgba(0, 0, 0, 0.3);
    border-left-color: #FF1B8D;
  }

  .exercise-name {
    font-weight: 700;
    color: #fff;
    font-size: 1rem;
  }

  .exercise-detail {
    display: flex;
    gap: 1rem;
    font-size: 0.875rem;
    color: #aaa;
    flex-wrap: wrap;
  }

  .exercise-detail span {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .exercise-badge {
    background: linear-gradient(135deg, rgba(76, 201, 240, 0.2), rgba(157, 78, 221, 0.2));
    border: 1px solid rgba(76, 201, 240, 0.3);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
  }

  /* ========================================
     TAGS
     ======================================== */
  .activity-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
  }

  .activity-tag {
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-size: 0.875rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* ========================================
     ENRICHMENTS (BOOSTERS)
     ======================================== */
  .enrichment-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1rem;
  }

  .enrichment-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(255, 27, 141, 0.1));
    border: 1px solid rgba(157, 78, 221, 0.3);
    border-radius: 16px;
    transition: all 0.2s ease;
  }

  .enrichment-item:hover {
    border-color: rgba(255, 27, 141, 0.5);
    transform: translateY(-2px);
  }

  .enrichment-icon {
    font-size: 2rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.2));
  }

  .enrichment-info {
    flex: 1;
  }

  .enrichment-name {
    font-weight: 700;
    color: #fff;
    margin-bottom: 0.125rem;
  }

  .enrichment-desc {
    font-size: 0.875rem;
    color: #aaa;
  }

  /* ========================================
     CTA SECTION
     ======================================== */
  .showcase-cta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1.5rem;
    margin-top: 3rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.25), rgba(255, 27, 141, 0.25));
    border: 1px solid rgba(157, 78, 221, 0.4);
    padding: 2rem;
  }

  .cta-content h3 {
    margin-bottom: 0.5rem;
    font-size: 1.25rem;
    color: #fff;
  }

  .cta-content p {
    color: #aaa;
    font-size: 0.9rem;
    margin: 0;
  }

  .btn {
    display: inline-block;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 50px;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    text-decoration: none;
    transition: all 0.2s ease;
  }

  .btn-primary {
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    color: white;
  }

  .btn-lg {
    padding: 1rem 2rem;
    font-size: 1.1rem;
  }

  .btn-glow {
    animation: glow 2s ease-in-out infinite;
  }

  .btn-primary:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.5);
  }

  @media (max-width: 640px) {
    .showcase-cta {
      flex-direction: column;
      text-align: center;
    }
  }

  /* ========================================
     ATTRIBUTION
     ======================================== */
  .showcase-attribution {
    text-align: center;
    padding: 3rem 0 2rem;
    color: #aaa;
    font-size: 0.9rem;
  }

  .fitglue-logo {
    text-decoration: none;
    font-weight: 900;
    font-size: 1.25rem;
    margin-left: 0.25rem;
  }

  .fit {
    color: #FF1B8D;
  }

  .glue {
    color: #9D4EDD;
  }

  /* ========================================
     MUSCLE ACTIVATION IMAGE
     ======================================== */
  .muscle-activation-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
  }

  /* ========================================
     HYBRID RACE BAR CHART
     ======================================== */
  .hybrid-race-bars {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .hybrid-race-bar-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .hybrid-race-bar-icon {
    font-size: 1.25rem;
    width: 2rem;
    text-align: center;
    flex-shrink: 0;
  }

  .hybrid-race-bar-container {
    flex: 1;
    height: 32px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
  }

  .hybrid-race-bar {
    height: 100%;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 0.75rem;
    min-width: 60px;
    transition: width 0.6s ease-out;
  }

  /* Run segments - cyan/teal */
  .hybrid-race-bar.bar-run {
    background: linear-gradient(90deg, #4CC9F0 0%, #38B6DC 100%);
  }

  /* Station segments - pink/purple gradient */
  .hybrid-race-bar.bar-station {
    background: linear-gradient(90deg, #FF1B8D 0%, #9D4EDD 100%);
  }

  .hybrid-race-bar-time {
    font-size: 0.875rem;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    white-space: nowrap;
  }

  .hybrid-race-bar-label {
    width: 140px;
    font-size: 0.875rem;
    color: #ddd;
    flex-shrink: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  @media (max-width: 640px) {
    .hybrid-race-bar-label {
      width: 100px;
      font-size: 0.75rem;
    }

    .hybrid-race-bar-time {
      font-size: 0.75rem;
    }
  }

  .hybrid-race-total {
    margin-top: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(255, 27, 141, 0.15), rgba(157, 78, 221, 0.15));
    border: 1px solid rgba(255, 27, 141, 0.3);
    border-radius: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .hybrid-race-total-label {
    font-size: 1rem;
    font-weight: 700;
    color: #fff;
  }

  .hybrid-race-total-value {
    font-size: 1.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
</style>

<script>
  // Sims-style rotating jokey fitness messages
  const LOADING_MESSAGES = [
    'Reticulating muscle fibers...',
    'Calibrating sweat glands...',
    'Polishing your running shoes...',
    'Stretching the pixels...',
    'Syncing your chakras...',
    'Buffering endorphins...',
    'Warming up the algorithms...',
    'Hydrating the database...',
    'Massaging the data points...',
    'Doing some light cardio...',
    'Flexing the API...',
    'Counting backwards from 10...',
    'Foam rolling the server...',
    'Adjusting seat to upright position...',
    'Untangling your headphones...',
    'Finding your gym buddy...',
    'Motivating the backend...',
    'Applying anti-chafe cream...',
    'Loading protein shakes...',
    'Activating beast mode...',
  ];

  // Start rotating messages
  let messageIndex = Math.floor(Math.random() * LOADING_MESSAGES.length);
  const loadingMessageEl = document.getElementById('loading-message');

  function rotateMessage() {
    if (loadingMessageEl) {
      loadingMessageEl.classList.add('fade-out');
      setTimeout(() => {
        messageIndex = (messageIndex + 1) % LOADING_MESSAGES.length;
        loadingMessageEl.textContent = LOADING_MESSAGES[messageIndex];
        loadingMessageEl.classList.remove('fade-out');
      }, 300);
    }
  }

  // Set initial message and start rotation
  if (loadingMessageEl) {
    loadingMessageEl.textContent = LOADING_MESSAGES[messageIndex];
  }
  const messageInterval = setInterval(rotateMessage, 2000);

  (async function () {
    // Extract ID from URL path: /showcase/{id}
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    let showcaseId = pathParts[0] === 'showcase' && pathParts[1] ? pathParts[1] : new URLSearchParams(window.location.search).get('id');

    const loadingEl = document.getElementById('showcase-loading');
    const errorEl = document.getElementById('showcase-error');
    const contentEl = document.getElementById('showcase-content');
    const errorMsgEl = document.getElementById('error-message');

    if (!showcaseId) {
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMsgEl.textContent = 'No showcase ID provided.';
      return;
    }

    try {
      const response = await fetch(`/api/showcase/${showcaseId}`);

      if (!response.ok) {
        clearInterval(messageInterval);
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
        errorMsgEl.textContent = response.status === 404 ? "This showcase doesn't exist." :
          response.status === 410 ? 'This showcase has expired.' : 'Failed to load showcase.';
        return;
      }

      const data = await response.json();
      renderShowcase(data);
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      contentEl.style.display = 'block';

    } catch (error) {
      console.error('Error loading showcase:', error);
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMsgEl.textContent = 'An error occurred while loading.';
    }

    function renderShowcase(data) {
      // Title & Meta
      document.getElementById('activity-title').textContent = data.title || 'Activity';
      document.getElementById('activity-type').textContent = formatActivityType(data.activityType);
      document.getElementById('activity-source').textContent = 'from ' + formatSource(data.source);

      // Owner attribution
      if (data.ownerDisplayName) {
        const attrEl = document.getElementById('owner-attribution');
        const slug = data.ownerDisplayName.toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
        attrEl.innerHTML = `by <a href="/u/${slug}" class="owner-name owner-link">${data.ownerDisplayName}</a>`;
        attrEl.style.display = 'flex';
      }

      if (data.startTime) {
        document.getElementById('activity-date').textContent = new Date(data.startTime).toLocaleDateString(undefined, {
          weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });
      }

      // Hide FitGlue branding for Athlete users
      if (data.isAthlete) {
        const cta = document.getElementById('showcase-cta');
        const attribution = document.getElementById('showcase-attribution');
        if (cta) cta.style.display = 'none';
        if (attribution) attribution.style.display = 'none';
      }

      // AI Banner background image
      const bannerUrl = data.enrichmentMetadata?.asset_ai_banner;
      if (bannerUrl) {
        const heroEl = document.querySelector('.showcase-hero');
        heroEl.style.backgroundImage = `url(${bannerUrl})`;
        heroEl.classList.add('has-banner');
      }

      // Stats
      const activity = data.activityData;
      if (activity && activity.sessions && activity.sessions.length > 0) {
        const session = activity.sessions[0];
        const statsGrid = document.getElementById('stats-section');
        const stats = [];

        if (session.totalElapsedTime) stats.push({ icon: '‚è±Ô∏è', value: formatDuration(session.totalElapsedTime), label: 'Duration' });
        if (session.totalDistance) stats.push({ icon: 'üìè', value: formatDistance(session.totalDistance), label: 'Distance' });

        // Cardio stats
        const allRecords = session.laps ? session.laps.flatMap(l => l.records || []) : [];
        const hrValues = allRecords.filter(r => r.heartRate > 0).map(r => r.heartRate);
        if (hrValues.length > 0) {
          const avgHr = Math.round(hrValues.reduce((a, b) => a + b, 0) / hrValues.length);
          stats.push({ icon: '‚ù§Ô∏è', value: avgHr, label: 'Avg BPM' });
        }

        // Power stats
        const powerValues = allRecords.filter(r => r.power > 0).map(r => r.power);
        if (powerValues.length > 0) {
          const avgPower = Math.round(powerValues.reduce((a, b) => a + b, 0) / powerValues.length);
          stats.push({ icon: '‚ö°', value: avgPower + 'W', label: 'Avg Power' });
        }

        // Cadence stats
        const cadenceValues = allRecords.filter(r => r.cadence > 0).map(r => r.cadence);
        if (cadenceValues.length > 0) {
          const avgCadence = Math.round(cadenceValues.reduce((a, b) => a + b, 0) / cadenceValues.length);
          stats.push({ icon: 'ü¶∂', value: avgCadence, label: 'Avg Cadence' });
        }

        // Speed/Pace stats
        const speedValues = allRecords.filter(r => r.speed > 0).map(r => r.speed);
        if (speedValues.length > 0) {
          const avgSpeed = speedValues.reduce((a, b) => a + b, 0) / speedValues.length;
          const avgSpeedKmh = (avgSpeed * 3.6).toFixed(1);
          stats.push({ icon: 'üöÄ', value: avgSpeedKmh + ' km/h', label: 'Avg Speed' });
        }

        // Strength stats
        if (session.strengthSets && session.strengthSets.length > 0) {
          const totalSets = session.strengthSets.length;
          const totalReps = session.strengthSets.reduce((sum, s) => sum + (s.reps || 0), 0);
          const totalWeightCalculated = session.strengthSets.reduce((sum, s) => {
            const reps = s.reps || 0;
            const weight = s.weightKg || 0;
            const distance = s.distanceMeters || 0;
            if (weight > 0) {
              if (reps > 0) return sum + (reps * weight);
              if (distance > 0) return sum + (distance * weight);
            }
            return sum;
          }, 0);
          stats.push({ icon: 'üî¢', value: totalSets, label: 'Sets' });
          stats.push({ icon: 'üí™', value: totalReps, label: 'Reps' });
          if (totalWeightCalculated > 0) stats.push({ icon: '‚öñÔ∏è', value: formatWeight(totalWeightCalculated), label: 'Volume' });
        }

        if (stats.length > 0) {
          statsGrid.innerHTML = stats.map(s => `
          <div class="stat-card">
            <div class="stat-icon">${s.icon}</div>
            <div class="stat-value">${s.value}</div>
            <div class="stat-label">${s.label}</div>
          </div>
        `).join('');
          statsGrid.style.display = 'grid';
        }

        // --- MAP / ROUTE THUMBNAIL ---
        const routeThumbnailUrl = data.enrichmentMetadata?.asset_route_thumbnail;
        const gpsRecords = allRecords.filter(r => r.positionLat && r.positionLong);

        if (routeThumbnailUrl || gpsRecords.length > 10) {
          const mapSection = document.getElementById('map-section');
          mapSection.style.display = 'block';

          if (routeThumbnailUrl) {
            // Display route thumbnail (SVG inline or img)
            const thumbnailContainer = document.createElement('div');
            thumbnailContainer.className = 'route-thumbnail-container';
            renderAsset(routeThumbnailUrl, 'Route Map', 'route-thumbnail-image', thumbnailContainer);
            const mapContainer = document.getElementById('activity-map');
            mapContainer.parentNode.insertBefore(thumbnailContainer, mapContainer);

            // If GPS data exists, show expandable interactive map option
            if (gpsRecords.length > 10) {
              mapContainer.style.display = 'none';
              thumbnailContainer.innerHTML += `
                <button class="expand-map-btn" onclick="document.getElementById('activity-map').style.display='block'; this.style.display='none'; initMap(gpsRecords);">
                  üó∫Ô∏è Show Interactive Map
                </button>
              `;
              // Make gpsRecords accessible to onclick handler
              window.gpsRecords = gpsRecords;
            } else {
              mapContainer.style.display = 'none';
            }
          } else {
            // No thumbnail, show interactive map
            setTimeout(() => initMap(gpsRecords), 100);
          }
        }

        // --- HEART RATE GRAPH ---
        if (hrValues.length > 10) {
          const hrSection = document.getElementById('hr-graph-section');
          const avg = Math.round(hrValues.reduce((a, b) => a + b, 0) / hrValues.length);
          const max = Math.max(...hrValues);
          const min = Math.min(...hrValues);

          document.getElementById('hr-summary').innerHTML = `
            <div class="hr-stat-mini"><span class="hr-value-mini">${avg}</span><span class="hr-label-mini">Avg</span></div>
            <div class="hr-stat-mini"><span class="hr-value-mini">${max}</span><span class="hr-label-mini">Max</span></div>
            <div class="hr-stat-mini"><span class="hr-value-mini">${min}</span><span class="hr-label-mini">Min</span></div>
          `;

          hrSection.style.display = 'block';
          setTimeout(() => initHrChart(allRecords, timeMarkers), 100);
        }

        // --- ELEVATION GRAPH ---
        if (allRecords.some(r => r.altitude !== undefined)) {
          document.getElementById('elevation-section').style.display = 'block';
          setTimeout(() => initElevationChart(allRecords, timeMarkers), 100);
        }

        // --- PACE GRAPH (from speed data) ---
        if (allRecords.filter(r => r.speed > 0).length > 10) {
          document.getElementById('pace-section').style.display = 'block';
          setTimeout(() => initPaceChart(allRecords, timeMarkers), 100);
        }

        // --- POWER GRAPH ---
        if (allRecords.filter(r => r.power > 0).length > 10) {
          document.getElementById('power-section').style.display = 'block';
          setTimeout(() => initPowerChart(allRecords, timeMarkers), 100);
        }

        // --- CADENCE GRAPH ---
        if (allRecords.filter(r => r.cadence > 0).length > 10) {
          document.getElementById('cadence-section').style.display = 'block';
          setTimeout(() => initCadenceChart(allRecords, timeMarkers), 100);
        }

        // --- SPEED GRAPH ---
        if (allRecords.filter(r => r.speed > 0).length > 10) {
          document.getElementById('speed-section').style.display = 'block';
          setTimeout(() => initSpeedChart(allRecords, timeMarkers), 100);
        }

        // --- EXERCISES ---
        if (session.strengthSets && session.strengthSets.length > 0) {
          const exercisesSection = document.getElementById('exercises-section');
          const exerciseList = document.getElementById('exercise-list');

          // Group by exercise name (preserving order)
          const blocks = [];
          const blockMap = {};
          session.strengthSets.forEach(set => {
            const name = set.exerciseName || 'Unknown';
            if (!blockMap[name]) {
              const block = { name, sets: [] };
              blocks.push(block);
              blockMap[name] = block;
            }
            blockMap[name].sets.push(set);
          });

          // Superset detection
          const hasSupersets = blocks.some(b => b.sets[0].supersetId);
          const supersetEmojiMap = {};
          const emojiNumbers = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"];
          let supersetCounter = 0;

          if (hasSupersets) {
            blocks.forEach(b => {
              const sid = b.sets[0].supersetId;
              if (sid && !supersetEmojiMap[sid]) {
                if (supersetCounter < emojiNumbers.length) {
                  supersetEmojiMap[sid] = emojiNumbers[supersetCounter++];
                }
              }
            });
          }

          document.getElementById('exercise-count').textContent = `${blocks.length} exercises`;

          exerciseList.innerHTML = blocks.map(b => {
            let marker = "";
            if (hasSupersets) {
              const sid = b.sets[0].supersetId;
              marker = sid ? (supersetEmojiMap[sid] + " ") : "‚¨ú ";
            }

            const formattedSets = formatCollapsedSets(b.sets);

            return `
            <div class="exercise-item">
              <span class="exercise-name">${marker}${b.name}</span>
              <div class="exercise-detail">
                <span>üìä ${b.sets.length} sets</span>
                ${formattedSets}
              </div>
            </div>
          `;
          }).join('');
          exercisesSection.style.display = 'block';
        }

        // --- MUSCLE ACTIVATION HEATMAP ---
        const heatmapUrl = data.enrichmentMetadata?.asset_muscle_heatmap;
        if (heatmapUrl) {
          const heatmapSection = document.getElementById('muscle-activation-section');
          const heatmapContainer = document.getElementById('muscle-heatmap-container');
          renderAsset(heatmapUrl, 'Muscle Activation Heatmap', 'muscle-heatmap-image', heatmapContainer);
          heatmapSection.style.display = 'block';
        }

        // --- HYBRID RACE BAR CHART ---
        // Note: timeMarkers is on the activity level, not session level
        const timeMarkers = activity.timeMarkers || [];
        const activityName = data.activityData?.name || '';
        const activityTags = data.activityData?.tags || [];

        // Detect hybrid race type from name or tags
        const isHybridRace =
          activityName.toLowerCase().includes('hyrox') ||
          activityName.toLowerCase().includes('athx') ||
          activityTags.some(t => t.toLowerCase().includes('hyrox')) ||
          activityTags.some(t => t.toLowerCase().includes('athx'));

        if (isHybridRace && timeMarkers.length > 0) {
          const hybridSection = document.getElementById('hybrid-race-section');
          const hybridBarsContainer = document.getElementById('hybrid-race-bars');
          const hybridTotal = document.getElementById('hybrid-race-total');
          const hybridName = document.getElementById('hybrid-race-name');

          // Determine race type for subtitle
          const raceType = activityName.toLowerCase().includes('hyrox') ? 'HYROX' : 'ATHX';
          hybridName.textContent = raceType + ' Race';

          // Calculate total duration for bar widths
          let totalDuration = 0;
          const segments = [];

          // Get session total elapsed time to calculate the last segment's duration
          const sessionTotalTime = session.totalElapsedTime || 0;

          for (let i = 0; i < timeMarkers.length; i++) {
            const marker = timeMarkers[i];
            const nextMarker = timeMarkers[i + 1];
            const isLastMarker = i === timeMarkers.length - 1;

            // Calculate duration to next marker or use marker's own duration if available
            let duration = 0;
            if (nextMarker && marker.timestamp && nextMarker.timestamp) {
              const startMs = new Date(marker.timestamp).getTime();
              const endMs = new Date(nextMarker.timestamp).getTime();
              duration = (endMs - startMs) / 1000; // seconds
            } else if (isLastMarker && sessionTotalTime > 0 && totalDuration > 0) {
              // For the last marker, calculate remaining time from session total
              duration = sessionTotalTime - totalDuration;
            } else if (marker.durationSeconds) {
              duration = marker.durationSeconds;
            }

            if (duration > 0) {
              totalDuration += duration;
              segments.push({
                label: marker.label || `Station ${i + 1}`,
                icon: marker.icon || getStationIcon(marker.label || ''),
                duration: duration,
                isRun: (marker.markerType === 'run_start' || marker.label?.toLowerCase().includes('run'))
              });
            }
          }

          // Fallback: If no time markers, try to infer from laps
          if (segments.length === 0 && session.laps && session.laps.length > 0) {
            session.laps.forEach((lap, i) => {
              if (lap.totalElapsedTime > 0) {
                const isRun = lap.exerciseName?.toLowerCase().includes('run') || !lap.exerciseName;
                totalDuration += lap.totalElapsedTime;
                segments.push({
                  label: lap.exerciseName || `Lap ${i + 1}`,
                  icon: getStationIcon(lap.exerciseName || ''),
                  duration: lap.totalElapsedTime,
                  isRun: isRun
                });
              }
            });
          }

          if (segments.length > 0) {
            // Find the longest segment for scaling (so longest bar = 100%)
            const maxDuration = Math.max(...segments.map(s => s.duration));

            // Render the bar chart
            hybridBarsContainer.innerHTML = segments.map(seg => {
              // Scale relative to longest segment, minimum 15% to keep readable
              const widthPercent = Math.max(15, (seg.duration / maxDuration) * 100);
              const barClass = seg.isRun ? 'bar-run' : 'bar-station';
              return `
                <div class="hybrid-race-bar-row">
                  <span class="hybrid-race-bar-icon">${seg.icon}</span>
                  <span class="hybrid-race-bar-label">${seg.label}</span>
                  <div class="hybrid-race-bar-container">
                    <div class="hybrid-race-bar ${barClass}" style="width: ${widthPercent}%;">
                      <span class="hybrid-race-bar-time">${formatTime(seg.duration)}</span>
                    </div>
                  </div>
                </div>
              `;
            }).join('');

            // Render total
            hybridTotal.innerHTML = `
              <span class="hybrid-race-total-label">‚è±Ô∏è Total Race Time</span>
              <span class="hybrid-race-total-value">${formatDuration(totalDuration)}</span>
            `;

            hybridSection.style.display = 'block';
          }
        }

        // Helper function for station icons
        function getStationIcon(name) {
          const n = name.toLowerCase();
          if (n.includes('run')) return 'üèÉ';
          if (n.includes('ski')) return '‚õ∑Ô∏è';
          if (n.includes('sled push')) return 'üõ∑';
          if (n.includes('sled pull')) return 'üõ∑';
          if (n.includes('burpee')) return 'üèãÔ∏è';
          if (n.includes('row')) return 'üö£';
          if (n.includes('farmer')) return 'üß≥';
          if (n.includes('sandbag') || n.includes('lunge')) return 'üéí';
          if (n.includes('wall ball')) return 'üèê';
          return 'üèÅ';
        }
      }

      // Enrichments
      if (data.appliedEnrichments && data.appliedEnrichments.length > 0) {
        const enrichSection = document.getElementById('enrichments-section');
        const badgesEl = document.getElementById('enrichment-badges');
        const registry = data.registry || {};

        badgesEl.innerHTML = data.appliedEnrichments.map(e => {
          const info = registry[e] || {
            icon: '‚ö°',
            name: e.replace('ENRICHER_PROVIDER_', '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
            description: 'Boosted activity data'
          };
          return `
          <div class="enrichment-item">
            <span class="enrichment-icon">${info.icon}</span>
            <div class="enrichment-info">
              <div class="enrichment-name">${info.name}</div>
              <div class="enrichment-desc">${info.description || info.desc}</div>
            </div>
          </div>
        `;
        }).join('');
        enrichSection.style.display = 'block';
      }

      // Muscle Activation Image
      if (data.enrichmentMetadata && data.enrichmentMetadata.asset_muscle_heatmap) {
        const muscleSection = document.getElementById('muscle-activation-section');
        const muscleContainer = document.getElementById('muscle-heatmap-container');
        // Only render if not already rendered above
        if (!muscleContainer.hasChildNodes()) {
          renderAsset(data.enrichmentMetadata.asset_muscle_heatmap, 'Muscle Activation Heatmap', 'muscle-heatmap-image', muscleContainer);
        }
        muscleSection.style.display = 'block';
      }

      // Description - Parse into sections and render as cards
      if (data.description) {
        renderDescriptionSections(data.description);
      }

      // Tags
      if (data.tags && data.tags.length > 0) {
        document.getElementById('tags-section').style.display = 'block';
        document.getElementById('activity-tags').innerHTML = data.tags.map(t =>
          `<span class="activity-tag">${t}</span>`
        ).join('');
      }
    }

    // --- MAP INITIALIZATION ---
    // Make initMap globally accessible for onclick handlers
    window.initMap = function initMap(records) {
      const map = L.map('activity-map', {
        zoomControl: true,
        scrollWheelZoom: false
      });

      // Dark theme tiles
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap, &copy; CARTO',
        maxZoom: 19
      }).addTo(map);

      // Create route polyline with gradient effect
      const latlngs = records.map(r => [r.positionLat, r.positionLong]);

      const routeLine = L.polyline(latlngs, {
        color: '#FF1B8D',
        weight: 4,
        opacity: 0.9,
        lineCap: 'round',
        lineJoin: 'round'
      }).addTo(map);

      // Add start/end markers
      if (latlngs.length > 0) {
        L.circleMarker(latlngs[0], {
          radius: 8,
          fillColor: '#06FFA5',
          color: '#fff',
          weight: 2,
          fillOpacity: 1
        }).addTo(map).bindPopup('Start');

        L.circleMarker(latlngs[latlngs.length - 1], {
          radius: 8,
          fillColor: '#FF1B8D',
          color: '#fff',
          weight: 2,
          fillOpacity: 1
        }).addTo(map).bindPopup('Finish');
      }

      map.fitBounds(routeLine.getBounds(), { padding: [30, 30] });
    }

    // --- ELAPSED TIME HELPER ---
    // Generates time labels for chart X-axis in MM:SS format
    function generateTimeLabels(records) {
      if (!records || records.length === 0) return [];

      const firstRecord = records.find(r => r.timestamp);
      if (!firstRecord) return records.map((_, i) => i); // Fallback to indices

      const startTime = new Date(firstRecord.timestamp).getTime();

      return records.map(r => {
        if (!r.timestamp) return '';
        const elapsed = (new Date(r.timestamp).getTime() - startTime) / 1000; // seconds
        const mins = Math.floor(elapsed / 60);
        const secs = Math.floor(elapsed % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      });
    }

    // --- TIME MARKER ANNOTATIONS HELPER ---
    // Calculates marker positions based on elapsed time from activity start
    function calculateMarkerAnnotations(records, timeMarkers) {
      if (!timeMarkers || timeMarkers.length === 0 || !records || records.length === 0) {
        return {};
      }

      // Find first and last record timestamps to establish time range
      const recordsWithTime = records.filter(r => r.timestamp);
      if (recordsWithTime.length < 2) return {};

      const firstTime = new Date(recordsWithTime[0].timestamp).getTime();
      const lastTime = new Date(recordsWithTime[recordsWithTime.length - 1].timestamp).getTime();
      const totalDuration = lastTime - firstTime;
      if (totalDuration <= 0) return {};

      const annotations = {};
      const colors = ['#4CC9F0', '#FF1B8D', '#9D4EDD', '#FFD93D', '#6BCB77', '#FF6B6B'];

      // Sort markers by timestamp
      const sortedMarkers = [...timeMarkers]
        .filter(m => m.timestamp)
        .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

      sortedMarkers.forEach((marker, idx) => {
        const markerTime = new Date(marker.timestamp).getTime();

        // Calculate where this marker falls as a proportion of total time
        const elapsed = markerTime - firstTime;
        const proportion = elapsed / totalDuration;

        // Map to chart index (0 to records.length - 1)
        const chartIndex = Math.round(proportion * (records.length - 1));

        // Skip if marker is outside the data range
        if (chartIndex < 0 || chartIndex >= records.length) return;

        // Short label for readability
        const fullLabel = marker.label || `M${idx + 1}`;
        const shortLabel = fullLabel.split(' ')[0].substring(0, 10);

        annotations['marker' + idx] = {
          type: 'line',
          xMin: chartIndex,
          xMax: chartIndex,
          borderColor: colors[idx % colors.length],
          borderWidth: 1,
          borderDash: [4, 4],
          label: {
            display: true,
            content: shortLabel,
            position: 'start',
            yAdjust: -5,
            backgroundColor: 'transparent',
            color: colors[idx % colors.length],
            font: { size: 9, weight: 'bold' },
            padding: 2
          }
        };
      });

      return annotations;
    }

    // --- HEART RATE CHART ---
    function initHrChart(records, timeMarkers) {
      const ctx = document.getElementById('hr-chart').getContext('2d');

      // Interpolate missing HR values for continuous line
      const hrData = records.map((r, i) => {
        if (r.heartRate > 0) return r.heartRate;

        // Find nearest valid HR before and after
        let prevHR = null, nextHR = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].heartRate > 0) { prevHR = records[j].heartRate; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].heartRate > 0) { nextHR = records[j].heartRate; break; }
        }

        // Interpolate or use nearest valid
        if (prevHR !== null && nextHR !== null) return (prevHR + nextHR) / 2;
        return prevHR || nextHR || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Heart Rate',
            data: hrData,
            borderColor: '#ff6b6b',
            backgroundColor: 'rgba(255, 107, 107, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            annotation: { annotations }
          },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: {
                color: '#666',
                maxTicksLimit: 8,
                font: { size: 9 }
              }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa' }
            }
          }
        }
      };

      storeChartConfig('hr', config);
      new Chart(ctx, config);
    }

    // --- ELEVATION CHART ---
    function initElevationChart(records, timeMarkers) {
      const ctx = document.getElementById('elevation-chart').getContext('2d');

      // Interpolate missing altitude values
      const elevData = records.map((r, i) => {
        if (r.altitude !== undefined) return r.altitude;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].altitude !== undefined) { prev = records[j].altitude; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].altitude !== undefined) { next = records[j].altitude; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Elevation',
            data: elevData,
            borderColor: '#9D4EDD',
            backgroundColor: 'rgba(157, 78, 221, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + 'm' }
            }
          }
        }
      };

      storeChartConfig('elevation', config);
      new Chart(ctx, config);
    }

    // --- PACE CHART (converts speed m/s to min/km) ---
    function initPaceChart(records, timeMarkers) {
      const ctx = document.getElementById('pace-chart').getContext('2d');

      // Convert speed to pace, interpolate missing values
      const paceData = records.map((r, i) => {
        if (r.speed > 0) {
          const pace = (1000 / r.speed) / 60;
          return pace < 15 ? pace : null; // Cap unreasonable paces
        }

        // Find nearest valid pace
        let prevPace = null, nextPace = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].speed > 0) {
            const p = (1000 / records[j].speed) / 60;
            if (p < 15) { prevPace = p; break; }
          }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].speed > 0) {
            const p = (1000 / records[j].speed) / 60;
            if (p < 15) { nextPace = p; break; }
          }
        }
        if (prevPace !== null && nextPace !== null) return (prevPace + nextPace) / 2;
        return prevPace || nextPace || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Pace',
            data: paceData,
            borderColor: '#FFD93D',
            backgroundColor: 'rgba(255, 217, 61, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              reverse: true, // Lower pace = faster, so reverse axis
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: {
                color: '#aaa',
                callback: v => {
                  const mins = Math.floor(v);
                  const secs = Math.round((v - mins) * 60);
                  return mins + ':' + secs.toString().padStart(2, '0') + '/km';
                }
              }
            }
          }
        }
      };

      storeChartConfig('pace', config);
      new Chart(ctx, config);
    }

    // --- POWER CHART ---
    function initPowerChart(records, timeMarkers) {
      const ctx = document.getElementById('power-chart').getContext('2d');

      // Interpolate missing power values
      const powerData = records.map((r, i) => {
        if (r.power > 0) return r.power;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].power > 0) { prev = records[j].power; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].power > 0) { next = records[j].power; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Power',
            data: powerData,
            borderColor: '#06FFA5',
            backgroundColor: 'rgba(6, 255, 165, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + 'W' }
            }
          }
        }
      };

      storeChartConfig('power', config);
      new Chart(ctx, config);
    }

    // --- CADENCE CHART ---
    function initCadenceChart(records, timeMarkers) {
      const ctx = document.getElementById('cadence-chart').getContext('2d');

      // Interpolate missing cadence values
      const cadenceData = records.map((r, i) => {
        if (r.cadence > 0) return r.cadence;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].cadence > 0) { prev = records[j].cadence; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].cadence > 0) { next = records[j].cadence; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Cadence',
            data: cadenceData,
            borderColor: '#FF6B9D',
            backgroundColor: 'rgba(255, 107, 157, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + ' rpm' }
            }
          }
        }
      };

      storeChartConfig('cadence', config);
      new Chart(ctx, config);
    }

    // --- SPEED CHART (converts m/s to km/h) ---
    function initSpeedChart(records, timeMarkers) {
      const ctx = document.getElementById('speed-chart').getContext('2d');

      // Interpolate missing speed values
      const speedData = records.map((r, i) => {
        if (r.speed > 0) return r.speed * 3.6; // m/s to km/h

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].speed > 0) { prev = records[j].speed * 3.6; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].speed > 0) { next = records[j].speed * 3.6; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Speed',
            data: speedData,
            borderColor: '#00D4FF',
            backgroundColor: 'rgba(0, 212, 255, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v.toFixed(1) + ' km/h' }
            }
          }
        }
      };

      storeChartConfig('speed', config);
      new Chart(ctx, config);
    }

    // --- DESCRIPTION SECTION PARSING ---

    /**
     * Parse enriched description into sections based on enricher headers.
     * Headers follow pattern: emoji + text + colon (e.g., "‚ú® AI Summary:")
     * Handles multi-line sections by grouping content until next header.
     */
    function parseDescriptionSections(text) {
      if (!text) return [];

      // Branding footer to strip entirely (showcase has plenty of FitGlue branding)
      const brandingPattern = /\n?\n?Posted via FitGlue\s*üí™/g;

      // Strip branding from description before parsing
      text = text.replace(brandingPattern, '').trim();
      if (!text) return [];

      // Section headers are lines that END with a colon (nothing after the colon on that line)
      // This elegantly distinguishes:
      //   "üèÅ Hyrox - Male Single:" (section header - line ends with colon)
      //   "üèÉ Run 1: 5:54 (1.1km)" (NOT a section header - has content after colon)
      const lines = text.split('\n');
      const sections = [];
      let currentSection = null;
      let preHeaderContent = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        const prevLine = i > 0 ? lines[i - 1].trim() : '';

        // Check if this line is a section header. Two patterns:
        // 1. Line ends with colon (multi-line sections like "üèÅ Hyrox - Male Single:")
        // 2. Line preceded by blank line AND starts with emoji + colon pattern (single-line like "‚ù§Ô∏è Heart Rate: value")
        const endsWithColon = trimmedLine.endsWith(':') && trimmedLine.length > 1;
        // Single-line sections must start with an emoji (not dash, bullet, etc.)
        const startsWithEmoji = /^[\u{1F300}-\u{1FAD6}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{FE00}-\u{FE0F}\u{1F900}-\u{1F9FF}\u{2300}-\u{23FF}]/u.test(trimmedLine);
        const isSingleLineSection = prevLine === '' && i > 0 && startsWithEmoji && trimmedLine.includes(':');

        if (endsWithColon || isSingleLineSection) {
          // Save any pre-header content as "Description"
          if (currentSection === null && preHeaderContent.length > 0) {
            const content = preHeaderContent.join('\n').trim();
            if (content) {
              sections.push({ emoji: 'üìù', title: 'Description', content: content });
            }
            preHeaderContent = [];
          }

          // Save previous section
          if (currentSection !== null) {
            sections.push(currentSection);
          }

          // Extract emoji and title from header
          let emoji, title, sectionContent;

          if (endsWithColon) {
            // Multi-line section: "üèÅ Title:" - content is on subsequent lines
            const headerText = trimmedLine.slice(0, -1).trim();
            emoji = [...headerText][0] || 'üìù';
            title = headerText.slice(emoji.length).trim() || 'Section';
            sectionContent = '';
          } else {
            // Single-line section: "‚ù§Ô∏è Heart Rate: value" - content is after the colon
            const colonIdx = trimmedLine.indexOf(':');
            const headerText = trimmedLine.slice(0, colonIdx).trim();
            emoji = [...headerText][0] || 'üìù';
            title = headerText.slice(emoji.length).trim() || 'Section';
            sectionContent = trimmedLine.slice(colonIdx + 1).trim();
          }

          currentSection = { emoji, title, content: sectionContent };
        } else if (currentSection === null) {
          // Content before any section header (user description)
          preHeaderContent.push(line);
        } else {
          // Content within current section
          currentSection.content += (currentSection.content ? '\n' : '') + line;
        }
      }

      // Save final section
      if (currentSection !== null) {
        currentSection.content = currentSection.content.trim();
        sections.push(currentSection);
      } else if (preHeaderContent.length > 0) {
        // No sections found - treat all as description
        const content = preHeaderContent.join('\n').trim();
        if (content) {
          sections.push({ emoji: 'üìù', title: 'Description', content: content });
        }
      }

      return sections;
    }

    /**
     * Render parsed sections as individual styled cards.
     * - User description goes to hero section (prominent display)
     * - Compact sections (single-line) are grouped horizontally
     * - Normal sections render as full-width cards
     */
    function renderDescriptionSections(text) {
      const container = document.getElementById('description-sections-container');
      const userDescEl = document.getElementById('user-description');
      const sections = parseDescriptionSections(text);

      if (sections.length === 0) {
        container.style.display = 'none';
        userDescEl.style.display = 'none';
        return;
      }

      // Separate user description from enricher sections
      const userDescSection = sections.find(s => s.title === 'Description');
      const enricherSections = sections.filter(s => s.title !== 'Description');

      // Render user description in hero
      if (userDescSection && userDescSection.content) {
        userDescEl.textContent = userDescSection.content;
        userDescEl.style.display = 'block';
      } else {
        userDescEl.style.display = 'none';
      }

      // If no enricher sections, hide container
      if (enricherSections.length === 0) {
        container.style.display = 'none';
        return;
      }

      // Detect compact sections (single-line, short content)
      const isCompact = (section) => {
        const lines = section.content.split('\n').filter(l => l.trim());
        return lines.length <= 1 && section.content.length < 100;
      };

      // Group consecutive compact sections for horizontal layout
      let html = '';
      let compactGroup = [];
      let idx = 0;

      const flushCompactGroup = () => {
        if (compactGroup.length === 0) return;

        // If single compact section, render normally to avoid orphan
        if (compactGroup.length === 1) {
          compactGroup.forEach(section => {
            html += renderSectionCard(section, idx++);
          });
        } else {
          // Wrap in horizontal row
          html += '<div class="compact-sections-row">';
          compactGroup.forEach(section => {
            html += renderSectionCard(section, idx++);
          });
          html += '</div>';
        }
        compactGroup = [];
      };

      enricherSections.forEach((section) => {
        if (isCompact(section)) {
          compactGroup.push(section);
        } else {
          flushCompactGroup();
          html += renderSectionCard(section, idx++);
        }
      });
      flushCompactGroup();

      container.innerHTML = html;
      container.style.display = 'block';
    }

    /**
     * Render a single section card.
     */
    function renderSectionCard(section, idx) {
      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header">
            <h2>${section.emoji} ${section.title}</h2>
          </div>
          <pre class="activity-description">${escapeHtml(section.content)}</pre>
        </div>
      `;
    }

    /**
     * Escape HTML to prevent XSS when inserting user content.
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // --- CHART MODAL ---

    // Store chart configurations for re-rendering in modal
    const chartConfigs = {};
    let modalChart = null;

    function storeChartConfig(key, config) {
      chartConfigs[key] = config;
    }

    function openChartModal(chartKey, title) {
      const modal = document.getElementById('chart-modal');
      const titleEl = document.getElementById('chart-modal-title');
      const canvas = document.getElementById('chart-modal-canvas');

      if (!chartConfigs[chartKey]) {
        console.warn('No chart config found for:', chartKey);
        return;
      }

      // Set title
      titleEl.textContent = title;

      // Destroy existing modal chart if any
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }

      // Show modal first so canvas has dimensions
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      document.documentElement.style.overflow = 'hidden';

      // Deep clone config to avoid mutating original
      const ctx = canvas.getContext('2d');
      const config = chartConfigs[chartKey];
      const modalConfig = deepCloneConfig(config);

      // Scale up annotation fonts for fullscreen readability
      if (modalConfig.options?.plugins?.annotation?.annotations) {
        Object.values(modalConfig.options.plugins.annotation.annotations).forEach(ann => {
          if (ann.label?.font) {
            ann.label.font.size = 14;
          }
        });
      }

      // Wait a frame for modal dimensions to settle
      requestAnimationFrame(() => {
        modalChart = new Chart(ctx, modalConfig);
      });

      // Close on ESC key
      document.addEventListener('keydown', handleModalEscape);
    }

    // Deep clone chart config, preserving functions
    function deepCloneConfig(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (typeof obj === 'function') return obj;
      if (Array.isArray(obj)) return obj.map(deepCloneConfig);
      const cloned = {};
      for (const key in obj) {
        cloned[key] = deepCloneConfig(obj[key]);
      }
      return cloned;
    }

    function closeChartModal() {
      const modal = document.getElementById('chart-modal');
      modal.style.display = 'none';
      document.body.style.overflow = '';
      document.documentElement.style.overflow = '';

      // Destroy modal chart
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }

      document.removeEventListener('keydown', handleModalEscape);
    }

    function handleModalEscape(e) {
      if (e.key === 'Escape') {
        closeChartModal();
      }
    }

    // Close modal when clicking backdrop
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('chart-modal-backdrop')) {
        closeChartModal();
      }
    });

    // Expose modal functions globally for onclick handlers
    window.openChartModal = openChartModal;
    window.closeChartModal = closeChartModal;

    // --- HELPERS ---

    // Check if URL points to an SVG asset
    function isSvgUrl(url) {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname.toLowerCase();
        return pathname.endsWith('.svg') || pathname.includes('.svg');
      } catch {
        return url.toLowerCase().includes('.svg');
      }
    }

    // Render asset as inline SVG or img based on file type
    function renderAsset(url, alt, className, container) {
      if (isSvgUrl(url)) {
        // Fetch and render SVG inline
        fetch(url)
          .then(res => {
            if (!res.ok) throw new Error('Failed to fetch SVG');
            return res.text();
          })
          .then(text => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'image/svg+xml');
            const svgElement = doc.querySelector('svg');
            if (svgElement) {
              svgElement.removeAttribute('width');
              svgElement.removeAttribute('height');
              svgElement.setAttribute('aria-label', alt);
              svgElement.setAttribute('role', 'img');
              if (className) {
                svgElement.classList.add(...className.split(' '));
              }
              container.innerHTML = svgElement.outerHTML;
            } else {
              // Fallback to img on parse failure
              container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
            }
          })
          .catch(() => {
            // Fallback to img on fetch failure
            container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
          });
      } else {
        // Non-SVG: use img tag
        container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
      }
    }

    function formatActivityType(type) {
      const types = {
        0: 'Workout', 5: 'CrossFit', 12: 'HIIT', 13: 'Hike', 23: 'Ride', 27: 'Run', 37: 'Swim',
        40: 'Trail Run', 45: 'Walk', 46: 'Weight Training', 49: 'Workout', 50: 'Yoga'
      };
      return types[type] || 'Activity';
    }

    function formatSource(source) {
      const sources = { 0: 'Unknown', 1: 'Hevy', 3: 'Fitbit', 4: 'Parkrun', 5: 'FIT Upload', 99: 'Test' };
      return sources[source] || 'Unknown';
    }

    function formatDuration(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      return h > 0 ? `${h}h ${m}m` : `${m}m`;
    }

    function formatDistance(meters) {
      return meters >= 1000 ? `${(meters / 1000).toFixed(1)}km` : `${Math.round(meters)}m`;
    }

    function formatWeight(kg) {
      return kg >= 1000 ? `${(kg / 1000).toFixed(1)}t` : `${Math.round(kg)}kg`;
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.round(seconds % 60);
      return m > 0 ? `${m}:${s.toString().padStart(2, '0')}` : `${s}s`;
    }


    function formatCollapsedSets(sets) {
      if (!sets || sets.length === 0) return "";

      const formattedSets = sets.map(s => formatSingleSet(s));

      // Check if all sets are identical
      const allIdentical = formattedSets.every(s => s === formattedSets[0]);

      if (allIdentical && sets.length > 1) {
        return `<span>üí™ ${sets.length} √ó ${formattedSets[0]}</span>`;
      }

      return formattedSets.map(s => `<span>üí™ ${s}</span>`).join('');
    }

    function formatSingleSet(set) {
      const hasWeight = set.weightKg > 0;
      const hasReps = set.reps > 0;
      const hasDistance = set.distanceMeters > 0;
      const hasTime = set.durationSeconds > 0;

      if (hasDistance || hasTime) {
        const parts = [];
        if (hasDistance) {
          parts.push(formatDistance(set.distanceMeters));
        }
        if (hasTime) {
          const formattedTime = formatTime(set.durationSeconds);
          if (hasDistance) {
            parts.push(`in ${formattedTime}`);
          } else {
            parts.push(formattedTime);
          }
        }
        if (hasWeight) {
          parts.push(`√ó ${Math.round(set.weightKg)}kg`);
        }
        return parts.join(' ');
      }

      // Standard weight lifting
      if (hasWeight && hasReps) {
        return `${set.reps} √ó ${set.weightKg.toFixed(1)}kg`;
      } else if (hasWeight) {
        return `${set.weightKg.toFixed(1)}kg`;
      } else if (hasReps) {
        return `${set.reps} reps`;
      }

      return "Completed";
    }

  })();
</script>

{{>footer}}