{{>header}}
<style>
  header.header {
    display: none !important;
  }

  footer.footer {
    display: none !important;
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
  }
</style>

<section class="showcase-page">
  <canvas class="showcase-particles" id="showcase-particles"></canvas>
  <!-- Loading State - Full FitGlue Experience -->
  <div id="showcase-loading" class="showcase-loading">
    <!-- Animated background gradient -->
    <div class="loading-bg-gradient"></div>

    <div class="loading-content">
      <!-- Animated logo -->
      <div class="loading-logo">
        <span class="loading-logo-fit">Fit</span><span class="loading-logo-glue">Glue</span>
      </div>

      <!-- Premium multi-ring spinner -->
      <div class="loading-spinner-container">
        <div class="loading-spinner-ring"></div>
        <div class="loading-spinner-ring loading-spinner-ring-2"></div>
        <div class="loading-spinner-ring loading-spinner-ring-3"></div>
      </div>

      <!-- Rotating funny messages -->
      <p id="loading-message" class="loading-message">Loading activity...</p>
    </div>
  </div>

  <!-- Error State -->
  <div id="showcase-error" class="showcase-error" style="display: none;">
    <div class="error-icon">üèÉüèÉ‚Äç‚ôÇÔ∏èüèÉ‚Äç‚ôÄÔ∏è</div>
    <h1>This Activity Got Away!</h1>
    <p id="error-message">Looks like this showcase sprinted off before we could catch it.</p>
    <p class="error-subtitle">It may have expired, or perhaps the link has a typo.</p>
    <a href="/" class="btn btn-primary">Explore FitGlue</a>
  </div>


  <!-- Success State -->
  <div id="showcase-content" class="showcase-content" style="display: none;">

    <!-- Hero Header -->
    <div class="showcase-hero">
      <h1 id="activity-title" class="showcase-title"></h1>
      <div id="owner-attribution" class="owner-attribution" style="display: none;"></div>
      <div class="showcase-meta">
        <span id="activity-type" class="activity-type-badge"></span>
        <span id="activity-source" class="activity-source"></span>
        <span id="activity-date" class="activity-date"></span>
      </div>
      <!-- User-provided description - prominent display -->
      <div id="user-description" class="user-description" style="display: none;"></div>
    </div>

    <!-- AI Summary - promoted to appear right after user description -->
    <div id="ai-summary-container" style="display: none;"></div>

    <!-- Stats Grid - Hero Cards -->
    <div id="stats-section" class="stats-grid" style="display: none;"></div>

    <!-- Hybrid Race Breakdown - PRIORITY POSITION for race activities -->
    <div id="hybrid-race-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üèÅ Race Breakdown</h2>
        <span id="hybrid-race-name" class="section-subtitle"></span>
      </div>
      <div id="hybrid-race-bars" class="hybrid-race-bars"></div>
      <div id="hybrid-race-total" class="hybrid-race-total"></div>
    </div>

    <!-- Map Section -->
    <div id="map-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üó∫Ô∏è Route</h2>
      </div>
      <div id="activity-map" class="activity-map"></div>
    </div>

    <!-- Heart Rate Graph -->
    <div id="hr-graph-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ù§Ô∏è Heart Rate</h2>
        <button class="expand-chart-btn" onclick="openChartModal('hr', '‚ù§Ô∏è Heart Rate')" title="Expand">‚õ∂</button>
      </div>
      <div class="hr-summary" id="hr-summary"></div>
      <div class="chart-container">
        <canvas id="hr-chart"></canvas>
      </div>
    </div>

    <!-- Elevation Graph -->
    <div id="elevation-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚õ∞Ô∏è Elevation</h2>
        <button class="expand-chart-btn" onclick="openChartModal('elevation', '‚õ∞Ô∏è Elevation')" title="Expand">‚õ∂</button>
      </div>
      <div class="graph-summary" id="elevation-summary"></div>
      <div class="chart-container">
        <canvas id="elevation-chart"></canvas>
      </div>
    </div>

    <!-- Pace Graph -->
    <div id="pace-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ö° Pace</h2>
        <button class="expand-chart-btn" onclick="openChartModal('pace', '‚ö° Pace')" title="Expand">‚õ∂</button>
      </div>
      <div class="graph-summary" id="pace-summary"></div>
      <div class="chart-container">
        <canvas id="pace-chart"></canvas>
      </div>
    </div>

    <!-- Power Graph -->
    <div id="power-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ö° Power</h2>
        <button class="expand-chart-btn" onclick="openChartModal('power', '‚ö° Power')" title="Expand">‚õ∂</button>
      </div>
      <div class="graph-summary" id="power-summary"></div>
      <div class="chart-container">
        <canvas id="power-chart"></canvas>
      </div>
    </div>

    <!-- Cadence Graph -->
    <div id="cadence-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>ü¶∂ Cadence</h2>
        <button class="expand-chart-btn" onclick="openChartModal('cadence', 'ü¶∂ Cadence')" title="Expand">‚õ∂</button>
      </div>
      <div class="graph-summary" id="cadence-summary"></div>
      <div class="chart-container">
        <canvas id="cadence-chart"></canvas>
      </div>
    </div>

    <!-- Speed Graph -->
    <div id="speed-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üöÄ Speed</h2>
        <button class="expand-chart-btn" onclick="openChartModal('speed', 'üöÄ Speed')" title="Expand">‚õ∂</button>
      </div>
      <div class="graph-summary" id="speed-summary"></div>
      <div class="chart-container">
        <canvas id="speed-chart"></canvas>
      </div>
    </div>

    <!-- Description Sections (parsed from enricher output) -->
    <div id="description-sections-container" style="display: none;"></div>

    <!-- Muscle Activation Heatmap -->
    <div id="muscle-activation-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üî• Muscle Activation</h2>
        <span class="section-subtitle">Visual breakdown of muscle engagement</span>
      </div>
      <div class="muscle-heatmap-container">
        <div id="muscle-heatmap-container" class="muscle-heatmap-inner"></div>
      </div>
    </div>

    <!-- Strength Sets / Exercises -->
    <div id="exercises-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üí™ Exercises</h2>
        <span id="exercise-count" class="section-subtitle"></span>
      </div>
      <div id="exercise-list" class="exercise-list"></div>
    </div>


    <!-- Tags -->
    <div id="tags-section" class="showcase-section" style="display: none;">
      <div id="activity-tags" class="activity-tags"></div>
    </div>

    <!-- Enrichments Applied (Premium Feature) - MOVED TO BOTTOM -->
    <div id="enrichments-section" class="showcase-section" style="display: none;">
      <div class="section-header">
        <h2>üöÄ Boosters Applied</h2>
        <span class="section-subtitle">FitGlue Boosters applied to this activity</span>
      </div>
      <div id="enrichment-badges" class="enrichment-list"></div>
    </div>

    <!-- CTA - MOVED TO BOTTOM -->
    <div id="showcase-cta" class="showcase-cta glass-card">
      <div class="cta-content">
        <h3>Want to enhance your own activities?</h3>
        <p>FitGlue automatically enriches your workouts with muscle heatmaps, heart rate data, and beautiful
          summaries.</p>
      </div>
      <a href="/" class="btn btn-primary btn-lg btn-glow">Try FitGlue Free</a>
    </div>

    <!-- Footer Attribution -->
    <div id="showcase-attribution" class="showcase-attribution">
      <span>Powered by</span>
      <a href="/" class="fitglue-logo">
        <span class="fit">Fit</span><span class="glue">Glue</span>
      </a>
    </div>
  </div>
</section>
</main>

<!-- Fullscreen Chart Modal (outside showcase-page to avoid overflow:hidden clipping on mobile) -->
<div id="chart-modal" class="chart-modal" style="display: none;">
  <div class="chart-modal-backdrop"></div>
  <div class="chart-modal-content glass-card">
    <div class="chart-modal-header">
      <h2 id="chart-modal-title"></h2>
      <button class="chart-modal-close" onclick="closeChartModal()">‚úï</button>
    </div>
    <div class="chart-modal-body">
      <canvas id="chart-modal-canvas"></canvas>
    </div>
  </div>
</div>

<!-- External Dependencies -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>

<style>
  /* ========================================
     SHOWCASE PAGE - WORLD CLASS DESIGN
     ======================================== */

  .showcase-page {
    min-height: 100vh;
    background: linear-gradient(180deg, #0a0a0a 0%, #1a0a20 50%, #0a0a0a 100%);
    padding: 0;
  }

  .showcase-loading {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0A0A0A;
    z-index: 9999;
    overflow: hidden;
  }

  /* Animated background gradient */
  .loading-bg-gradient {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(ellipse at 20% 20%, rgba(255, 27, 141, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(157, 78, 221, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 50%, rgba(76, 201, 240, 0.03) 0%, transparent 70%);
    animation: loading-bg-pulse 4s ease-in-out infinite;
  }

  @keyframes loading-bg-pulse {

    0%,
    100% {
      opacity: 0.6;
      transform: scale(1);
    }

    50% {
      opacity: 1;
      transform: scale(1.05);
    }
  }

  /* Content container */
  .loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    animation: loading-fade-in 0.6s ease-out;
    z-index: 1;
  }

  @keyframes loading-fade-in {
    from {
      opacity: 0;
      transform: translateY(10px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Logo styling */
  .loading-logo {
    font-size: clamp(2.5rem, 8vw, 4rem);
    font-weight: 900;
    letter-spacing: -0.02em;
    display: flex;
    gap: 0;
  }

  .loading-logo-fit {
    background: linear-gradient(135deg, #FF1B8D 0%, #FF6BB3 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: loading-logo-shimmer 2s ease-in-out infinite;
  }

  .loading-logo-glue {
    background: linear-gradient(135deg, #9D4EDD 0%, #C77DFF 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: loading-logo-shimmer 2s ease-in-out infinite 0.15s;
  }

  @keyframes loading-logo-shimmer {

    0%,
    100% {
      opacity: 0.9;
      filter: brightness(1);
    }

    50% {
      opacity: 1;
      filter: brightness(1.2);
    }
  }

  /* Premium multi-ring spinner */
  .loading-spinner-container {
    position: relative;
    width: 60px;
    height: 60px;
  }

  .loading-spinner-ring {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 3px solid transparent;
    border-top-color: #FF1B8D;
    animation: spin 1.2s cubic-bezier(0.5, 0.1, 0.5, 0.9) infinite;
  }

  .loading-spinner-ring-2 {
    inset: 6px;
    border-top-color: #9D4EDD;
    animation-duration: 1.8s;
    animation-direction: reverse;
  }

  .loading-spinner-ring-3 {
    inset: 12px;
    border-top-color: #4CC9F0;
    animation-duration: 2.4s;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  /* Message styling */
  .loading-message {
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.5);
    font-weight: 500;
    letter-spacing: 0.01em;
    min-height: 1.5em;
    transition: opacity 0.3s ease;
  }

  .loading-message.fade-out {
    opacity: 0;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes shimmer {
    to {
      background-position: 200% center;
    }
  }

  @keyframes pulse {

    0%,
    100% {
      transform: scale(1);
    }

    50% {
      transform: scale(1.05);
    }
  }

  @keyframes glow {

    0%,
    100% {
      box-shadow: 0 0 20px rgba(255, 27, 141, 0.4);
    }

    50% {
      box-shadow: 0 0 40px rgba(255, 27, 141, 0.8);
    }
  }

  /* Error State */
  .showcase-error {
    text-align: center;
    max-width: 500px;
    margin: 15vh auto 0;
    padding: 2rem;
    background: rgba(30, 30, 40, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
  }

  .error-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
  }

  .showcase-error h1 {
    font-size: clamp(1.5rem, 4vw, 2.2rem);
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .showcase-error p {
    font-size: 1rem;
    color: #aaa;
    margin-bottom: 0.5rem;
  }

  .error-subtitle {
    font-size: 0.875rem !important;
    opacity: 0.7;
    margin-bottom: 1.5rem !important;
  }

  /* Content Container - No bounding box on mobile */
  .showcase-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
    animation: fadeInUp 0.6s ease-out;
  }

  @media (min-width: 768px) {
    .showcase-content {
      padding: 0 2rem;
    }
  }

  /* ========================================
     HERO SECTION
     ======================================== */
  .showcase-hero {
    text-align: center;
    padding: 3rem 1rem 2rem;
    margin-bottom: 1.5rem;
    position: relative;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 24px;
    overflow: hidden;
  }

  /* Dark overlay for text readability when banner is present */
  .showcase-hero.has-banner {
    min-height: 350px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .showcase-hero.has-banner::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.4);
    z-index: 0;
  }

  .showcase-hero.has-banner>* {
    position: relative;
    z-index: 1;
  }

  .showcase-title {
    font-size: clamp(2.5rem, 8vw, 4rem);
    font-weight: 900;
    margin-bottom: 1rem;
    background: linear-gradient(90deg,
        #FF1B8D 0%,
        #9D4EDD 25%,
        #fff 50%,
        #9D4EDD 75%,
        #FF1B8D 100%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    line-height: 1.1;
    animation: shimmer 3s linear infinite;
    text-shadow: 0 0 60px rgba(255, 27, 141, 0.3);
  }

  .showcase-meta {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  /* User-provided description - big, bold, beautiful */
  .user-description {
    margin-top: 1.5rem;
    padding: 0 1rem;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    font-size: 1.25rem;
    font-style: italic;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
    line-height: 1.6;
    position: relative;
  }

  .user-description::before {
    content: '"';
    font-size: 3rem;
    font-family: Georgia, serif;
    position: absolute;
    left: -0.5rem;
    top: -0.5rem;
    opacity: 0.3;
    color: #9D4EDD;
  }

  /* Compact sections container - horizontal stacking */
  .compact-sections-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
  }

  .compact-sections-row .description-section-card {
    flex: 1 1 280px;
    max-width: 400px;
    min-width: 250px;
  }

  @media (max-width: 600px) {
    .compact-sections-row .description-section-card {
      flex: 1 1 100%;
      max-width: 100%;
    }
  }

  .owner-attribution {
    font-size: 1.1rem;
    color: #aaa;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }

  .owner-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid rgba(255, 27, 141, 0.4);
    overflow: hidden;
    flex-shrink: 0;
  }

  .owner-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .owner-name {
    font-weight: 700;
    color: #fff;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .owner-link {
    text-decoration: none;
    cursor: pointer;
    transition: filter 0.2s ease;
  }

  .owner-link:hover {
    filter: brightness(1.3);
  }

  .activity-type-badge {
    background: linear-gradient(135deg, #4CC9F0, #9D4EDD);
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-weight: 700;
    font-size: 0.875rem;
    color: white;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    box-shadow: 0 4px 15px rgba(76, 201, 240, 0.3);
  }

  .activity-source,
  .activity-date {
    color: #aaa;
    font-size: 0.875rem;
  }

  /* ========================================
     HERO STATS GRID
     ======================================== */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
    padding: 0;
  }

  .stat-card {
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    padding: 1.5rem 1rem;
    text-align: center;
    transition: all 0.3s ease;
    animation: fadeInUp 0.6s ease-out backwards;
  }

  .stat-card:nth-child(1) {
    animation-delay: 0.1s;
  }

  .stat-card:nth-child(2) {
    animation-delay: 0.15s;
  }

  .stat-card:nth-child(3) {
    animation-delay: 0.2s;
  }

  .stat-card:nth-child(4) {
    animation-delay: 0.25s;
  }

  .stat-card:nth-child(5) {
    animation-delay: 0.3s;
  }

  .stat-card:hover {
    transform: translateY(-4px);
    border-color: rgba(255, 27, 141, 0.4);
    box-shadow: 0 10px 40px rgba(255, 27, 141, 0.2);
  }

  .stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
  }

  .stat-value {
    font-size: clamp(1.75rem, 5vw, 2.5rem);
    font-weight: 900;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    line-height: 1.2;
  }

  .stat-label {
    font-size: 0.75rem;
    color: #aaa;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-top: 0.25rem;
  }

  /* ========================================
     GLASS CARDS
     ======================================== */
  .glass-card {
    background: rgba(30, 30, 40, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    animation: fadeInUp 0.6s ease-out backwards;
  }

  .showcase-section {
    margin-bottom: 1.5rem;
  }

  .section-header {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .section-header h2 {
    font-size: 1.25rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
    color: #fff;
  }

  .section-subtitle {
    font-size: 0.875rem;
    color: #aaa;
  }

  /* Expand Chart Button */
  .expand-chart-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    padding: 0.4rem 0.6rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .expand-chart-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  /* Fullscreen Chart Modal */
  .chart-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }

  .chart-modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
  }

  .chart-modal-content {
    position: relative;
    width: calc(100vw - 2rem);
    height: calc(100vh - 2rem);
    height: calc(100dvh - 2rem);
    max-width: none;
    max-height: none;
    padding: 1.5rem;
    animation: modalSlideIn 0.3s ease;
    overflow: hidden;
  }

  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: scale(0.95) translateY(20px);
    }

    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .chart-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
  }

  .chart-modal-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #fff;
  }

  .chart-modal-close {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.25rem;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .chart-modal-close:hover {
    background: rgba(255, 100, 100, 0.3);
    border-color: rgba(255, 100, 100, 0.5);
  }

  .chart-modal-body {
    height: calc(100% - 4rem);
    overflow: auto;
  }

  .chart-modal-body canvas {
    width: 100% !important;
    height: 100% !important;
  }

  /* ========================================
     MAP
     ======================================== */
  .activity-map {
    height: 300px;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* Custom Leaflet Theming */
  .leaflet-container {
    background: #1a1a2e;
  }

  .leaflet-tile {
    filter: saturate(0.3) brightness(0.6) hue-rotate(200deg);
  }

  /* Route Thumbnail */
  .route-thumbnail-container {
    position: relative;
    margin-bottom: 1rem;
  }

  .route-thumbnail {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .expand-map-btn {
    display: block;
    width: 100%;
    margin-top: 0.75rem;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.2), rgba(255, 27, 141, 0.2));
    border: 1px solid rgba(157, 78, 221, 0.4);
    border-radius: 12px;
    color: #fff;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .expand-map-btn:hover {
    border-color: rgba(255, 27, 141, 0.6);
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.3), rgba(255, 27, 141, 0.3));
    transform: translateY(-2px);
  }

  /* ========================================
     ROUTE THUMBNAIL
     ======================================== */
  .route-thumbnail-container {
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .route-thumbnail-image {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(255, 27, 141, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .route-thumbnail-image:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.4);
  }

  .route-thumbnail-hint {
    font-size: 0.875rem;
    color: #aaa;
    margin-top: 0.5rem;
    font-style: italic;
  }

  /* ========================================
     MUSCLE ACTIVATION HEATMAP
     ======================================== */
  .muscle-heatmap-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 16px;
  }

  .muscle-heatmap-inner {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }

  .muscle-heatmap-inner svg,
  .muscle-heatmap-image {
    max-width: 100%;
    height: auto;
    max-height: 500px;
    filter: drop-shadow(0 0 20px rgba(255, 27, 141, 0.3));
  }

  @media (min-width: 768px) {

    .muscle-heatmap-inner svg,
    .muscle-heatmap-image {
      max-height: 600px;
    }
  }

  /* Route thumbnail SVG styling */
  .route-thumbnail-container svg.route-thumbnail-image {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(255, 27, 141, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .route-thumbnail-container svg.route-thumbnail-image:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.4);
  }

  /* ========================================
     CHARTS
     ======================================== */
  .chart-container {
    position: relative;
    height: 200px;
    width: 100%;
  }

  .hr-summary {
    display: flex;
    justify-content: space-around;
    margin-bottom: 1rem;
    text-align: center;
  }

  .hr-stat-mini {
    display: flex;
    flex-direction: column;
  }

  .hr-value-mini {
    font-size: 1.5rem;
    font-weight: 800;
    color: #ff6b6b;
  }

  .hr-label-mini {
    font-size: 0.75rem;
    color: #aaa;
    text-transform: uppercase;
  }

  /* ========================================
     DESCRIPTION
     ======================================== */
  .activity-description {
    background: rgba(0, 0, 0, 0.3);
    padding: 1.25rem;
    border-radius: 16px;
    white-space: pre-wrap;
    font-family: inherit;
    font-size: 1rem;
    color: #fff;
    line-height: 1.7;
    overflow-x: auto;
    border: 1px solid rgba(255, 255, 255, 0.05);
    margin: 0;
  }

  /* Description Section Cards (parsed from enricher output) */
  .description-section-card {
    animation: fadeInUp 0.5s ease-out backwards;
  }

  #description-sections-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  /* ========================================
     PERSONAL RECORDS CARDS
     ======================================== */
  .pr-records-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 0.75rem;
  }

  .pr-card {
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.02));
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.1rem 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    transition: all 0.25s ease;
    animation: fadeInUp 0.4s ease-out backwards;
    position: relative;
    overflow: hidden;
  }

  .pr-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--pr-accent, rgba(255, 27, 141, 0.08)), transparent 60%);
    pointer-events: none;
  }

  .pr-card:hover {
    transform: translateY(-3px);
    border-color: var(--pr-accent, rgba(255, 27, 141, 0.3));
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3), 0 0 20px var(--pr-accent, rgba(255, 27, 141, 0.1));
  }

  .pr-card.pr-type-1rm {
    --pr-accent: rgba(255, 27, 141, 0.15);
  }

  .pr-card.pr-type-volume {
    --pr-accent: rgba(157, 78, 221, 0.15);
  }

  .pr-card.pr-type-reps {
    --pr-accent: rgba(76, 201, 240, 0.15);
  }

  .pr-card.pr-type-time {
    --pr-accent: rgba(6, 255, 165, 0.15);
  }

  .pr-card.pr-type-distance {
    --pr-accent: rgba(255, 159, 67, 0.15);
  }

  .pr-card-top {
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }

  .pr-emoji {
    font-size: 1.5rem;
    filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.2));
    flex-shrink: 0;
  }

  .pr-name {
    font-size: 0.82rem;
    font-weight: 700;
    color: #fff;
    line-height: 1.25;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }

  .pr-value {
    font-size: 1.5rem;
    font-weight: 900;
    letter-spacing: -0.02em;
    line-height: 1.15;
    position: relative;
    z-index: 1;
  }

  .pr-value.gradient-1rm {
    background: linear-gradient(135deg, #FF1B8D, #FF6BB3);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-volume {
    background: linear-gradient(135deg, #9D4EDD, #C77DFF);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-reps {
    background: linear-gradient(135deg, #4CC9F0, #80DAFF);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-time {
    background: linear-gradient(135deg, #06FFA5, #4ADE80);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-distance {
    background: linear-gradient(135deg, #FF9F43, #FFD93D);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-type-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #888;
    font-weight: 600;
  }

  .pr-improvement {
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.45rem;
    border-radius: 20px;
    width: fit-content;
    position: relative;
    z-index: 1;
  }

  .pr-improvement.positive {
    background: rgba(6, 255, 165, 0.12);
    color: #4ADE80;
    border: 1px solid rgba(6, 255, 165, 0.2);
  }

  .pr-improvement.negative {
    background: rgba(255, 100, 100, 0.12);
    color: #FF6B6B;
    border: 1px solid rgba(255, 100, 100, 0.2);
  }

  @media (max-width: 480px) {
    .pr-records-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .pr-value {
      font-size: 1.2rem;
    }

    .pr-emoji {
      font-size: 1.2rem;
    }

    .pr-name {
      font-size: 0.75rem;
    }
  }

  /* ========================================
     INTERVALS TIMELINE
     ======================================== */
  .intervals-timeline {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  /* --- Standalone rows (warmup / cooldown) --- */
  .interval-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 0.55rem 0.75rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--interval-accent, rgba(255, 255, 255, 0.15));
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .interval-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .interval-row.warmup {
    --interval-accent: #4ADE80;
  }

  .interval-row.cooldown {
    --interval-accent: #60A5FA;
  }

  /* --- Group card (header + sub-rows) --- */
  .interval-group-card {
    border-radius: 14px;
    border: 1px solid rgba(157, 78, 221, 0.2);
    background: rgba(157, 78, 221, 0.04);
    overflow: hidden;
    animation: fadeInUp 0.3s ease-out backwards;
  }

  .interval-group-header {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 0.65rem 0.85rem;
    background: rgba(157, 78, 221, 0.08);
    border-left: 4px solid #C77DFF;
  }

  .interval-group-header .interval-label {
    font-weight: 600;
    font-size: 0.85rem;
    color: #e0d0f0;
  }

  .interval-sub-rows {
    display: flex;
    flex-direction: column;
  }

  .interval-sub-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.4rem 0.75rem 0.4rem 1.8rem;
    border-top: 1px solid rgba(255, 255, 255, 0.04);
    transition: background 0.2s;
  }

  .interval-sub-row:hover {
    background: rgba(255, 255, 255, 0.04);
  }

  .interval-sub-row .interval-label {
    font-size: 0.78rem;
    color: #aaa;
  }

  /* --- Insight rows (Active vs Recovery, Getting faster, etc.) --- */
  .interval-row.insight {
    --interval-accent: rgba(255, 255, 255, 0.15);
    border-left-style: dashed;
    background: rgba(255, 255, 255, 0.02);
    gap: 0.5rem;
  }

  .interval-row.insight .interval-label {
    font-size: 0.8rem;
    color: #bbb;
  }

  .interval-insight-metrics {
    display: flex;
    gap: 0.4rem;
    flex-shrink: 0;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  .interval-insight-metric {
    font-size: 0.72rem;
    font-weight: 600;
    padding: 0.12rem 0.45rem;
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.06);
    color: #ccc;
    white-space: nowrap;
  }

  /* --- Insight cards: Active vs Recovery & Pace Trend --- */
  .interval-insight-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 10px;
    padding: 0.7rem 0.9rem;
    margin-top: 0.4rem;
  }

  .insight-card-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.55rem;
    font-size: 0.82rem;
    color: #bbb;
    font-weight: 500;
  }

  /* Active vs Recovery comparison */
  .insight-comparison {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .insight-comparison-value {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.15rem;
  }

  .insight-comparison-value .value {
    font-size: 1.15rem;
    font-weight: 700;
    color: #fff;
  }

  .insight-comparison-value .label {
    font-size: 0.65rem;
    color: #999;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .hr-drift-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.2rem 0.6rem;
    border-radius: 8px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-top: 0.3rem;
  }

  .hr-drift-badge.warning {
    background: rgba(251, 146, 60, 0.15);
    color: #fb923c;
    border: 1px solid rgba(251, 146, 60, 0.25);
  }

  .hr-drift-badge.normal {
    background: rgba(74, 222, 128, 0.15);
    color: #4ade80;
    border: 1px solid rgba(74, 222, 128, 0.25);
  }

  /* --- Graph summary bars (shared across all chart sections) --- */
  .graph-summary {
    display: flex;
    justify-content: space-around;
    margin-bottom: 1rem;
    text-align: center;
  }

  .graph-summary:empty {
    display: none;
  }

  .graph-stat-mini {
    display: flex;
    flex-direction: column;
    gap: 0.1rem;
  }

  .graph-value-mini {
    font-size: 1.3rem;
    font-weight: 800;
    color: #fff;
  }

  .graph-label-mini {
    font-size: 0.65rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.8px;
  }

  /* Color coding for graph summary values */
  .graph-value-mini.pace {
    color: #fbbf24;
  }

  .graph-value-mini.power {
    color: #c084fc;
  }

  .graph-value-mini.cadence {
    color: #34d399;
  }

  .graph-value-mini.speed {
    color: #60a5fa;
  }

  .graph-value-mini.elevation-gain {
    color: #4ade80;
  }

  .graph-value-mini.elevation-loss {
    color: #f87171;
  }

  .graph-value-mini.elevation-max {
    color: #fbbf24;
  }

  /* --- Heart Rate dashboard (when no graph) --- */
  .hr-dashboard {
    display: flex;
    justify-content: space-around;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0;
    flex-wrap: wrap;
  }

  .hr-dashboard-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.1rem;
  }

  .hr-dashboard-value {
    font-size: 1.8rem;
    font-weight: 800;
  }

  .hr-dashboard-value.min {
    color: #60a5fa;
  }

  .hr-dashboard-value.avg {
    color: #fff;
  }

  .hr-dashboard-value.max {
    color: #f87171;
  }

  .hr-dashboard-label {
    font-size: 0.65rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.8px;
  }

  .hr-dashboard-unit {
    font-size: 0.8rem;
    color: #666;
    font-weight: 400;
  }

  /* --- Recovery Advisor card --- */
  .recovery-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.6rem;
    margin-bottom: 0.5rem;
  }

  .recovery-grid.has-acwr {
    grid-template-columns: 1fr 1fr 1fr;
  }

  @media (max-width: 480px) {
    .recovery-grid.has-acwr {
      grid-template-columns: 1fr 1fr;
    }
  }

  .recovery-stat-block {
    background: rgba(255, 255, 255, 0.04);
    border-radius: 8px;
    padding: 0.5rem 0.6rem;
    text-align: center;
  }

  .recovery-stat-value {
    font-size: 1.2rem;
    font-weight: 700;
    color: #fff;
  }

  .recovery-stat-sub {
    font-size: 0.7rem;
    color: #64748b;
    margin-top: 0.1rem;
  }

  .recovery-stat-label {
    font-size: 0.65rem;
    color: #888;
    text-transform: uppercase;
    margin-top: 0.15rem;
  }

  .recovery-stat-hint {
    font-size: 0.62rem;
    color: #64748b;
    margin-top: 0.15rem;
    font-style: italic;
    line-height: 1.3;
  }

  .recovery-stat-tag {
    font-size: 0.6rem;
    padding: 0.1rem 0.35rem;
    border-radius: 4px;
    margin-left: 0.3rem;
    font-weight: 600;
  }

  .recovery-stat-tag.easy,
  .recovery-stat-tag.recovery {
    background: rgba(74, 222, 128, 0.2);
    color: #4ade80;
  }

  .recovery-stat-tag.moderate,
  .recovery-stat-tag.optimal {
    background: rgba(251, 191, 36, 0.2);
    color: #fbbf24;
  }

  .recovery-stat-tag.hard,
  .recovery-stat-tag.building {
    background: rgba(251, 146, 60, 0.2);
    color: #fb923c;
  }

  .recovery-stat-tag.overreaching {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
  }

  .recovery-stat-tag.detraining {
    background: rgba(103, 232, 249, 0.2);
    color: #67e8f9;
  }

  .recovery-fatigue-warning {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(251, 146, 60, 0.08);
    border: 1px solid rgba(251, 146, 60, 0.25);
    border-radius: 8px;
    padding: 0.4rem 0.7rem;
    color: #fb923c;
    font-size: 0.78rem;
    margin-bottom: 0.4rem;
  }

  .recovery-suggestion {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(96, 165, 250, 0.08);
    border: 1px solid rgba(96, 165, 250, 0.2);
    border-radius: 8px;
    padding: 0.5rem 0.7rem;
    color: #94a3b8;
    font-size: 0.82rem;
  }

  .recovery-suggestion .icon {
    font-size: 1.1rem;
  }

  .recovery-suggestion .value {
    color: #60a5fa;
    font-weight: 700;
  }

  /* --- Calories section --- */
  .calories-display {
    display: flex;
    align-items: center;
    gap: 1rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .calories-value-block {
    text-align: center;
  }

  .calories-number {
    font-size: 2.2rem;
    font-weight: 800;
    color: #fbbf24;
  }

  .calories-unit {
    font-size: 0.75rem;
    color: #888;
    text-transform: uppercase;
  }

  .calories-food-callout {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    background: rgba(251, 191, 36, 0.1);
    border: 1px solid rgba(251, 191, 36, 0.2);
    border-radius: 10px;
    padding: 0.4rem 0.7rem;
    font-size: 0.85rem;
    color: #fbbf24;
    font-weight: 500;
  }

  /* --- Training Load gauge --- */
  .training-load-display {
    display: flex;
    align-items: center;
    gap: 1rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .training-load-value {
    font-size: 2.5rem;
    font-weight: 800;
    color: #fff;
  }

  .training-load-badge {
    font-size: 0.85rem;
    font-weight: 700;
    padding: 0.3rem 0.8rem;
    border-radius: 20px;
  }

  .training-load-badge.easy {
    background: rgba(74, 222, 128, 0.2);
    color: #4ade80;
    border: 1px solid rgba(74, 222, 128, 0.3);
  }

  .training-load-badge.moderate {
    background: rgba(251, 191, 36, 0.2);
    color: #fbbf24;
    border: 1px solid rgba(251, 191, 36, 0.3);
  }

  .training-load-badge.hard {
    background: rgba(251, 146, 60, 0.2);
    color: #fb923c;
    border: 1px solid rgba(251, 146, 60, 0.3);
  }

  .training-load-badge.extreme {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
    border: 1px solid rgba(239, 68, 68, 0.3);
  }

  .training-load-badge.recovery {
    background: rgba(103, 232, 249, 0.2);
    color: #67e8f9;
    border: 1px solid rgba(103, 232, 249, 0.3);
  }

  /* ========================================
     MUSCLE HEATMAP
     ======================================== */
  .muscle-heatmap-grid {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .muscle-bar-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }

  .muscle-bar-label {
    font-size: 0.8rem;
    font-weight: 600;
    color: #ccc;
    min-width: 7rem;
    text-align: right;
    flex-shrink: 0;
  }

  .muscle-bar-track {
    flex: 1;
    height: 14px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 7px;
    overflow: hidden;
    position: relative;
  }

  .muscle-bar-fill {
    height: 100%;
    border-radius: 7px;
    background: linear-gradient(90deg, #a855f7, #7c3aed);
    transition: width 0.6s cubic-bezier(0.23, 1, 0.32, 1);
    box-shadow: 0 0 10px rgba(168, 85, 247, 0.3);
  }

  .muscle-bar-level {
    font-size: 0.7rem;
    color: #aaa;
    min-width: 1.5rem;
    flex-shrink: 0;
  }

  /* ========================================
     DISTANCE PR GRID (Fastest X records)
     ======================================== */
  .pr-distance-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .pr-distance-card {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.15rem;
    padding: 0.6rem 0.4rem;
    border-radius: 12px;
    background: rgba(251, 146, 60, 0.1);
    border: 1px solid rgba(251, 146, 60, 0.18);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: all 0.2s ease;
  }

  .pr-distance-card:hover {
    transform: translateY(-2px);
    border-color: rgba(251, 146, 60, 0.35);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
  }

  .pr-distance-value {
    font-size: 1.1rem;
    font-weight: 800;
    letter-spacing: -0.02em;
    background: linear-gradient(135deg, #fb923c, #fbbf24);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-distance-label {
    font-size: 0.6rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #999;
  }

  .pr-distance-improvement {
    font-size: 0.55rem;
    font-weight: 600;
    margin-top: 0.1rem;
  }

  .pr-distance-improvement.positive {
    color: #4ade80;
  }

  .pr-distance-improvement.negative {
    color: #ef4444;
  }

  /* ========================================
     GROUPED PR CARDS
     ======================================== */
  .pr-grouped-card {
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 14px;
    padding: 0.8rem 1rem;
    animation: fadeInUp 0.3s ease-out backwards;
  }

  .pr-grouped-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.6rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
  }

  .pr-grouped-name {
    font-size: 0.9rem;
    font-weight: 700;
    color: #fff;
  }

  .pr-grouped-records {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .pr-record-chip {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.15rem;
    padding: 0.35rem 0.7rem;
    border-radius: 10px;
    flex: 1;
    min-width: 5rem;
  }

  .pr-record-chip.chip-1rm {
    background: rgba(251, 191, 36, 0.12);
    border: 1px solid rgba(251, 191, 36, 0.2);
  }

  .pr-record-chip.chip-volume {
    background: rgba(96, 165, 250, 0.12);
    border: 1px solid rgba(96, 165, 250, 0.2);
  }

  .pr-record-chip.chip-reps {
    background: rgba(74, 222, 128, 0.12);
    border: 1px solid rgba(74, 222, 128, 0.2);
  }

  .pr-record-chip.chip-time {
    background: rgba(251, 146, 60, 0.12);
    border: 1px solid rgba(251, 146, 60, 0.2);
  }

  .pr-record-chip.chip-distance {
    background: rgba(168, 85, 247, 0.12);
    border: 1px solid rgba(168, 85, 247, 0.2);
  }

  .pr-record-value {
    font-size: 0.9rem;
    font-weight: 700;
    color: #fff;
  }

  .pr-record-type {
    font-size: 0.65rem;
    font-weight: 600;
    text-transform: uppercase;
    color: #999;
    letter-spacing: 0.04em;
  }

  .pr-record-improvement {
    font-size: 0.65rem;
    font-weight: 600;
  }

  .pr-record-improvement.positive {
    color: #4ade80;
  }

  .pr-record-improvement.negative {
    color: #ef4444;
  }

  /* ========================================
     ENHANCED WORKOUT SUMMARY
     ======================================== */
  .workout-headline-callout {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.1));
    border: 1px solid rgba(251, 191, 36, 0.2);
    border-radius: 10px;
    padding: 0.35rem 0.8rem;
    font-size: 0.8rem;
    font-weight: 700;
    color: #fbbf24;
    margin-bottom: 0.3rem;
  }

  .workout-exercise-card {
    display: flex;
    flex-direction: column;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid transparent;
    overflow: hidden;
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .workout-exercise-card:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .workout-exercise-card.cat-weighted {
    border-left-color: #a855f7;
  }

  .workout-exercise-card.cat-bodyweight {
    border-left-color: #4ade80;
  }

  .workout-exercise-card.cat-timed {
    border-left-color: #60a5fa;
  }

  .workout-exercise-card.cat-stretch {
    border-left-color: #818cf8;
  }

  .workout-ex-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
  }

  .workout-ex-icon {
    font-size: 0.85rem;
    flex-shrink: 0;
    width: 1.4rem;
    text-align: center;
  }

  .workout-ex-name {
    font-size: 0.82rem;
    font-weight: 600;
    color: #eee;
    flex: 1;
    min-width: 0;
  }

  .workout-ex-set-rows {
    display: flex;
    flex-direction: column;
  }

  .workout-ex-set-row {
    font-size: 0.75rem;
    color: #aaa;
    padding: 0.3rem 0.75rem 0.3rem 2rem;
    border-top: 1px solid rgba(255, 255, 255, 0.04);
    font-variant-numeric: tabular-nums;
    animation: fadeInUp 0.25s ease-out backwards;
  }

  .workout-ex-set-row:hover {
    background: rgba(255, 255, 255, 0.03);
  }

  .training-load-scale {
    width: 100%;
    height: 6px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 3px;
    margin-top: 0.6rem;
    position: relative;
    overflow: hidden;
  }

  .training-load-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.8s ease;
  }

  /* --- Running Dynamics three-column --- */
  .dynamics-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
  }

  @media (max-width: 500px) {
    .dynamics-grid {
      grid-template-columns: 1fr;
    }
  }

  .dynamics-stat {
    background: rgba(255, 255, 255, 0.04);
    border-radius: 8px;
    padding: 0.6rem 0.5rem;
    text-align: center;
  }

  .dynamics-icon {
    font-size: 1.1rem;
    margin-bottom: 0.2rem;
  }

  .dynamics-value {
    font-size: 1.2rem;
    font-weight: 700;
    color: #fff;
  }

  .dynamics-label {
    font-size: 0.6rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 0.1rem;
  }

  /* --- Splits (pace per km) --- */
  .splits-grid {
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }

  .split-row {
    display: grid;
    grid-template-columns: 52px 1fr 56px;
    align-items: center;
    gap: 0.5rem;
    animation: fadeInUp 0.35s ease-out backwards;
  }

  .split-label {
    font-size: 0.75rem;
    font-weight: 600;
    color: #ccc;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }

  .split-bar-track {
    height: 22px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 6px;
    overflow: hidden;
    position: relative;
  }

  .split-bar-fill {
    height: 100%;
    border-radius: 6px;
    background: linear-gradient(90deg, rgba(157, 78, 221, 0.7), rgba(76, 201, 240, 0.7));
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 8px;
  }

  .split-bar-fill.fastest {
    background: linear-gradient(90deg, rgba(74, 222, 128, 0.8), rgba(52, 211, 153, 0.9));
  }

  .split-bar-fill.slowest {
    background: linear-gradient(90deg, rgba(251, 146, 60, 0.7), rgba(239, 68, 68, 0.6));
  }

  .split-value {
    font-size: 0.8rem;
    font-weight: 700;
    color: #fff;
    text-align: left;
    font-variant-numeric: tabular-nums;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .split-badge {
    font-size: 0.7rem;
    line-height: 1;
  }

  .split-insight {
    margin-top: 0.6rem;
    padding: 0.5rem 0.75rem;
    background: rgba(255, 255, 255, 0.04);
    border-radius: 10px;
    border-left: 3px solid rgba(157, 78, 221, 0.6);
    font-size: 0.82rem;
    color: #ccc;
    animation: fadeInUp 0.4s ease-out backwards;
  }

  .split-insight .insight-emoji {
    margin-right: 0.3rem;
  }

  .split-insight .highlight {
    font-weight: 700;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  /* --- Elevation section (no graph) --- */
  .elevation-stats-grid {
    display: flex;
    justify-content: space-around;
    text-align: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .elevation-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .elevation-stat-arrow {
    font-size: 1rem;
  }

  .elevation-stat-value {
    font-size: 1.3rem;
    font-weight: 700;
    color: #fff;
  }

  .elevation-stat-label {
    font-size: 0.6rem;
    color: #888;
    text-transform: uppercase;
  }

  .elevation-sparkline {
    background: rgba(255, 255, 255, 0.04);
    border-radius: 6px;
    padding: 0.3rem 0.5rem;
    font-family: monospace;
    font-size: 0.9rem;
    text-align: center;
    color: #94a3b8;
  }

  /* --- Location & Weather combined --- */
  .conditions-row {
    display: flex;
    gap: 0.6rem;
    align-items: stretch;
    flex-wrap: wrap;
  }

  .conditions-item {
    flex: 1;
    min-width: 120px;
    background: rgba(255, 255, 255, 0.04);
    border-radius: 8px;
    padding: 0.5rem 0.7rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .conditions-icon {
    font-size: 1.2rem;
  }

  .conditions-text {
    display: flex;
    flex-direction: column;
    gap: 0.05rem;
  }

  .conditions-value {
    font-size: 0.85rem;
    font-weight: 600;
    color: #fff;
  }

  .conditions-label {
    font-size: 0.6rem;
    color: #888;
    text-transform: uppercase;
  }

  /* --- Enhanced compact stat pills --- */
  .enhanced-stat-pill {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 10px;
    padding: 0.5rem 0.7rem;
    min-width: 80px;
  }

  .enhanced-stat-pill .pill-value {
    font-size: 1.2rem;
    font-weight: 700;
    color: #fff;
  }

  .enhanced-stat-pill .pill-label {
    font-size: 0.6rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .enhanced-pills-row {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .insight-comparison-value.active .value {
    color: #4ade80;
  }

  .insight-comparison-value.recovery .value {
    color: #60a5fa;
  }

  .insight-vs-divider {
    font-size: 0.7rem;
    color: #666;
    font-weight: 600;
    text-transform: uppercase;
  }

  .insight-ratio-badge {
    background: linear-gradient(135deg, rgba(168, 85, 247, 0.25), rgba(139, 92, 246, 0.15));
    color: #c084fc;
    font-weight: 700;
    font-size: 0.8rem;
    padding: 0.25rem 0.6rem;
    border-radius: 8px;
    border: 1px solid rgba(168, 85, 247, 0.3);
  }

  /* Pace trend mini chart */
  .insight-trend {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .insight-trend-chart {
    display: flex;
    align-items: flex-end;
    gap: 4px;
    height: 36px;
  }

  .insight-trend-bar {
    width: 22px;
    border-radius: 4px 4px 0 0;
    transition: height 0.6s ease;
    position: relative;
  }

  .insight-trend-bar.faster {
    background: linear-gradient(to top, rgba(74, 222, 128, 0.4), rgba(74, 222, 128, 0.8));
  }

  .insight-trend-bar.slower {
    background: linear-gradient(to top, rgba(251, 146, 60, 0.4), rgba(251, 146, 60, 0.8));
  }

  .insight-trend-bar.neutral {
    background: linear-gradient(to top, rgba(148, 163, 184, 0.3), rgba(148, 163, 184, 0.6));
  }

  .insight-trend-bar .bar-label {
    position: absolute;
    bottom: -16px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.55rem;
    color: #888;
    white-space: nowrap;
  }

  .insight-trend-arrow {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.1rem;
  }

  .insight-trend-arrow .arrow {
    font-size: 1.3rem;
  }

  .insight-trend-arrow .arrow.faster {
    color: #4ade80;
  }

  .insight-trend-arrow .arrow.slower {
    color: #fb923c;
  }

  .insight-trend-pct {
    font-size: 0.95rem;
    font-weight: 700;
    padding: 0.15rem 0.5rem;
    border-radius: 6px;
  }

  .insight-trend-pct.faster {
    background: rgba(74, 222, 128, 0.15);
    color: #4ade80;
  }

  .insight-trend-pct.slower {
    background: rgba(251, 146, 60, 0.15);
    color: #fb923c;
  }

  .insight-trend-values {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.85rem;
    color: #ccc;
  }

  .insight-trend-values .from {
    color: #999;
  }

  .insight-trend-values .to {
    color: #fff;
    font-weight: 600;
  }

  .insight-trend-values .arrow-text {
    color: #666;
  }

  .intervals-subtitle {
    font-size: 0.85rem;
    color: #999;
    font-weight: 400;
    margin-left: 0.4rem;
  }

  /* --- Shared elements --- */
  .interval-emoji {
    font-size: 1.1rem;
    flex-shrink: 0;
  }

  .interval-label {
    flex: 1;
    font-size: 0.82rem;
    color: #ccc;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .interval-stats {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  .interval-stat {
    font-size: 0.75rem;
    font-weight: 600;
    padding: 0.15rem 0.5rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.06);
    color: #ddd;
    white-space: nowrap;
  }

  .interval-stat.pace {
    color: #FF6BB3;
  }

  .interval-stat.hr {
    color: #FF6B6B;
  }

  .interval-stat.dist {
    color: #4CC9F0;
  }

  .interval-stat.time {
    color: #FFD93D;
  }

  /* ========================================
     HR ZONE BARS
     ======================================== */
  .hr-zones-list {
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }

  .hr-zone-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    animation: fadeInUp 0.3s ease-out backwards;
  }

  .hr-zone-label {
    font-size: 0.72rem;
    font-weight: 600;
    color: #aaa;
    min-width: 110px;
    flex-shrink: 0;
    text-align: right;
  }

  .hr-zone-bar {
    flex: 1;
    height: 22px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    overflow: hidden;
    position: relative;
  }

  .hr-zone-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.8s ease-out;
    min-width: 2px;
  }

  .hr-zone-fill.zone-0 {
    background: linear-gradient(90deg, #6B7280, #9CA3AF);
  }

  .hr-zone-fill.zone-1 {
    background: linear-gradient(90deg, #60A5FA, #93C5FD);
  }

  .hr-zone-fill.zone-2 {
    background: linear-gradient(90deg, #4ADE80, #86EFAC);
  }

  .hr-zone-fill.zone-3 {
    background: linear-gradient(90deg, #FBBF24, #FCD34D);
  }

  .hr-zone-fill.zone-4 {
    background: linear-gradient(90deg, #FB923C, #FDBA74);
  }

  .hr-zone-fill.zone-5 {
    background: linear-gradient(90deg, #EF4444, #FCA5A5);
  }

  .hr-zone-duration {
    font-size: 0.72rem;
    font-weight: 700;
    color: #ddd;
    min-width: 45px;
    text-align: right;
    flex-shrink: 0;
  }

  /* ========================================
     GOAL / STREAK / MILESTONE PROGRESS
     ======================================== */
  .progress-section-body {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .progress-bar-container {
    width: 100%;
    height: 28px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 14px;
    overflow: visible;
    position: relative;
  }

  .progress-bar-fill {
    height: 100%;
    border-radius: 14px;
    background: linear-gradient(90deg, #FF1B8D, #9D4EDD);
    transition: width 1s ease-out;
    position: relative;
    min-width: 4px;
    overflow: hidden;
  }

  .progress-bar-fill.milestone {
    background: linear-gradient(90deg, #4CC9F0, #9D4EDD);
  }

  .progress-bar-fill.milestone.celebration {
    background: linear-gradient(90deg, #FFD700, #FFA500, #FF6B6B);
    animation: celebration-pulse 2s ease-in-out infinite;
  }

  @keyframes celebration-pulse {

    0%,
    100% {
      filter: brightness(1);
    }

    50% {
      filter: brightness(1.3);
    }
  }

  .milestone-celebration {
    border: 1px solid rgba(255, 215, 0, 0.3) !important;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.1);
  }

  .milestone-banner {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.8rem;
    padding: 1rem 0;
  }

  .milestone-confetti {
    font-size: 1.8rem;
    animation: confetti-bounce 1s ease-in-out infinite alternate;
  }

  .milestone-confetti:last-child {
    animation-delay: 0.3s;
  }

  @keyframes confetti-bounce {
    from {
      transform: translateY(0) rotate(-5deg);
    }

    to {
      transform: translateY(-6px) rotate(5deg);
    }
  }

  .milestone-value {
    font-size: 2rem;
    font-weight: 900;
    background: linear-gradient(135deg, #FFD700, #FFA500);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.02em;
  }

  .milestone-label {
    font-size: 0.8rem;
    font-weight: 700;
    color: #FFD700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .progress-bar-fill.streak {
    background: linear-gradient(90deg, #FB923C, #EF4444);
  }

  .progress-bar-label {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.72rem;
    font-weight: 800;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    white-space: nowrap;
  }

  .progress-bar-label.outside {
    right: auto;
    left: calc(100% + 8px);
    color: #ccc;
    text-shadow: none;
  }

  .progress-details {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }

  .progress-detail-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: #bbb;
  }

  .progress-detail-row .detail-emoji {
    flex-shrink: 0;
  }

  .streak-number {
    font-size: 2.5rem;
    font-weight: 900;
    letter-spacing: -0.03em;
    background: linear-gradient(135deg, #FB923C, #EF4444);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    line-height: 1;
  }

  .streak-label {
    font-size: 0.85rem;
    color: #aaa;
    font-weight: 600;
  }

  .streak-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.7rem;
    font-weight: 700;
    padding: 0.2rem 0.6rem;
    border-radius: 20px;
    background: rgba(251, 146, 60, 0.12);
    color: #FB923C;
    border: 1px solid rgba(251, 146, 60, 0.2);
    width: fit-content;
  }

  /* ========================================
     STAT ROWS (bullet-list sections)
     ======================================== */
  .stat-rows {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }

  .stat-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.45rem 0.6rem;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.03);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .stat-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .stat-row-emoji {
    font-size: 1rem;
    flex-shrink: 0;
  }

  .stat-row-label {
    flex: 1;
    font-size: 0.82rem;
    color: #aaa;
    min-width: 0;
  }

  .stat-row-value {
    font-size: 0.88rem;
    font-weight: 700;
    color: #fff;
    text-align: right;
    flex-shrink: 0;
  }

  /* ========================================
     COMPACT STAT PILLS (single-line ‚Ä¢-separated)
     ======================================== */
  .compact-stat-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    align-items: center;
  }

  .stat-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.35rem 0.7rem;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.08);
    font-size: 0.8rem;
    font-weight: 600;
    color: #ddd;
    transition: all 0.2s;
  }

  .stat-pill:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.15);
  }

  .stat-pill-label {
    color: #888;
    font-weight: 500;
  }

  .stat-pill-value {
    color: #fff;
    font-weight: 700;
  }

  @media (max-width: 480px) {
    .hr-zone-label {
      min-width: 80px;
      font-size: 0.65rem;
    }

    .interval-stats {
      gap: 0.25rem;
    }

    .interval-stat {
      font-size: 0.65rem;
      padding: 0.1rem 0.35rem;
    }

    .streak-number {
      font-size: 2rem;
    }
  }

  /* ========================================
     AI SUMMARY PROSE ‚Äî ‚ú® Magic Shimmer
     ======================================== */
  .ai-summary-card {
    position: relative;
    overflow: hidden;
    background: linear-gradient(135deg,
        rgba(255, 200, 50, 0.04) 0%,
        rgba(157, 78, 221, 0.06) 50%,
        rgba(76, 201, 240, 0.04) 100%) !important;
    border: 1px solid transparent;
    background-clip: padding-box !important;
  }

  /* Animated gradient border */
  .ai-summary-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    padding: 1px;
    background: linear-gradient(135deg,
        rgba(255, 200, 50, 0.5),
        rgba(157, 78, 221, 0.5),
        rgba(76, 201, 240, 0.5),
        rgba(255, 200, 50, 0.5));
    background-size: 300% 300%;
    animation: aiGradientShift 6s ease-in-out infinite;
    -webkit-mask:
      linear-gradient(#fff 0 0) content-box,
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
    z-index: 1;
  }

  /* Subtle glow */
  .ai-summary-card::after {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: inherit;
    box-shadow:
      0 0 20px rgba(255, 200, 50, 0.08),
      0 0 40px rgba(157, 78, 221, 0.06);
    animation: aiGlow 4s ease-in-out infinite alternate;
    pointer-events: none;
    z-index: 0;
  }

  .ai-summary-prose {
    position: relative;
    z-index: 2;
    font-size: 0.9rem;
    line-height: 1.75;
    color: #d4d0dc;
    padding: 0.8rem 1rem;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.02);
    font-style: italic;
    overflow: hidden;
  }

  /* Shimmer sweep across text */
  .ai-summary-prose::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 60%;
    height: 100%;
    background: linear-gradient(90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.04) 40%,
        rgba(255, 200, 50, 0.06) 50%,
        rgba(255, 255, 255, 0.04) 60%,
        transparent 100%);
    animation: aiShimmerSweep 5s ease-in-out infinite;
    pointer-events: none;
  }

  .ai-summary-header h2 {
    background: linear-gradient(135deg, #FFC832, #C77DFF, #4CC9F0);
    background-size: 200% 200%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: aiGradientShift 6s ease-in-out infinite;
  }

  @keyframes aiGradientShift {

    0%,
    100% {
      background-position: 0% 50%;
    }

    50% {
      background-position: 100% 50%;
    }
  }

  @keyframes aiShimmerSweep {

    0%,
    20% {
      left: -100%;
    }

    60%,
    100% {
      left: 150%;
    }
  }

  @keyframes aiGlow {
    0% {
      box-shadow:
        0 0 15px rgba(255, 200, 50, 0.06),
        0 0 30px rgba(157, 78, 221, 0.04);
    }

    100% {
      box-shadow:
        0 0 25px rgba(255, 200, 50, 0.1),
        0 0 50px rgba(157, 78, 221, 0.08);
    }
  }

  /* ========================================
     PARKRUN RESULTS
     ======================================== */
  .parkrun-results {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .parkrun-stat-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 0.55rem 0.7rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .parkrun-stat-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .parkrun-stat-label {
    font-size: 0.82rem;
    color: #aaa;
    min-width: 90px;
    font-weight: 600;
  }

  .parkrun-stat-value {
    font-size: 0.95rem;
    font-weight: 700;
    color: #fff;
  }

  .parkrun-badges {
    display: flex;
    gap: 0.35rem;
    flex-wrap: wrap;
    margin-left: auto;
  }

  .parkrun-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.5rem;
    border-radius: 20px;
    white-space: nowrap;
  }

  .parkrun-badge.all-time {
    background: rgba(255, 215, 0, 0.12);
    color: #FFD700;
    border: 1px solid rgba(255, 215, 0, 0.2);
  }

  .parkrun-badge.this-year {
    background: rgba(192, 192, 192, 0.12);
    color: #C0C0C0;
    border: 1px solid rgba(192, 192, 192, 0.2);
  }

  .parkrun-badge.first-visit {
    background: rgba(255, 255, 100, 0.12);
    color: #FFFF64;
    border: 1px solid rgba(255, 255, 100, 0.2);
  }

  /* ========================================
     EFFORT SCORE GAUGE
     ======================================== */
  .effort-score-body {
    display: flex;
    flex-direction: column;
    gap: 0.7rem;
  }

  .effort-gauge {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .effort-gauge-ring {
    position: relative;
    width: 80px;
    height: 80px;
    flex-shrink: 0;
  }

  .effort-gauge-ring svg {
    transform: rotate(-90deg);
    width: 80px;
    height: 80px;
  }

  .effort-gauge-ring .gauge-bg {
    fill: none;
    stroke: rgba(255, 255, 255, 0.08);
    stroke-width: 6;
  }

  .effort-gauge-ring .gauge-fill {
    fill: none;
    stroke-width: 6;
    stroke-linecap: round;
    transition: stroke-dashoffset 1s ease-out;
  }

  .effort-gauge-value {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.3rem;
    font-weight: 900;
    color: #fff;
  }

  .effort-gauge-info {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
  }

  .effort-label {
    font-size: 1.1rem;
    font-weight: 700;
  }

  .effort-label.easy {
    color: #4ADE80;
  }

  .effort-label.moderate {
    color: #FBBF24;
  }

  .effort-label.hard {
    color: #FB923C;
  }

  .effort-label.very-hard {
    color: #EF4444;
  }

  .effort-label.max {
    color: #DC2626;
  }

  .effort-factors {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }

  .effort-factor {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.35rem 0.6rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    font-size: 0.8rem;
    color: #bbb;
    animation: fadeInUp 0.3s ease-out backwards;
  }

  .effort-factor-emoji {
    flex-shrink: 0;
  }

  .effort-factor-name {
    flex: 1;
    color: #aaa;
  }

  .effort-factor-value {
    font-weight: 700;
    color: #fff;
  }

  .effort-verdict {
    font-size: 0.8rem;
    color: #888;
    font-style: italic;
    padding-left: 0.3rem;
  }

  /* ========================================
     WORKOUT SUMMARY
     ======================================== */
  .workout-summary-body {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .workout-headline-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
  }

  .workout-exercises {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }

  .workout-exercise-row {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.03);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .workout-exercise-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .workout-superset-marker {
    font-size: 0.85rem;
    flex-shrink: 0;
    min-width: 1.4rem;
    text-align: center;
  }

  .workout-exercise-name {
    font-size: 0.82rem;
    font-weight: 600;
    color: #ddd;
    flex-shrink: 0;
    min-width: 0;
  }

  .workout-exercise-sets {
    font-size: 0.8rem;
    color: #aaa;
    flex: 1;
    text-align: right;
    word-break: break-word;
  }

  @media (max-width: 480px) {
    .effort-gauge-ring {
      width: 64px;
      height: 64px;
    }

    .effort-gauge-ring svg {
      width: 64px;
      height: 64px;
    }

    .effort-gauge-value {
      font-size: 1rem;
    }

    .parkrun-stat-label {
      min-width: 70px;
      font-size: 0.75rem;
    }
  }

  /* ========================================
     EXERCISES
     ======================================== */
  .exercise-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .exercise-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 1rem 1.25rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 16px;
    border-left: 4px solid #4CC9F0;
    transition: all 0.2s ease;
  }

  .exercise-item:hover {
    background: rgba(0, 0, 0, 0.3);
    border-left-color: #FF1B8D;
  }

  .exercise-name {
    font-weight: 700;
    color: #fff;
    font-size: 1rem;
  }

  .exercise-detail {
    display: flex;
    gap: 1rem;
    font-size: 0.875rem;
    color: #aaa;
    flex-wrap: wrap;
  }

  .exercise-detail span {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .exercise-badge {
    background: linear-gradient(135deg, rgba(76, 201, 240, 0.2), rgba(157, 78, 221, 0.2));
    border: 1px solid rgba(76, 201, 240, 0.3);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
  }

  /* ========================================
     TAGS
     ======================================== */
  .activity-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
  }

  .activity-tag {
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-size: 0.875rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* ========================================
     ENRICHMENTS (BOOSTERS)
     ======================================== */
  .enrichment-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1rem;
  }

  .enrichment-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(255, 27, 141, 0.1));
    border: 1px solid rgba(157, 78, 221, 0.3);
    border-radius: 16px;
    transition: all 0.2s ease;
  }

  .enrichment-item:hover {
    border-color: rgba(255, 27, 141, 0.5);
    transform: translateY(-2px);
  }

  .enrichment-icon {
    font-size: 2rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.2));
  }

  .enrichment-info {
    flex: 1;
  }

  .enrichment-name {
    font-weight: 700;
    color: #fff;
    margin-bottom: 0.125rem;
  }

  .enrichment-desc {
    font-size: 0.875rem;
    color: #aaa;
  }

  /* ========================================
     CTA SECTION
     ======================================== */
  .showcase-cta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1.5rem;
    margin-top: 3rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.25), rgba(255, 27, 141, 0.25));
    border: 1px solid rgba(157, 78, 221, 0.4);
    padding: 2rem;
  }

  .cta-content h3 {
    margin-bottom: 0.5rem;
    font-size: 1.25rem;
    color: #fff;
  }

  .cta-content p {
    color: #aaa;
    font-size: 0.9rem;
    margin: 0;
  }

  .btn {
    display: inline-block;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 50px;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    text-decoration: none;
    transition: all 0.2s ease;
  }

  .btn-primary {
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    color: white;
  }

  .btn-lg {
    padding: 1rem 2rem;
    font-size: 1.1rem;
  }

  .btn-glow {
    animation: glow 2s ease-in-out infinite;
  }

  .btn-primary:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.5);
  }

  @media (max-width: 640px) {
    .showcase-cta {
      flex-direction: column;
      text-align: center;
    }
  }

  /* ========================================
     ATTRIBUTION
     ======================================== */
  .showcase-attribution {
    text-align: center;
    padding: 3rem 0 2rem;
    color: #aaa;
    font-size: 0.9rem;
  }

  .fitglue-logo {
    text-decoration: none;
    font-weight: 900;
    font-size: 1.25rem;
    margin-left: 0.25rem;
  }

  .fit {
    color: #FF1B8D;
  }

  .glue {
    color: #9D4EDD;
  }

  /* ========================================
     MUSCLE ACTIVATION IMAGE
     ======================================== */
  .muscle-activation-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
  }

  /* ========================================
     HYBRID RACE BAR CHART
     ======================================== */
  .hybrid-race-bars {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .hybrid-race-bar-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .hybrid-race-bar-icon {
    font-size: 1.25rem;
    width: 2rem;
    text-align: center;
    flex-shrink: 0;
  }

  .hybrid-race-bar-container {
    flex: 1;
    height: 32px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
  }

  .hybrid-race-bar {
    height: 100%;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 0.75rem;
    min-width: 60px;
    transition: width 0.6s ease-out;
  }

  /* Run segments - cyan/teal */
  .hybrid-race-bar.bar-run {
    background: linear-gradient(90deg, #4CC9F0 0%, #38B6DC 100%);
  }

  /* Station segments - pink/purple gradient */
  .hybrid-race-bar.bar-station {
    background: linear-gradient(90deg, #FF1B8D 0%, #9D4EDD 100%);
  }

  .hybrid-race-bar-time {
    font-size: 0.875rem;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    white-space: nowrap;
  }

  .hybrid-race-bar-label {
    width: 140px;
    font-size: 0.875rem;
    color: #ddd;
    flex-shrink: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  @media (max-width: 640px) {
    .hybrid-race-bar-label {
      width: 100px;
      font-size: 0.75rem;
    }

    .hybrid-race-bar-time {
      font-size: 0.75rem;
    }
  }

  .hybrid-race-total {
    margin-top: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(255, 27, 141, 0.15), rgba(157, 78, 221, 0.15));
    border: 1px solid rgba(255, 27, 141, 0.3);
    border-radius: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .hybrid-race-total-label {
    font-size: 1rem;
    font-weight: 700;
    color: #fff;
  }

  .hybrid-race-total-value {
    font-size: 1.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
</style>

<script>
  // Sims-style rotating jokey fitness messages
  const LOADING_MESSAGES = [
    'Reticulating muscle fibers...',
    'Calibrating sweat glands...',
    'Polishing your running shoes...',
    'Stretching the pixels...',
    'Syncing your chakras...',
    'Buffering endorphins...',
    'Warming up the algorithms...',
    'Hydrating the database...',
    'Massaging the data points...',
    'Doing some light cardio...',
    'Flexing the API...',
    'Counting backwards from 10...',
    'Foam rolling the server...',
    'Adjusting seat to upright position...',
    'Untangling your headphones...',
    'Finding your gym buddy...',
    'Motivating the backend...',
    'Applying anti-chafe cream...',
    'Loading protein shakes...',
    'Activating beast mode...',
  ];


  // Start rotating messages
  let messageIndex = Math.floor(Math.random() * LOADING_MESSAGES.length);
  const loadingMessageEl = document.getElementById('loading-message');

  function rotateMessage() {
    if (loadingMessageEl) {
      loadingMessageEl.classList.add('fade-out');
      setTimeout(() => {
        messageIndex = (messageIndex + 1) % LOADING_MESSAGES.length;
        loadingMessageEl.textContent = LOADING_MESSAGES[messageIndex];
        loadingMessageEl.classList.remove('fade-out');
      }, 300);
    }
  }

  // Set initial message and start rotation
  if (loadingMessageEl) {
    loadingMessageEl.textContent = LOADING_MESSAGES[messageIndex];
  }
  const messageInterval = setInterval(rotateMessage, 2000);

  // Store chart configurations for re-rendering in modal
  const chartConfigs = {};
  let modalChart = null;

  function storeChartConfig(key, config) {
    chartConfigs[key] = config;
  }

  (async function () {
    // Extract ID from URL path: /showcase/{id}
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    let showcaseId = pathParts[0] === 'showcase' && pathParts[1] ? pathParts[1] : new URLSearchParams(window.location.search).get('id');

    const loadingEl = document.getElementById('showcase-loading');
    const errorEl = document.getElementById('showcase-error');
    const contentEl = document.getElementById('showcase-content');
    const errorMsgEl = document.getElementById('error-message');

    if (!showcaseId) {
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMsgEl.textContent = 'No showcase ID provided.';
      return;
    }

    try {
      // Demo mode: fetch local fixture data from /demo-showcase.json
      // To use real data, copy/paste the JSON response from /api/showcase/{id} into that file.
      if (showcaseId.startsWith('demo') && window.location.hostname === 'localhost') {
        const demoResponse = await fetch('/' + showcaseId + '.json');
        if (!demoResponse.ok) {
          throw new Error('Failed to load demo fixture data');
        }
        const data = await demoResponse.json();
        applyTheme(data.theme);
        renderShowcase(data);
        clearInterval(messageInterval);
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
        return;
      }

      const response = await fetch(`/api/showcase/${showcaseId}`);

      if (!response.ok) {
        clearInterval(messageInterval);
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
        errorMsgEl.textContent = response.status === 404 ? "This showcase doesn't exist." :
          response.status === 410 ? 'This showcase has expired.' : 'Failed to load showcase.';
        return;
      }

      const data = await response.json();
      applyTheme(data.theme);
      renderShowcase(data);
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      contentEl.style.display = 'block';

    } catch (error) {
      console.error('Error loading showcase:', error);
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMsgEl.textContent = 'An error occurred while loading.';
    }

    function applyTheme(theme) {
      if (!theme) theme = {};
      var page = document.querySelector('.showcase-page');
      if (!page) return;

      // Localhost-only: query string overrides for testing
      if (window.location.hostname === 'localhost') {
        var params = new URLSearchParams(window.location.search);
        if (params.get('theme')) theme.themeId = params.get('theme');
        if (params.get('accent')) theme.customAccentColor = params.get('accent');
        if (params.get('animation')) theme.animationId = params.get('animation');
        if (params.get('cardStyle')) theme.cardStyle = params.get('cardStyle');
      }

      if (theme.themeId && theme.themeId !== 'default') {
        page.setAttribute('data-theme', theme.themeId);
      }
      if (theme.cardStyle && theme.cardStyle !== 'glass') {
        page.setAttribute('data-card-style', theme.cardStyle);
      }
      if (theme.customAccentColor) {
        page.style.setProperty('--sc-accent', theme.customAccentColor);
      }
      if (theme.animationId) {
        window._showcaseAnimation = theme.animationId;
        if (typeof window.setShowcaseAnimation === 'function') {
          window.setShowcaseAnimation(theme.animationId);
        }
      }

      // Inject dynamic CSS overrides that replace all hard-coded brand colours
      // with CSS variable references. This avoids editing 50+ inline style rules.
      var existing = document.getElementById('theme-overrides');
      if (existing) existing.remove();

      var style = document.createElement('style');
      style.id = 'theme-overrides';
      style.textContent = [
        // Title shimmer gradient
        '.showcase-title { background: linear-gradient(90deg, var(--sc-accent) 0%, var(--sc-accent-alt) 25%, #fff 50%, var(--sc-accent-alt) 75%, var(--sc-accent) 100%) !important; background-size: 200% auto !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        '.showcase-title { text-shadow: 0 0 60px color-mix(in srgb, var(--sc-accent) 30%, transparent) !important; }',
        // Error heading
        '.showcase-error h1 { background: linear-gradient(135deg, var(--sc-accent), var(--sc-accent-alt)) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        // Owner attribution
        '.owner-name { background: linear-gradient(135deg, var(--sc-accent), var(--sc-accent-alt)) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        '.owner-avatar { border-color: color-mix(in srgb, var(--sc-accent) 40%, transparent) !important; }',
        // Stat values
        '.stat-value { background: linear-gradient(135deg, var(--sc-accent), var(--sc-accent-alt)) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        '.stat-card:hover { border-color: color-mix(in srgb, var(--sc-accent) 40%, transparent) !important; box-shadow: 0 10px 40px color-mix(in srgb, var(--sc-accent) 20%, transparent) !important; }',
        // Description quote marks
        '.description-section-card::before { color: var(--sc-accent-alt) !important; }',
        // Map & route thumbnail
        '.expand-map-btn { background: linear-gradient(135deg, color-mix(in srgb, var(--sc-accent-alt) 20%, transparent), color-mix(in srgb, var(--sc-accent) 20%, transparent)) !important; border-color: color-mix(in srgb, var(--sc-accent-alt) 40%, transparent) !important; }',
        '.expand-map-btn:hover { border-color: color-mix(in srgb, var(--sc-accent) 60%, transparent) !important; background: linear-gradient(135deg, color-mix(in srgb, var(--sc-accent-alt) 30%, transparent), color-mix(in srgb, var(--sc-accent) 30%, transparent)) !important; }',
        '.route-thumbnail-image { box-shadow: 0 4px 20px color-mix(in srgb, var(--sc-accent) 20%, transparent) !important; }',
        '.route-thumbnail-image:hover { box-shadow: 0 8px 30px color-mix(in srgb, var(--sc-accent) 40%, transparent) !important; }',
        // Tag badges
        '.activity-tag { border-color: color-mix(in srgb, var(--sc-accent-alt) 40%, transparent) !important; background: color-mix(in srgb, var(--sc-accent-alt) 15%, transparent) !important; }',
        // Booster applied badges
        '.enrichment-badge { border-color: color-mix(in srgb, var(--sc-accent-alt) 20%, transparent) !important; background: color-mix(in srgb, var(--sc-accent-alt) 4%, transparent) !important; }',
        '.enrichment-badge:hover { background: color-mix(in srgb, var(--sc-accent-alt) 8%, transparent) !important; border-color: color-mix(in srgb, var(--sc-accent) 30%, transparent) !important; }',
        // Booster content blocks
        '.enrichment-output-block { border-left-color: var(--sc-accent-alt) !important; }',
        // Loading spinner
        '.loading-logo-fit { background: linear-gradient(135deg, var(--sc-accent) 0%, color-mix(in srgb, var(--sc-accent) 70%, white) 100%) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        '.loading-logo-glue { background: linear-gradient(135deg, var(--sc-accent-alt) 0%, color-mix(in srgb, var(--sc-accent-alt) 70%, white) 100%) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        // FitGlue footer logo
        '.fitglue-logo .fit { background: linear-gradient(135deg, var(--sc-accent) 0%, color-mix(in srgb, var(--sc-accent) 70%, white) 100%) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        '.fitglue-logo .glue { background: linear-gradient(135deg, var(--sc-accent-alt) 0%, color-mix(in srgb, var(--sc-accent-alt) 70%, white) 100%) !important; -webkit-background-clip: text !important; background-clip: text !important; }',
        // CTA banner
        '.showcase-cta::before { background: linear-gradient(135deg, color-mix(in srgb, var(--sc-accent) 30%, transparent), color-mix(in srgb, var(--sc-accent-alt) 30%, transparent)) !important; }',
        '.btn-gradient { background: linear-gradient(135deg, var(--sc-accent) 0%, var(--sc-accent-alt) 100%) !important; }',
        '.btn-gradient:hover { box-shadow: 0 8px 20px color-mix(in srgb, var(--sc-accent-alt) 40%, transparent) !important; }',
        // Chart/metric bars
        '.metric-bar-fill { background: linear-gradient(90deg, var(--sc-accent), var(--sc-accent-alt)) !important; }',
        '.metric-bar-segment { background: linear-gradient(90deg, var(--sc-accent), var(--sc-accent-alt)) !important; }',
        // Personal record cards
        '.pr-card { --pr-accent: color-mix(in srgb, var(--sc-accent) 15%, transparent) !important; }',
        '.pr-card:nth-child(even) { --pr-accent: color-mix(in srgb, var(--sc-accent-alt) 15%, transparent) !important; }',
        // Photo gallery glow
        '.photo-thumbnail img { filter: none !important; }',
        '.photo-thumbnail:hover img { box-shadow: 0 0 20px color-mix(in srgb, var(--sc-accent) 30%, transparent) !important; }',
      ].join('\n');
      document.head.appendChild(style);
    }

    function renderShowcase(data) {
      // Title & Meta
      document.getElementById('activity-title').textContent = data.title || 'Activity';
      document.title = (data.title || 'Activity') + ' | FitGlue';
      document.getElementById('activity-type').textContent = formatActivityType(data.activityType);
      document.getElementById('activity-source').textContent = 'from ' + formatSource(data.source);

      // Owner attribution
      if (data.ownerDisplayName) {
        const attrEl = document.getElementById('owner-attribution');
        const slug = data.ownerProfileSlug || data.ownerDisplayName.toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
        let avatarHtml = '';
        if (data.ownerProfilePictureUrl) {
          avatarHtml = `<span class="owner-avatar"><img src="${data.ownerProfilePictureUrl}" alt="${data.ownerDisplayName}" /></span>`;
        }
        attrEl.innerHTML = `${avatarHtml}by <a href="/u/${slug}" class="owner-name owner-link">${data.ownerDisplayName}</a>`;
        attrEl.style.display = 'flex';
      }

      if (data.startTime) {
        document.getElementById('activity-date').textContent = new Date(data.startTime).toLocaleDateString(undefined, {
          weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });
      }

      // Hide FitGlue branding for Athlete users
      if (data.isAthlete) {
        const cta = document.getElementById('showcase-cta');
        const attribution = document.getElementById('showcase-attribution');
        if (cta) cta.style.display = 'none';
        if (attribution) attribution.style.display = 'none';
      }

      // AI Banner background image
      const bannerUrl = data.enrichmentMetadata?.asset_ai_banner;
      if (bannerUrl) {
        const heroEl = document.querySelector('.showcase-hero');
        heroEl.style.backgroundImage = `url(${bannerUrl})`;
        heroEl.classList.add('has-banner');
      }

      // Stats
      const activity = data.activityData;
      if (activity && activity.sessions && activity.sessions.length > 0) {
        const session = activity.sessions[0];
        const statsGrid = document.getElementById('stats-section');
        const stats = [];

        if (session.totalElapsedTime) stats.push({ icon: '‚è±Ô∏è', value: formatDuration(session.totalElapsedTime), label: 'Duration' });
        if (session.totalDistance) stats.push({ icon: 'üìè', value: formatDistance(session.totalDistance), label: 'Distance' });

        // Cardio stats
        const allRecords = session.laps ? session.laps.flatMap(l => l.records || []) : [];
        const hrValues = allRecords.filter(r => r.heartRate > 0).map(r => r.heartRate);
        if (hrValues.length > 0) {
          const avgHr = Math.round(hrValues.reduce((a, b) => a + b, 0) / hrValues.length);
          stats.push({ icon: '‚ù§Ô∏è', value: avgHr, label: 'Avg BPM' });
        }

        // Power stats
        const powerValues = allRecords.filter(r => r.power > 0).map(r => r.power);
        if (powerValues.length > 0) {
          const avgPower = Math.round(powerValues.reduce((a, b) => a + b, 0) / powerValues.length);
          stats.push({ icon: '‚ö°', value: avgPower + 'W', label: 'Avg Power' });
        }

        // Cadence stats
        const cadenceValues = allRecords.filter(r => r.cadence > 0).map(r => r.cadence);
        if (cadenceValues.length > 0) {
          const avgCadence = Math.round(cadenceValues.reduce((a, b) => a + b, 0) / cadenceValues.length);
          stats.push({ icon: 'ü¶∂', value: avgCadence, label: 'Avg Cadence' });
        }

        // Speed/Pace stats
        const speedValues = allRecords.filter(r => r.speed > 0).map(r => r.speed);
        if (speedValues.length > 0) {
          const avgSpeed = speedValues.reduce((a, b) => a + b, 0) / speedValues.length;
          const avgSpeedKmh = (avgSpeed * 3.6).toFixed(1);
          stats.push({ icon: 'üöÄ', value: avgSpeedKmh + ' km/h', label: 'Avg Speed' });
        }

        // Strength stats
        if (session.strengthSets && session.strengthSets.length > 0) {
          const totalSets = session.strengthSets.length;
          const totalReps = session.strengthSets.reduce((sum, s) => sum + (s.reps || 0), 0);
          const totalWeightCalculated = session.strengthSets.reduce((sum, s) => {
            const reps = s.reps || 0;
            const weight = s.weightKg || 0;
            const distance = s.distanceMeters || 0;
            if (weight > 0) {
              if (reps > 0) return sum + (reps * weight);
              if (distance > 0) return sum + (distance * weight);
            }
            return sum;
          }, 0);
          stats.push({ icon: 'üî¢', value: totalSets, label: 'Sets' });
          stats.push({ icon: 'üí™', value: totalReps, label: 'Reps' });
          if (totalWeightCalculated > 0) stats.push({ icon: '‚öñÔ∏è', value: formatWeight(totalWeightCalculated), label: 'Volume' });
        }

        if (stats.length > 0) {
          statsGrid.innerHTML = stats.map(s => `
          <div class="stat-card">
            <div class="stat-icon">${s.icon}</div>
            <div class="stat-value">${s.value}</div>
            <div class="stat-label">${s.label}</div>
          </div>
        `).join('');
          statsGrid.style.display = 'grid';
        }

        // --- MAP / ROUTE THUMBNAIL ---
        const routeThumbnailUrl = data.enrichmentMetadata?.asset_route_thumbnail;
        const gpsRecords = allRecords.filter(r => r.positionLat && r.positionLong);

        if (routeThumbnailUrl || gpsRecords.length > 10) {
          const mapSection = document.getElementById('map-section');
          mapSection.style.display = 'block';

          if (routeThumbnailUrl) {
            // Display route thumbnail (SVG inline or img)
            const thumbnailContainer = document.createElement('div');
            thumbnailContainer.className = 'route-thumbnail-container';
            renderAsset(routeThumbnailUrl, 'Route Map', 'route-thumbnail-image', thumbnailContainer);
            const mapContainer = document.getElementById('activity-map');
            mapContainer.parentNode.insertBefore(thumbnailContainer, mapContainer);

            // If GPS data exists, show expandable interactive map option
            if (gpsRecords.length > 10) {
              mapContainer.style.display = 'none';
              thumbnailContainer.innerHTML += `
                <button class="expand-map-btn" onclick="document.getElementById('activity-map').style.display='block'; this.style.display='none'; initMap(gpsRecords);">
                  üó∫Ô∏è Show Interactive Map
                </button>
              `;
              // Make gpsRecords accessible to onclick handler
              window.gpsRecords = gpsRecords;
            } else {
              mapContainer.style.display = 'none';
            }
          } else {
            // No thumbnail, show interactive map
            setTimeout(() => initMap(gpsRecords), 100);
          }
        }

        // Note: timeMarkers is on the activity level, not session level
        const timeMarkers = activity.timeMarkers || [];

        // --- HEART RATE GRAPH ---
        if (hrValues.length > 10) {
          const hrSection = document.getElementById('hr-graph-section');
          const avg = Math.round(hrValues.reduce((a, b) => a + b, 0) / hrValues.length);
          const max = Math.max(...hrValues);
          const min = Math.min(...hrValues);

          document.getElementById('hr-summary').innerHTML = `
            <div class="hr-stat-mini"><span class="hr-value-mini">${avg}</span><span class="hr-label-mini">Avg</span></div>
            <div class="hr-stat-mini"><span class="hr-value-mini">${max}</span><span class="hr-label-mini">Max</span></div>
            <div class="hr-stat-mini"><span class="hr-value-mini">${min}</span><span class="hr-label-mini">Min</span></div>
          `;

          hrSection.style.display = 'block';
          setTimeout(() => initHrChart(allRecords, timeMarkers), 100);
        }

        // --- ELEVATION GRAPH ---
        if (allRecords.some(r => r.altitude !== undefined)) {
          document.getElementById('elevation-section').style.display = 'block';
          setTimeout(() => initElevationChart(allRecords, timeMarkers), 100);
        }

        // --- PACE GRAPH (from speed data) ---
        if (allRecords.filter(r => r.speed > 0).length > 10) {
          document.getElementById('pace-section').style.display = 'block';
          setTimeout(() => initPaceChart(allRecords, timeMarkers), 100);
        }

        // --- POWER GRAPH ---
        if (allRecords.filter(r => r.power > 0).length > 10) {
          document.getElementById('power-section').style.display = 'block';
          setTimeout(() => initPowerChart(allRecords, timeMarkers), 100);
        }

        // --- CADENCE GRAPH ---
        if (allRecords.filter(r => r.cadence > 0).length > 10) {
          document.getElementById('cadence-section').style.display = 'block';
          setTimeout(() => initCadenceChart(allRecords, timeMarkers), 100);
        }

        // --- SPEED GRAPH ---
        if (allRecords.filter(r => r.speed > 0).length > 10) {
          document.getElementById('speed-section').style.display = 'block';
          setTimeout(() => initSpeedChart(allRecords, timeMarkers), 100);
        }

        // --- EXERCISES ---
        // Suppress when Workout Summary or Hybrid Race Breakdown already covers exercises
        const hasWorkoutSummary = (data.description || '').includes('üìã Workout Summary:');
        const _actName = (data.activityData?.name || '').toLowerCase();
        const _actTags = (data.activityData?.tags || []).map(t => t.toLowerCase());
        const isHybridRaceExercise = _actName.includes('hyrox') || _actName.includes('athx') ||
          _actTags.some(t => t.includes('hyrox')) || _actTags.some(t => t.includes('athx'));
        if (session.strengthSets && session.strengthSets.length > 0 && !hasWorkoutSummary && !isHybridRaceExercise) {
          const exercisesSection = document.getElementById('exercises-section');
          const exerciseList = document.getElementById('exercise-list');

          // Group by exercise name (preserving order)
          const blocks = [];
          const blockMap = {};
          session.strengthSets.forEach(set => {
            const name = set.exerciseName || 'Unknown';
            if (!blockMap[name]) {
              const block = { name, sets: [] };
              blocks.push(block);
              blockMap[name] = block;
            }
            blockMap[name].sets.push(set);
          });

          // Superset detection
          const hasSupersets = blocks.some(b => b.sets[0].supersetId);
          const supersetEmojiMap = {};
          const emojiNumbers = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"];
          let supersetCounter = 0;

          if (hasSupersets) {
            blocks.forEach(b => {
              const sid = b.sets[0].supersetId;
              if (sid && !supersetEmojiMap[sid]) {
                if (supersetCounter < emojiNumbers.length) {
                  supersetEmojiMap[sid] = emojiNumbers[supersetCounter++];
                }
              }
            });
          }

          document.getElementById('exercise-count').textContent = `${blocks.length} exercises`;

          exerciseList.innerHTML = blocks.map(b => {
            let marker = "";
            if (hasSupersets) {
              const sid = b.sets[0].supersetId;
              marker = sid ? (supersetEmojiMap[sid] + " ") : "‚¨ú ";
            }

            const formattedSets = formatCollapsedSets(b.sets);

            return `
            <div class="exercise-item">
              <span class="exercise-name">${marker}${b.name}</span>
              <div class="exercise-detail">
                <span>üìä ${b.sets.length} sets</span>
                ${formattedSets}
              </div>
            </div>
          `;
          }).join('');
          exercisesSection.style.display = 'block';
        }

        // --- MUSCLE ACTIVATION HEATMAP ---
        const heatmapUrl = data.enrichmentMetadata?.asset_muscle_heatmap;
        if (heatmapUrl) {
          const heatmapSection = document.getElementById('muscle-activation-section');
          const heatmapContainer = document.getElementById('muscle-heatmap-container');
          renderAsset(heatmapUrl, 'Muscle Activation Heatmap', 'muscle-heatmap-image', heatmapContainer);
          heatmapSection.style.display = 'block';
        }

        // --- HYBRID RACE BAR CHART ---
        const activityName = data.activityData?.name || '';
        const activityTags = data.activityData?.tags || [];

        // Detect hybrid race type from name or tags
        const isHybridRace =
          activityName.toLowerCase().includes('hyrox') ||
          activityName.toLowerCase().includes('athx') ||
          activityTags.some(t => t.toLowerCase().includes('hyrox')) ||
          activityTags.some(t => t.toLowerCase().includes('athx'));

        if (isHybridRace && timeMarkers.length > 0) {
          const hybridSection = document.getElementById('hybrid-race-section');
          const hybridBarsContainer = document.getElementById('hybrid-race-bars');
          const hybridTotal = document.getElementById('hybrid-race-total');
          const hybridName = document.getElementById('hybrid-race-name');

          // Determine race type for subtitle
          const raceType = activityName.toLowerCase().includes('hyrox') ? 'HYROX' : 'ATHX';
          hybridName.textContent = raceType + ' Race';

          // Calculate total duration for bar widths
          let totalDuration = 0;
          const segments = [];

          // Get session total elapsed time to calculate the last segment's duration
          const sessionTotalTime = session.totalElapsedTime || 0;

          for (let i = 0; i < timeMarkers.length; i++) {
            const marker = timeMarkers[i];
            const nextMarker = timeMarkers[i + 1];
            const isLastMarker = i === timeMarkers.length - 1;

            // Calculate duration to next marker or use marker's own duration if available
            let duration = 0;
            if (nextMarker && marker.timestamp && nextMarker.timestamp) {
              const startMs = new Date(marker.timestamp).getTime();
              const endMs = new Date(nextMarker.timestamp).getTime();
              duration = (endMs - startMs) / 1000; // seconds
            } else if (isLastMarker && sessionTotalTime > 0 && totalDuration > 0) {
              // For the last marker, calculate remaining time from session total
              duration = sessionTotalTime - totalDuration;
            } else if (marker.durationSeconds) {
              duration = marker.durationSeconds;
            }

            if (duration > 0) {
              totalDuration += duration;
              segments.push({
                label: marker.label || `Station ${i + 1}`,
                icon: marker.icon || getStationIcon(marker.label || ''),
                duration: duration,
                isRun: (marker.markerType === 'run_start' || marker.label?.toLowerCase().includes('run'))
              });
            }
          }

          // Fallback: If no time markers, try to infer from laps
          if (segments.length === 0 && session.laps && session.laps.length > 0) {
            session.laps.forEach((lap, i) => {
              if (lap.totalElapsedTime > 0) {
                const isRun = lap.exerciseName?.toLowerCase().includes('run') || !lap.exerciseName;
                totalDuration += lap.totalElapsedTime;
                segments.push({
                  label: lap.exerciseName || `Lap ${i + 1}`,
                  icon: getStationIcon(lap.exerciseName || ''),
                  duration: lap.totalElapsedTime,
                  isRun: isRun
                });
              }
            });
          }

          if (segments.length > 0) {
            // Find the longest segment for scaling (so longest bar = 100%)
            const maxDuration = Math.max(...segments.map(s => s.duration));

            // Render the bar chart
            hybridBarsContainer.innerHTML = segments.map(seg => {
              // Scale relative to longest segment, minimum 15% to keep readable
              const widthPercent = Math.max(15, (seg.duration / maxDuration) * 100);
              const barClass = seg.isRun ? 'bar-run' : 'bar-station';
              return `
                <div class="hybrid-race-bar-row">
                  <span class="hybrid-race-bar-icon">${seg.icon}</span>
                  <span class="hybrid-race-bar-label">${seg.label}</span>
                  <div class="hybrid-race-bar-container">
                    <div class="hybrid-race-bar ${barClass}" style="width: ${widthPercent}%;">
                      <span class="hybrid-race-bar-time">${formatTime(seg.duration)}</span>
                    </div>
                  </div>
                </div>
              `;
            }).join('');

            // Render total
            hybridTotal.innerHTML = `
              <span class="hybrid-race-total-label">‚è±Ô∏è Total Race Time</span>
              <span class="hybrid-race-total-value">${formatDuration(totalDuration)}</span>
            `;

            hybridSection.style.display = 'block';
          }
        }

        // Helper function for station icons
        function getStationIcon(name) {
          const n = name.toLowerCase();
          if (n.includes('run')) return 'üèÉ';
          if (n.includes('ski')) return '‚õ∑Ô∏è';
          if (n.includes('sled push')) return 'üõ∑';
          if (n.includes('sled pull')) return 'üõ∑';
          if (n.includes('burpee')) return 'üèãÔ∏è';
          if (n.includes('row')) return 'üö£';
          if (n.includes('farmer')) return 'üß≥';
          if (n.includes('sandbag') || n.includes('lunge')) return 'üéí';
          if (n.includes('wall ball')) return 'üèê';
          return 'üèÅ';
        }
      }

      // Enrichments
      if (data.appliedEnrichments && data.appliedEnrichments.length > 0) {
        const enrichSection = document.getElementById('enrichments-section');
        const badgesEl = document.getElementById('enrichment-badges');
        const registry = data.registry || {};

        badgesEl.innerHTML = data.appliedEnrichments.map(e => {
          const info = registry[e] || {
            icon: '‚ö°',
            name: e.replace('ENRICHER_PROVIDER_', '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
            description: 'Boosted activity data'
          };
          return `
          <div class="enrichment-item">
            <span class="enrichment-icon">${info.icon}</span>
            <div class="enrichment-info">
              <div class="enrichment-name">${info.name}</div>
              <div class="enrichment-desc">${info.description || info.desc}</div>
            </div>
          </div>
        `;
        }).join('');
        enrichSection.style.display = 'block';
      }

      // Muscle Activation Image
      if (data.enrichmentMetadata && data.enrichmentMetadata.asset_muscle_heatmap) {
        const muscleSection = document.getElementById('muscle-activation-section');
        const muscleContainer = document.getElementById('muscle-heatmap-container');
        // Only render if not already rendered above
        if (!muscleContainer.hasChildNodes()) {
          renderAsset(data.enrichmentMetadata.asset_muscle_heatmap, 'Muscle Activation Heatmap', 'muscle-heatmap-image', muscleContainer);
        }
        muscleSection.style.display = 'block';
      }

      // Description - Parse into sections and render as cards
      if (data.description) {
        renderDescriptionSections(data.description);
      }

      // Tags
      if (data.tags && data.tags.length > 0) {
        document.getElementById('tags-section').style.display = 'block';
        document.getElementById('activity-tags').innerHTML = data.tags.map(t =>
          `<span class="activity-tag">${t}</span>`
        ).join('');
      }
    }

    // --- MAP INITIALIZATION ---
    // Make initMap globally accessible for onclick handlers
    window.initMap = function initMap(records) {
      const map = L.map('activity-map', {
        zoomControl: true,
        scrollWheelZoom: false
      });

      // Dark theme tiles
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap, &copy; CARTO',
        maxZoom: 19
      }).addTo(map);

      // Create route polyline with gradient effect
      const latlngs = records.map(r => [r.positionLat, r.positionLong]);

      const routeLine = L.polyline(latlngs, {
        color: '#FF1B8D',
        weight: 4,
        opacity: 0.9,
        lineCap: 'round',
        lineJoin: 'round'
      }).addTo(map);

      // Add start/end markers
      if (latlngs.length > 0) {
        L.circleMarker(latlngs[0], {
          radius: 8,
          fillColor: '#06FFA5',
          color: '#fff',
          weight: 2,
          fillOpacity: 1
        }).addTo(map).bindPopup('Start');

        L.circleMarker(latlngs[latlngs.length - 1], {
          radius: 8,
          fillColor: '#FF1B8D',
          color: '#fff',
          weight: 2,
          fillOpacity: 1
        }).addTo(map).bindPopup('Finish');
      }

      map.fitBounds(routeLine.getBounds(), { padding: [30, 30] });
    }

    // --- ELAPSED TIME HELPER ---
    // Generates time labels for chart X-axis in MM:SS format
    function generateTimeLabels(records) {
      if (!records || records.length === 0) return [];

      const firstRecord = records.find(r => r.timestamp);
      if (!firstRecord) return records.map((_, i) => i); // Fallback to indices

      const startTime = new Date(firstRecord.timestamp).getTime();

      return records.map(r => {
        if (!r.timestamp) return '';
        const elapsed = (new Date(r.timestamp).getTime() - startTime) / 1000; // seconds
        const mins = Math.floor(elapsed / 60);
        const secs = Math.floor(elapsed % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      });
    }

    // --- TIME MARKER ANNOTATIONS HELPER ---
    // Calculates marker positions based on elapsed time from activity start
    function calculateMarkerAnnotations(records, timeMarkers) {
      if (!timeMarkers || timeMarkers.length === 0 || !records || records.length === 0) {
        return {};
      }

      // Find first and last record timestamps to establish time range
      const recordsWithTime = records.filter(r => r.timestamp);
      if (recordsWithTime.length < 2) return {};

      const firstTime = new Date(recordsWithTime[0].timestamp).getTime();
      const lastTime = new Date(recordsWithTime[recordsWithTime.length - 1].timestamp).getTime();
      const totalDuration = lastTime - firstTime;
      if (totalDuration <= 0) return {};

      const annotations = {};
      const colors = ['#4CC9F0', '#FF1B8D', '#9D4EDD', '#FFD93D', '#6BCB77', '#FF6B6B'];

      // Sort markers by timestamp
      const sortedMarkers = [...timeMarkers]
        .filter(m => m.timestamp)
        .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

      sortedMarkers.forEach((marker, idx) => {
        const markerTime = new Date(marker.timestamp).getTime();

        // Calculate where this marker falls as a proportion of total time
        const elapsed = markerTime - firstTime;
        const proportion = elapsed / totalDuration;

        // Map to chart index (0 to records.length - 1)
        const chartIndex = Math.round(proportion * (records.length - 1));

        // Clamp to valid chart range (first marker often falls at/before first record)
        const clampedIndex = Math.max(0, Math.min(chartIndex, records.length - 1));

        // Multi-line label: each word on its own line for full context
        const fullLabel = marker.label || `M${idx + 1}`;
        const labelLines = fullLabel.split(' ');

        annotations['marker' + idx] = {
          type: 'line',
          xMin: clampedIndex,
          xMax: clampedIndex,
          borderColor: colors[idx % colors.length],
          borderWidth: 1,
          borderDash: [4, 4],
          label: {
            display: true,
            content: labelLines,
            position: 'start',
            yAdjust: -5,
            backgroundColor: 'transparent',
            color: colors[idx % colors.length],
            font: { size: 9, weight: 'bold' },
            padding: 2
          }
        };
      });

      return annotations;
    }

    // --- HEART RATE CHART ---
    function initHrChart(records, timeMarkers) {
      const ctx = document.getElementById('hr-chart').getContext('2d');

      // Interpolate missing HR values for continuous line
      const hrData = records.map((r, i) => {
        if (r.heartRate > 0) return r.heartRate;

        // Find nearest valid HR before and after
        let prevHR = null, nextHR = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].heartRate > 0) { prevHR = records[j].heartRate; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].heartRate > 0) { nextHR = records[j].heartRate; break; }
        }

        // Interpolate or use nearest valid
        if (prevHR !== null && nextHR !== null) return (prevHR + nextHR) / 2;
        return prevHR || nextHR || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Heart Rate',
            data: hrData,
            borderColor: '#ff6b6b',
            backgroundColor: 'rgba(255, 107, 107, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            annotation: { annotations }
          },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: {
                color: '#666',
                maxTicksLimit: 8,
                font: { size: 9 }
              }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa' }
            }
          }
        }
      };

      storeChartConfig('hr', config);
      new Chart(ctx, config);
    }

    // --- ELEVATION CHART ---
    function initElevationChart(records, timeMarkers) {
      const ctx = document.getElementById('elevation-chart').getContext('2d');

      // Interpolate missing altitude values
      const elevData = records.map((r, i) => {
        if (r.altitude !== undefined) return r.altitude;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].altitude !== undefined) { prev = records[j].altitude; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].altitude !== undefined) { next = records[j].altitude; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Elevation',
            data: elevData,
            borderColor: '#9D4EDD',
            backgroundColor: 'rgba(157, 78, 221, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + 'm' }
            }
          }
        }
      };

      storeChartConfig('elevation', config);
      new Chart(ctx, config);
    }

    // --- PACE CHART (converts speed m/s to min/km) ---
    function initPaceChart(records, timeMarkers) {
      const ctx = document.getElementById('pace-chart').getContext('2d');

      // Convert speed to pace, interpolate missing values
      const paceData = records.map((r, i) => {
        if (r.speed > 0) {
          const pace = (1000 / r.speed) / 60;
          return pace < 15 ? pace : null; // Cap unreasonable paces
        }

        // Find nearest valid pace
        let prevPace = null, nextPace = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].speed > 0) {
            const p = (1000 / records[j].speed) / 60;
            if (p < 15) { prevPace = p; break; }
          }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].speed > 0) {
            const p = (1000 / records[j].speed) / 60;
            if (p < 15) { nextPace = p; break; }
          }
        }
        if (prevPace !== null && nextPace !== null) return (prevPace + nextPace) / 2;
        return prevPace || nextPace || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Pace',
            data: paceData,
            borderColor: '#FFD93D',
            backgroundColor: 'rgba(255, 217, 61, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              reverse: true, // Lower pace = faster, so reverse axis
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: {
                color: '#aaa',
                callback: v => {
                  const mins = Math.floor(v);
                  const secs = Math.round((v - mins) * 60);
                  return mins + ':' + secs.toString().padStart(2, '0') + '/km';
                }
              }
            }
          }
        }
      };

      storeChartConfig('pace', config);
      new Chart(ctx, config);
    }

    // --- POWER CHART ---
    function initPowerChart(records, timeMarkers) {
      const ctx = document.getElementById('power-chart').getContext('2d');

      // Interpolate missing power values
      const powerData = records.map((r, i) => {
        if (r.power > 0) return r.power;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].power > 0) { prev = records[j].power; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].power > 0) { next = records[j].power; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Power',
            data: powerData,
            borderColor: '#06FFA5',
            backgroundColor: 'rgba(6, 255, 165, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + 'W' }
            }
          }
        }
      };

      storeChartConfig('power', config);
      new Chart(ctx, config);
    }

    // --- CADENCE CHART ---
    function initCadenceChart(records, timeMarkers) {
      const ctx = document.getElementById('cadence-chart').getContext('2d');

      // Interpolate missing cadence values
      const cadenceData = records.map((r, i) => {
        if (r.cadence > 0) return r.cadence;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].cadence > 0) { prev = records[j].cadence; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].cadence > 0) { next = records[j].cadence; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Cadence',
            data: cadenceData,
            borderColor: '#FF6B9D',
            backgroundColor: 'rgba(255, 107, 157, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + ' rpm' }
            }
          }
        }
      };

      storeChartConfig('cadence', config);
      new Chart(ctx, config);
    }

    // --- SPEED CHART (converts m/s to km/h) ---
    function initSpeedChart(records, timeMarkers) {
      const ctx = document.getElementById('speed-chart').getContext('2d');

      // Interpolate missing speed values
      const speedData = records.map((r, i) => {
        if (r.speed > 0) return r.speed * 3.6; // m/s to km/h

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].speed > 0) { prev = records[j].speed * 3.6; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].speed > 0) { next = records[j].speed * 3.6; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Speed',
            data: speedData,
            borderColor: '#00D4FF',
            backgroundColor: 'rgba(0, 212, 255, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v.toFixed(1) + ' km/h' }
            }
          }
        }
      };

      storeChartConfig('speed', config);
      new Chart(ctx, config);
    }

    // --- DESCRIPTION SECTION PARSING ---

    /**
     * Parse enriched description into sections based on enricher headers.
     * Headers follow pattern: emoji + text + colon (e.g., "‚ú® AI Summary:")
     * Handles multi-line sections by grouping content until next header.
     */
    function parseDescriptionSections(text) {
      if (!text) return [];

      // Branding footer to strip entirely (showcase has plenty of FitGlue branding)
      const brandingPattern = /\n?\n?Posted via FitGlue\s*üí™/g;

      // Strip branding from description before parsing
      text = text.replace(brandingPattern, '').trim();
      if (!text) return [];

      // Section headers are lines that END with a colon (nothing after the colon on that line)
      // This elegantly distinguishes:
      //   "üèÅ Hyrox - Male Single:" (section header - line ends with colon)
      //   "üèÉ Run 1: 5:54 (1.1km)" (NOT a section header - has content after colon)
      const lines = text.split('\n');
      const sections = [];
      let currentSection = null;
      let preHeaderContent = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        const prevLine = i > 0 ? lines[i - 1].trim() : '';

        // Check if this line is a section header. Two patterns:
        // 1. Line ends with colon (multi-line sections like "üèÅ Hyrox - Male Single:")
        // 2. Line preceded by blank line AND starts with emoji + colon pattern (single-line like "‚ù§Ô∏è Heart Rate: value")
        const endsWithColon = trimmedLine.endsWith(':') && trimmedLine.length > 1;
        // Single-line sections must start with an emoji (not dash, bullet, etc.)
        const startsWithEmoji = /^[\u{1F300}-\u{1FAD6}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{FE00}-\u{FE0F}\u{1F900}-\u{1F9FF}\u{2300}-\u{23FF}]/u.test(trimmedLine);
        const isSingleLineSection = prevLine === '' && i > 0 && startsWithEmoji && trimmedLine.includes(':');

        if (endsWithColon || isSingleLineSection) {
          // Save any pre-header content as "Description"
          if (currentSection === null && preHeaderContent.length > 0) {
            const content = preHeaderContent.join('\n').trim();
            if (content) {
              sections.push({ emoji: 'üìù', title: 'Description', content: content });
            }
            preHeaderContent = [];
          }

          // Save previous section
          if (currentSection !== null) {
            sections.push(currentSection);
          }

          // Extract emoji and title from header
          let emoji, title, sectionContent;

          if (endsWithColon) {
            // Multi-line section: "üèÅ Title:" - content is on subsequent lines
            const headerText = trimmedLine.slice(0, -1).trim();
            const emojiResult = extractLeadingEmoji(headerText);
            emoji = emojiResult.emoji;
            title = emojiResult.rest.trim() || 'Section';
            sectionContent = '';
          } else {
            // Single-line section: "‚ù§Ô∏è Heart Rate: value" - content is after the colon
            const colonIdx = trimmedLine.indexOf(':');
            const headerText = trimmedLine.slice(0, colonIdx).trim();
            const emojiResult = extractLeadingEmoji(headerText);
            emoji = emojiResult.emoji;
            title = emojiResult.rest.trim() || 'Section';
            sectionContent = trimmedLine.slice(colonIdx + 1).trim();
          }

          currentSection = { emoji, title, content: sectionContent };
        } else if (currentSection === null) {
          // Content before any section header (user description)
          preHeaderContent.push(line);
        } else {
          // Content within current section
          currentSection.content += (currentSection.content ? '\n' : '') + line;
        }
      }

      // Save final section
      if (currentSection !== null) {
        currentSection.content = currentSection.content.trim();
        sections.push(currentSection);
      } else if (preHeaderContent.length > 0) {
        // No sections found - treat all as description
        const content = preHeaderContent.join('\n').trim();
        if (content) {
          sections.push({ emoji: 'üìù', title: 'Description', content: content });
        }
      }

      return sections;
    }

    /**
     * Render parsed sections as individual styled cards.
     * - User description goes to hero section (prominent display)
     * - Compact sections (single-line) are grouped horizontally
     * - Normal sections render as full-width cards
     */
    function renderDescriptionSections(text) {
      const container = document.getElementById('description-sections-container');
      const userDescEl = document.getElementById('user-description');
      const sections = parseDescriptionSections(text);

      if (sections.length === 0) {
        container.style.display = 'none';
        userDescEl.style.display = 'none';
        return;
      }

      // Separate user description from enricher sections
      const userDescSection = sections.find(s => s.title === 'Description');
      const aiSummarySection = sections.find(s => s.title === 'AI Summary');
      const enricherSections = sections.filter(s => s.title !== 'Description' && s.title !== 'AI Summary');

      // Render user description in hero
      if (userDescSection && userDescSection.content) {
        userDescEl.textContent = userDescSection.content;
        userDescEl.style.display = 'block';
      } else {
        userDescEl.style.display = 'none';
      }

      // Promote AI Summary to appear right after user description
      const aiContainer = document.getElementById('ai-summary-container');
      if (aiSummarySection && aiSummarySection.content) {
        aiContainer.innerHTML = renderAISummarySection(aiSummarySection, 0);
        aiContainer.style.display = 'block';
      } else {
        aiContainer.style.display = 'none';
      }

      // If no enricher sections, hide container
      if (enricherSections.length === 0) {
        container.style.display = 'none';
        return;
      }

      // --- Suppress sections whose graph is already visible ---
      const graphSectionMap = {
        'Heart Rate': 'hr-graph-section',
        'Pace': 'pace-section',
        'Power': 'power-section',
        'Cadence': 'cadence-section',
        'Speed': 'speed-section',
        'Elevation': 'elevation-section',
      };
      const graphSummaryMap = {
        'Pace': 'pace-summary',
        'Power': 'power-summary',
        'Cadence': 'cadence-summary',
        'Speed': 'speed-summary',
        'Elevation': 'elevation-summary',
      };

      // Store suppressed section data for graph summary migration
      window._showcaseGraphStats = {};

      const filteredSections = enricherSections.filter(section => {
        const graphId = graphSectionMap[section.title];
        if (graphId) {
          const graphEl = document.getElementById(graphId);
          if (graphEl && graphEl.style.display !== 'none') {
            // Graph is visible ‚Äî suppress this description section
            window._showcaseGraphStats[section.title] = section;
            return false;
          }
        }
        // Suppress Hyrox/ATHX race text section when Race Breakdown is visible
        {
          const hybridEl = document.getElementById('hybrid-race-section');
          if (hybridEl && hybridEl.style.display !== 'none') {
            const t = section.title.toLowerCase();
            if (t.startsWith('hyrox') || t.startsWith('athx')) return false;
          }
        }
        return true;
      });

      // --- Populate graph summary bars from suppressed sections ---
      populateGraphSummaries();

      // --- Merge Location + Weather into a single conditions section ---
      const locationSection = filteredSections.find(s => s.title === 'Location');
      const weatherSection = filteredSections.find(s => s.title === 'Weather');
      const mergedSections = filteredSections.filter(s => s.title !== 'Location' && s.title !== 'Weather');
      if (locationSection || weatherSection) {
        mergedSections.push({
          title: 'Conditions',
          emoji: 'üåç',
          content: '',
          _location: locationSection,
          _weather: weatherSection,
          _merged: true,
        });
      }

      if (mergedSections.length === 0) {
        container.style.display = 'none';
        return;
      }

      // Detect compact sections (single-line, short content)
      const isCompact = (section) => {
        if (section._merged) return false;
        const lines = section.content.split('\n').filter(l => l.trim());
        return lines.length <= 1 && section.content.length < 100;
      };

      // Group consecutive compact sections for horizontal layout
      let html = '';
      let compactGroup = [];
      let idx = 0;

      const flushCompactGroup = () => {
        if (compactGroup.length === 0) return;

        // If single compact section, render normally to avoid orphan
        if (compactGroup.length === 1) {
          compactGroup.forEach(section => {
            html += renderSectionCard(section, idx++);
          });
        } else {
          // Wrap in horizontal row
          html += '<div class="compact-sections-row">';
          compactGroup.forEach(section => {
            html += renderSectionCard(section, idx++);
          });
          html += '</div>';
        }
        compactGroup = [];
      };

      mergedSections.forEach((section) => {
        if (isCompact(section)) {
          compactGroup.push(section);
        } else {
          flushCompactGroup();
          html += renderSectionCard(section, idx++);
        }
      });
      flushCompactGroup();

      container.innerHTML = html;
      container.style.display = 'block';
    }

    /**
     * Populate graph summary bars from suppressed description sections.
     */
    function populateGraphSummaries() {
      const stats = window._showcaseGraphStats || {};

      // HR drift badge (HR section always has graph data via hr-summary)
      const hrSection = stats['Heart Rate'];
      if (hrSection) {
        const driftMatch = hrSection.content.match(/Drift:\s*([+-]?\d+)\s*bpm\s*\(([^)]+)\)/i);
        if (driftMatch) {
          const driftVal = parseInt(driftMatch[1]);
          const driftNote = driftMatch[2];
          const badgeClass = Math.abs(driftVal) > 15 ? 'warning' : 'normal';
          const summaryEl = document.getElementById('hr-summary');
          if (summaryEl) {
            summaryEl.innerHTML += `
              <div class="hr-stat-mini">
                <span class="hr-value-mini" style="color:${badgeClass === 'warning' ? '#fb923c' : '#4ade80'}">${driftVal > 0 ? '+' : ''}${driftVal}</span>
                <span class="hr-label-mini">Drift</span>
                <span class="hr-drift-badge ${badgeClass}">${escapeHtml(driftNote)}</span>
              </div>`;
          }
        }
      }

      // Parse compact stat pills format: "value1 label1 ‚Ä¢ value2 label2"
      const parseCompactPills = (content) => {
        return content.split(' ‚Ä¢ ').map(p => p.trim()).filter(Boolean).map(part => {
          const m = part.match(/^(.+?)\s+(avg|max|min|best|total|gain|loss)$/i);
          return m ? { value: m[1], label: m[2] } : { value: part, label: '' };
        });
      };

      // Populate Pace summary
      const paceSec = stats['Pace'];
      if (paceSec) {
        const el = document.getElementById('pace-summary');
        if (el) {
          const pills = parseCompactPills(paceSec.content);
          el.innerHTML = pills.map(p =>
            `<div class="graph-stat-mini"><span class="graph-value-mini pace">${escapeHtml(p.value)}</span><span class="graph-label-mini">${escapeHtml(p.label)}</span></div>`
          ).join('');
        }
      }

      // Populate Power summary
      const powerSec = stats['Power'];
      if (powerSec) {
        const el = document.getElementById('power-summary');
        if (el) {
          const pills = parseCompactPills(powerSec.content);
          el.innerHTML = pills.map(p =>
            `<div class="graph-stat-mini"><span class="graph-value-mini power">${escapeHtml(p.value)}</span><span class="graph-label-mini">${escapeHtml(p.label)}</span></div>`
          ).join('');
        }
      }

      // Populate Cadence summary
      const cadenceSec = stats['Cadence'];
      if (cadenceSec) {
        const el = document.getElementById('cadence-summary');
        if (el) {
          const pills = parseCompactPills(cadenceSec.content);
          el.innerHTML = pills.map(p =>
            `<div class="graph-stat-mini"><span class="graph-value-mini cadence">${escapeHtml(p.value)}</span><span class="graph-label-mini">${escapeHtml(p.label)}</span></div>`
          ).join('');
        }
      }

      // Populate Speed summary
      const speedSec = stats['Speed'];
      if (speedSec) {
        const el = document.getElementById('speed-summary');
        if (el) {
          const pills = parseCompactPills(speedSec.content);
          el.innerHTML = pills.map(p =>
            `<div class="graph-stat-mini"><span class="graph-value-mini speed">${escapeHtml(p.value)}</span><span class="graph-label-mini">${escapeHtml(p.label)}</span></div>`
          ).join('');
        }
      }

      // Populate Elevation summary
      const elevSec = stats['Elevation'];
      if (elevSec) {
        const el = document.getElementById('elevation-summary');
        if (el) {
          // First line is stats, skip sparkline
          const firstLine = elevSec.content.split('\n')[0] || '';
          const pills = parseCompactPills(firstLine);
          const colorMap = { gain: 'elevation-gain', loss: 'elevation-loss', max: 'elevation-max' };
          el.innerHTML = pills.map(p => {
            const colorClass = colorMap[p.label.toLowerCase()] || '';
            return `<div class="graph-stat-mini"><span class="graph-value-mini ${colorClass}">${escapeHtml(p.value)}</span><span class="graph-label-mini">${escapeHtml(p.label)}</span></div>`;
          }).join('');
        }
      }
    }

    /**
     * Render a single section card.
     * Delegates to specialised renderers for known enricher sections.
     */
    function renderSectionCard(section, idx) {
      const title = section.title;

      // Route to specialised renderers based on section title
      if (title === 'Personal Records') return renderPRSection(section, idx);
      if (title.startsWith('Intervals')) return renderIntervalsSection(section, idx);
      if (title === 'Heart Rate Zones') return renderHRZonesSection(section, idx);
      if (title.includes('Goal Progress')) return renderGoalSection(section, idx);
      if (title === 'Streak Tracker') return renderStreakSection(section, idx);
      if (title.startsWith('Lifetime')) return renderMilestoneSection(section, idx);
      if (title === 'Parkrun Results') return renderParkrunSection(section, idx);
      if (title.startsWith('Effort Score')) return renderEffortScoreSection(section, idx);
      if (title === 'Workout Summary') return renderWorkoutSummarySection(section, idx);

      // AI Summary gets pretty prose styling
      if (title === 'AI Summary') return renderAISummarySection(section, idx);

      // New specialized renderers
      if (title === 'Heart Rate') return renderHeartRateSection(section, idx);
      if (title === 'Recovery Advisor') return renderRecoverySection(section, idx);
      if (title === 'Calories') return renderCaloriesSection(section, idx);
      if (title === 'Training Load') return renderTrainingLoadSection(section, idx);
      if (title === 'Muscle Heatmap') return renderMuscleHeatmapSection(section, idx);
      if (title === 'Elevation') return renderElevationSection(section, idx);
      if (title === 'Running Dynamics') return renderRunningDynamicsSection(section, idx);
      if (title === 'Splits') return renderSplitsSection(section, idx);
      if (title === 'Conditions' && section._merged) return renderConditionsSection(section, idx);

      // Bullet-list sections get parsed stat rows
      const lines = section.content.split('\n').filter(l => l.trim());
      const bulletLines = lines.filter(l => l.trim().startsWith('‚Ä¢'));
      if (bulletLines.length > 0 && bulletLines.length === lines.length) {
        return renderBulletListSection(section, idx);
      }

      // Single-line with ‚Ä¢ separators get enhanced stat pills
      if (lines.length <= 1 && section.content.includes(' ‚Ä¢ ')) {
        return renderEnhancedCompactPills(section, idx);
      }

      // Single-line compact sections get enhanced value display
      if (lines.length <= 1 && section.content.trim()) {
        return renderEnhancedCompactPills(section, idx);
      }

      // Generic fallback
      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header">
            <h2>${section.emoji} ${section.title}</h2>
          </div>
          <pre class="activity-description">${escapeHtml(section.content)}</pre>
        </div>
      `;
    }

    /**
     * Heart Rate section ‚Äî color-coded min/avg/max dashboard with drift badge.
     */
    function renderHeartRateSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let min = '', avg = '', max = '', driftText = '', driftNote = '';

      lines.forEach(line => {
        const clean = line.replace(/^‚Ä¢\s*/, '').trim();
        const minM = clean.match(/(\d+)\s*bpm\s*min/i);
        const avgM = clean.match(/(\d+)\s*bpm\s*avg/i);
        const maxM = clean.match(/(\d+)\s*bpm\s*max/i);
        const driftM = clean.match(/Drift:\s*([+-]?\d+\s*bpm)\s*\(([^)]+)\)/i);
        if (minM) min = minM[1];
        if (avgM) avg = avgM[1];
        if (maxM) max = maxM[1];
        if (driftM) { driftText = driftM[1]; driftNote = driftM[2]; }
      });

      const driftVal = parseInt(driftText);
      const badgeClass = Math.abs(driftVal) > 15 ? 'warning' : 'normal';

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="hr-dashboard">
            ${min ? `<div class="hr-dashboard-stat"><span class="hr-dashboard-value min">${min}</span><span class="hr-dashboard-label">Min</span><span class="hr-dashboard-unit">bpm</span></div>` : ''}
            ${avg ? `<div class="hr-dashboard-stat"><span class="hr-dashboard-value avg">${avg}</span><span class="hr-dashboard-label">Avg</span><span class="hr-dashboard-unit">bpm</span></div>` : ''}
            ${max ? `<div class="hr-dashboard-stat"><span class="hr-dashboard-value max">${max}</span><span class="hr-dashboard-label">Max</span><span class="hr-dashboard-unit">bpm</span></div>` : ''}
            ${driftText ? `<div class="hr-dashboard-stat"><span class="hr-dashboard-value" style="color:${badgeClass === 'warning' ? '#fb923c' : '#4ade80'}">${escapeHtml(driftText.replace(/\s*bpm/, ''))}</span><span class="hr-dashboard-label">Drift</span><span class="hr-drift-badge ${badgeClass}">${escapeHtml(driftNote)}</span></div>` : ''}
          </div>
        </div>`;
    }

    /**
     * Recovery Advisor ‚Äî structured grid with session load, 7-day/28-day loads, ACWR, and recovery callout.
     */
    function renderRecoverySection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let sessionVal = '', sessionTag = '', weekVal = '', chronicVal = '', acwrVal = '', acwrLabel = '', suggestion = '', fatigueWarning = '';

      lines.forEach(line => {
        const clean = line.replace(/^‚Ä¢\s*/, '').trim();
        const sessionM = clean.match(/Session\s*load:\s*([\d.]+\s*TRIMP)\s*\(([\w\s]+)\)/i);
        const loadM = clean.match(/7-day\s*load:\s*([\d.]+\s*TRIMP)\s*‚Ä¢\s*28-day\s*avg:\s*([\d.]+\s*TRIMP)/i);
        const weekOnlyM = !loadM && clean.match(/7-day\s*load:\s*([\d.]+\s*TRIMP)/i);
        const acwrM = clean.match(/ACWR:\s*([\d.]+)\s*\(([^)‚ö†Ô∏è]+)/i);
        const sugM = clean.match(/Suggested\s*recovery:\s*(.+)/i);
        const fatigueM = clean.match(/(\d+)\s*consecutive\s*hard\s*days/i);
        if (sessionM) { sessionVal = sessionM[1]; sessionTag = sessionM[2].trim(); }
        if (loadM) { weekVal = loadM[1]; chronicVal = loadM[2]; }
        if (weekOnlyM) weekVal = weekOnlyM[1];
        if (acwrM) { acwrVal = acwrM[1]; acwrLabel = acwrM[2].trim(); }
        if (sugM) suggestion = sugM[1].replace(/^üí°\s*/, '');
        if (fatigueM) fatigueWarning = clean.replace(/^‚ö†Ô∏è\s*/, '');
      });

      const intensityClass = sessionTag.toLowerCase() === 'easy' || sessionTag.toLowerCase() === 'recovery' ? 'easy' : sessionTag.toLowerCase() === 'moderate' ? 'moderate' : 'hard';
      const acwrClass = acwrLabel.toLowerCase();
      const hasACWR = acwrVal !== '';

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="recovery-grid${hasACWR ? ' has-acwr' : ''}">
            <div class="recovery-stat-block">
              <div class="recovery-stat-value">${escapeHtml(sessionVal)}${sessionTag ? `<span class="recovery-stat-tag ${intensityClass}">${escapeHtml(sessionTag)}</span>` : ''}</div>
              <div class="recovery-stat-label">Session Load</div>
              <div class="recovery-stat-hint">How hard this session was</div>
            </div>
            <div class="recovery-stat-block">
              <div class="recovery-stat-value">${escapeHtml(weekVal)}</div>
              ${chronicVal ? `<div class="recovery-stat-sub">28d: ${escapeHtml(chronicVal)}</div>` : ''}
              <div class="recovery-stat-label">7-Day Load</div>
              <div class="recovery-stat-hint">Cumulative training this week</div>
            </div>
            ${hasACWR ? `<div class="recovery-stat-block">
              <div class="recovery-stat-value">${escapeHtml(acwrVal)}${acwrLabel ? `<span class="recovery-stat-tag ${acwrClass}">${escapeHtml(acwrLabel)}</span>` : ''}</div>
              <div class="recovery-stat-label">Workload Ratio</div>
              <div class="recovery-stat-hint">Recent vs long-term training balance</div>
            </div>` : ''}
          </div>
          ${fatigueWarning ? `<div class="recovery-fatigue-warning"><span>‚ö†Ô∏è</span><span>${escapeHtml(fatigueWarning)}</span></div>` : ''}
          ${suggestion ? `<div class="recovery-suggestion"><span class="icon">üïê</span><span>Suggested recovery: <span class="value">${escapeHtml(suggestion)}</span></span></div>` : ''}
        </div>`;
    }

    /**
     * Calories ‚Äî large value with food comparison callout.
     */
    function renderCaloriesSection(section, idx) {
      const text = section.content.trim();
      // Parse "223 kcal ‚âà 0.8 slice of pizza üçï"
      const m = text.match(/^([\d.]+)\s*kcal\s*‚âà?\s*(.+)$/);
      if (!m) return renderEnhancedCompactPills(section, idx);

      const kcal = m[1];
      const comparison = m[2].trim();

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="calories-display">
            <div class="calories-value-block">
              <span class="calories-number">${escapeHtml(kcal)}</span>
              <div class="calories-unit">kcal</div>
            </div>
            <div class="calories-food-callout">‚âà ${escapeHtml(comparison)}</div>
          </div>
        </div>`;
    }

    /**
     * Training Load ‚Äî gauge-style with intensity badge and scale bar.
     */
    function renderTrainingLoadSection(section, idx) {
      const text = section.content.trim();
      // Parse "38 (Easy)"
      const m = text.match(/^([\d.]+)\s*\((\w+)\)$/);
      if (!m) return renderEnhancedCompactPills(section, idx);

      const value = parseFloat(m[1]);
      const intensity = m[2];
      const intLower = intensity.toLowerCase();
      const badgeClass = intLower === 'recovery' ? 'recovery' : intLower === 'easy' ? 'easy' : intLower === 'moderate' ? 'moderate' : intLower === 'hard' ? 'hard' : 'extreme';

      // Scale: 0-200 range for training load
      const fillPct = Math.min((value / 200) * 100, 100);
      const gradientColors = {
        recovery: 'linear-gradient(90deg, #67e8f9, #06b6d4)',
        easy: 'linear-gradient(90deg, #4ade80, #22c55e)',
        moderate: 'linear-gradient(90deg, #fbbf24, #f59e0b)',
        hard: 'linear-gradient(90deg, #fb923c, #f97316)',
        extreme: 'linear-gradient(90deg, #ef4444, #dc2626)',
      };

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="training-load-display">
            <span class="training-load-value">${escapeHtml(m[1])}</span>
            <span class="training-load-badge ${badgeClass}">${escapeHtml(intensity)}</span>
          </div>
          <div class="training-load-scale">
            <div class="training-load-fill" style="width:${fillPct}%;background:${gradientColors[badgeClass]}"></div>
          </div>
        </div>`;
    }

    /**
     * Elevation section (when no graph) ‚Äî columnar stats + sparkline.
     */
    function renderElevationSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const firstLine = lines[0] || '';
      const sparkline = lines.length > 1 ? lines[1].replace(/^üìà\s*/, '') : '';

      // Parse "+36m gain ‚Ä¢ -36m loss ‚Ä¢ 28m max"
      const parts = firstLine.split(' ‚Ä¢ ').map(p => p.trim()).filter(Boolean);
      const stats = parts.map(part => {
        const m = part.match(/^([+-]?[\d.]+\w*)\s+(.+)$/);
        if (m) {
          const label = m[2].toLowerCase();
          const arrow = label.includes('gain') ? '‚Üë' : label.includes('loss') ? '‚Üì' : '‚ñ≤';
          const cssClass = label.includes('gain') ? 'elevation-gain' : label.includes('loss') ? 'elevation-loss' : 'elevation-max';
          return { value: m[1], label: m[2], arrow, cssClass };
        }
        return { value: part, label: '', arrow: '', cssClass: '' };
      });

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="elevation-stats-grid">
            ${stats.map(s => `
              <div class="elevation-stat">
                <span class="elevation-stat-arrow">${s.arrow}</span>
                <span class="elevation-stat-value" style="color:var(--${s.cssClass}, #fff)">${escapeHtml(s.value)}</span>
                <span class="elevation-stat-label">${escapeHtml(s.label)}</span>
              </div>
            `).join('')}
          </div>
          ${sparkline ? `<div class="elevation-sparkline">${escapeHtml(sparkline)}</div>` : ''}
        </div>`;
    }

    /**
     * Running Dynamics ‚Äî three stat cards: GCT, Stride, Vertical Oscillation.
     */
    function renderRunningDynamicsSection(section, idx) {
      const text = section.content.trim();
      // Parse "‚è±Ô∏è GCT: 253 ms ‚Ä¢ üìè Stride: 10.73 m ‚Ä¢ ‚ÜïÔ∏è Vert: 8.3 cm"
      const parts = text.split(' ‚Ä¢ ').map(p => p.trim()).filter(Boolean);

      const stats = parts.map(part => {
        const emojiResult = extractLeadingEmoji(part);
        const rest = emojiResult.rest.trim();
        const colonIdx = rest.indexOf(':');
        if (colonIdx > 0) {
          return {
            icon: emojiResult.emoji,
            label: rest.substring(0, colonIdx).trim(),
            value: rest.substring(colonIdx + 1).trim(),
          };
        }
        return { icon: emojiResult.emoji, label: '', value: rest };
      });

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="dynamics-grid">
            ${stats.map(s => `
              <div class="dynamics-stat">
                <div class="dynamics-icon">${s.icon}</div>
                <div class="dynamics-value">${escapeHtml(s.value)}</div>
                <div class="dynamics-label">${escapeHtml(s.label)}</div>
              </div>
            `).join('')}
          </div>
        </div>`;
    }

    /**
     * Splits ‚Äî visual pace bars for each km with fastest/slowest highlights.
     * Parses lines like: "‚Ä¢ Km 1: 5:12 üèÜ"
     */
    function renderSplitsSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());

      // Separate split bullet lines from insight lines
      const splitLines = [];
      const insightLines = [];
      lines.forEach(line => {
        const trimmed = line.trim();
        if (trimmed.startsWith('‚Ä¢')) {
          splitLines.push(trimmed);
        } else if (trimmed) {
          insightLines.push(trimmed);
        }
      });

      if (splitLines.length === 0) return renderBulletListSection(section, idx);

      // Parse each split line
      const splits = splitLines.map(line => {
        const clean = line.replace(/^‚Ä¢\s*/, '').trim();
        // Match "Km N: M:SS" with optional badge emoji(s)
        const m = clean.match(/^(Km\s*\d+|Mile\s*\d+):\s*(\d+:\d{2})(.*)$/i);
        if (!m) return null;
        const label = m[1];
        const pace = m[2];
        const rest = m[3].trim();
        const isFastest = rest.includes('üèÜ');
        const isSlowest = rest.includes('üê¢');
        // Convert M:SS to total seconds for bar sizing
        const [min, sec] = pace.split(':').map(Number);
        const totalSec = min * 60 + sec;
        return { label, pace, totalSec, isFastest, isSlowest, badge: isFastest ? 'üèÜ' : isSlowest ? 'üê¢' : '' };
      }).filter(Boolean);

      if (splits.length === 0) return renderBulletListSection(section, idx);

      // Find min/max for scaling bars (lower pace = faster = longer bar)
      const fastestSec = Math.min(...splits.map(s => s.totalSec));
      const slowestSec = Math.max(...splits.map(s => s.totalSec));
      const range = slowestSec - fastestSec || 1;

      const barsHtml = splits.map((s, i) => {
        // Scale: fastest gets 100%, slowest gets ~40%, linear interpolation
        const pct = 100 - ((s.totalSec - fastestSec) / range) * 60;
        const fillClass = s.isFastest ? 'fastest' : s.isSlowest ? 'slowest' : '';
        const delay = (idx * 0.1) + (i * 0.03);
        return `<div class="split-row" style="animation-delay:${delay}s">
          <span class="split-label">${escapeHtml(s.label)}</span>
          <div class="split-bar-track">
            <div class="split-bar-fill ${fillClass}" style="width:${pct}%"></div>
          </div>
          <span class="split-value">${escapeHtml(s.pace)}${s.badge ? `<span class="split-badge">${s.badge}</span>` : ''}</span>
        </div>`;
      }).join('');

      // Render insight lines (üî• Negative Split, üòì Fatigue, üí™ Strong Finish)
      const insightsHtml = insightLines.map((line, i) => {
        const emojiResult = extractLeadingEmoji(line);
        return `<div class="split-insight" style="animation-delay:${(idx * 0.1) + (splits.length * 0.03) + (i * 0.08)}s">
          <span class="insight-emoji">${emojiResult.emoji}</span>
          <span class="highlight">${escapeHtml(emojiResult.rest.trim())}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="splits-grid">${barsHtml}</div>
          ${insightsHtml}
        </div>`;
    }

    /**
     * Conditions ‚Äî merged Location + Weather row.
     */
    function renderConditionsSection(section, idx) {
      const locSection = section._location;
      const wxSection = section._weather;

      let items = [];

      if (locSection) {
        const locText = locSection.content.trim();
        // Parse "Long Bennington, South Kesteven (‚òÄÔ∏è Afternoon)"
        const locMatch = locText.match(/^(.+?)\s*\((.+)\)$/);
        if (locMatch) {
          items.push({ icon: 'üìç', value: locMatch[1], label: locMatch[2] });
        } else {
          items.push({ icon: 'üìç', value: locText, label: 'Location' });
        }
      }

      if (wxSection) {
        const wxText = wxSection.content.trim();
        // Parse "10¬∞C, Rain ‚Ä¢ Wind: 17 km/h SW"
        const wxParts = wxText.split(' ‚Ä¢ ').map(p => p.trim());
        wxParts.forEach(p => {
          const colonIdx = p.indexOf(':');
          if (colonIdx > 0) {
            items.push({ icon: 'üí®', value: p.substring(colonIdx + 1).trim(), label: p.substring(0, colonIdx).trim() });
          } else {
            items.push({ icon: 'üå°Ô∏è', value: p, label: 'Weather' });
          }
        });
      }

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="conditions-row">
            ${items.map(item => `
              <div class="conditions-item">
                <span class="conditions-icon">${item.icon}</span>
                <div class="conditions-text">
                  <span class="conditions-value">${escapeHtml(item.value)}</span>
                  <span class="conditions-label">${escapeHtml(item.label)}</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>`;
    }

    /**
     * Enhanced compact stat pills ‚Äî stacked value + label layout.
     */
    function renderEnhancedCompactPills(section, idx) {
      const parts = section.content.split(' ‚Ä¢ ').map(p => p.trim()).filter(Boolean);
      const pillsHtml = parts.map(part => {
        const labelMatch = part.match(/^(.+?)\s+(avg|max|min|best|total|gain|loss)$/i);
        if (labelMatch) {
          return `<div class="enhanced-stat-pill"><span class="pill-value">${escapeHtml(labelMatch[1])}</span><span class="pill-label">${escapeHtml(labelMatch[2])}</span></div>`;
        }
        return `<div class="enhanced-stat-pill"><span class="pill-value">${escapeHtml(part)}</span></div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="enhanced-pills-row">${pillsHtml}</div>
        </div>`;
    }

    /**
     * Parse a single PR bullet line into structured data.
     * Input:  "üèÜ Bench Press (barbell) 1RM: 53.3kg"
     * Input:  "üí™ Bench Press (barbell) Volume: 1280kg (previous: 1200kg, +6.7%)"
     */
    function parsePRLine(line) {
      // Strip leading bullet
      line = line.replace(/^‚Ä¢\s*/, '').trim();
      if (!line) return null;

      // Extract emoji (first character cluster)
      const chars = [...line];
      const emoji = chars[0] || 'üèÜ';
      let rest = line.slice(emoji.length).trim();

      // Split on the LAST colon that precedes the value
      // Pattern: "Name Type: value (previous: ...)"
      // We need the last TYPE keyword before the colon
      const typePatterns = ['1RM', 'Best Set Volume', 'Total Volume', 'Volume', 'Max Reps', 'Total Time',
        'Longest Run', 'Longest Ride', 'Highest Elevation Gain'];

      let name = '', recordType = '', value = '', previous = '', improvement = '';

      // Try to match known type suffixes
      let matched = false;

      // Dynamic match for "Fastest X:" patterns (covers all 23+ distance thresholds)
      const fastestMatch = rest.match(/^(Fastest\s+[^:]+?):\s*(.+)$/);
      if (fastestMatch) {
        name = '';
        recordType = fastestMatch[1].trim();
        const afterType = fastestMatch[2].trim();
        const parenMatch = afterType.match(/^(.+?)\s*\(previous:\s*(.+?),\s*([+-]?[\d.]+%)\)$/);
        if (parenMatch) {
          value = parenMatch[1].trim();
          previous = parenMatch[2].trim();
          improvement = parenMatch[3].trim();
        } else {
          value = afterType;
        }
        matched = true;
      }

      if (!matched) {
        for (const tp of typePatterns) {
          const idx = rest.lastIndexOf(tp + ':');
          if (idx >= 0) {
            name = rest.substring(0, idx).trim();
            const afterType = rest.substring(idx + tp.length + 1).trim();
            recordType = tp;

            // Extract improvement in parentheses
            const parenMatch = afterType.match(/^(.+?)\s*\(previous:\s*(.+?),\s*([+-]?[\d.]+%)\)$/);
            if (parenMatch) {
              value = parenMatch[1].trim();
              previous = parenMatch[2].trim();
              improvement = parenMatch[3].trim();
            } else {
              value = afterType;
            }
            matched = true;
            break;
          }
        }
      }

      // Fallback: split on first colon
      if (!matched) {
        const colonIdx = rest.indexOf(':');
        if (colonIdx < 0) return null;
        const beforeColon = rest.substring(0, colonIdx).trim();
        const afterColon = rest.substring(colonIdx + 1).trim();

        // Try to separate name from type (last word before colon)
        const words = beforeColon.split(/\s+/);
        if (words.length > 1) {
          recordType = words.pop();
          name = words.join(' ');
        } else {
          name = beforeColon;
          recordType = '';
        }

        const parenMatch = afterColon.match(/^(.+?)\s*\(previous:\s*(.+?),\s*([+-]?[\d.]+%)\)$/);
        if (parenMatch) {
          value = parenMatch[1].trim();
          previous = parenMatch[2].trim();
          improvement = parenMatch[3].trim();
        } else {
          value = afterColon;
        }
      }

      // Determine CSS type class
      const lowerType = recordType.toLowerCase();
      let typeClass = 'time'; // default
      if (lowerType === '1rm') typeClass = '1rm';
      else if (lowerType.includes('volume')) typeClass = 'volume';
      else if (lowerType.includes('reps')) typeClass = 'reps';
      else if (lowerType.includes('fastest') || lowerType.includes('time')) typeClass = 'time';
      else if (lowerType.includes('longest') || lowerType.includes('distance') || lowerType.includes('elevation')) typeClass = 'distance';

      return { emoji, name, recordType, value, previous, improvement, typeClass };
    }

    /**
     * Render Personal Records grouped by exercise.
     * Each exercise gets a single card with chips for each record type.
     */
    function renderPRSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const records = lines.map(parsePRLine).filter(Boolean);

      if (records.length === 0) {
        return `
          <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
            <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
            <pre class="activity-description">${escapeHtml(section.content)}</pre>
          </div>`;
      }

      // Group records by exercise name
      const grouped = {};
      const groupOrder = [];
      for (const pr of records) {
        if (!grouped[pr.name]) {
          grouped[pr.name] = { name: pr.name, emoji: pr.emoji, records: [] };
          groupOrder.push(pr.name);
        }
        grouped[pr.name].records.push(pr);
        // Prefer trophy emoji over muscle emoji for the group
        if (pr.emoji === 'üèÜ') grouped[pr.name].emoji = 'üèÜ';
      }

      // Separate distance PRs (empty name) from exercise PRs
      const distanceRecords = grouped[''] ? grouped[''].records : [];
      const exerciseGroups = groupOrder.filter(n => n !== '');

      // Render distance PRs as a flat grid of standalone cards
      let distanceHtml = '';
      if (distanceRecords.length > 0) {
        const distCards = distanceRecords.map((pr, i) => {
          const delay = (idx * 0.1) + (i * 0.04);
          let improvementHtml = '';
          if (pr.improvement) {
            const isTimeRecord = pr.typeClass === 'time';
            const startsWithMinus = pr.improvement.startsWith('-');
            const isPositive = isTimeRecord ? startsWithMinus : !startsWithMinus;
            const cls = isPositive ? 'positive' : 'negative';
            const arrow = isPositive ? '‚ñ≤' : '‚ñº';
            improvementHtml = `<span class="pr-distance-improvement ${cls}">${arrow} ${pr.improvement}</span>`;
          }
          // Extract the distance label from recordType (e.g. "Fastest 100m" -> "100m")
          const distLabel = pr.recordType.replace(/^Fastest\s+/i, '');
          return `<div class="pr-distance-card" style="animation-delay:${delay}s">
            <span class="pr-distance-value">${escapeHtml(pr.value)}</span>
            <span class="pr-distance-label">${escapeHtml(distLabel)}</span>
            ${improvementHtml}
          </div>`;
        }).join('');
        distanceHtml = `<div class="pr-distance-grid">${distCards}</div>`;
      }

      // Render exercise PRs as grouped cards with chips (existing logic)
      const cardsHtml = exerciseGroups.map((name, i) => {
        const group = grouped[name];
        const delay = (idx * 0.1) + ((distanceRecords.length > 0 ? 1 : 0) + i) * 0.06;

        const chipsHtml = group.records.map(pr => {
          let improvementHtml = '';
          if (pr.improvement) {
            // For time-based records (fastest X), negative improvement = faster = good
            const isTimeRecord = pr.typeClass === 'time';
            const startsWithMinus = pr.improvement.startsWith('-');
            const isPositive = isTimeRecord ? startsWithMinus : !startsWithMinus;
            const cls = isPositive ? 'positive' : 'negative';
            const arrow = isPositive ? '‚ñ≤' : '‚ñº';
            improvementHtml = `<span class="pr-record-improvement ${cls}">${arrow} ${pr.improvement}</span>`;
          }
          return `<div class="pr-record-chip chip-${pr.typeClass}">
            <span class="pr-record-value">${escapeHtml(pr.value)}</span>
            <span class="pr-record-type">${escapeHtml(pr.recordType || 'Record')}</span>
            ${improvementHtml}
          </div>`;
        }).join('');

        return `
          <div class="pr-grouped-card" style="animation-delay: ${delay}s;">
            <div class="pr-grouped-header">
              <span class="pr-emoji">${group.emoji}</span>
              <span class="pr-grouped-name">${escapeHtml(group.name)}</span>
            </div>
            <div class="pr-grouped-records">${chipsHtml}</div>
          </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header">
            <h2>${section.emoji} ${section.title}</h2>
          </div>
          ${distanceHtml}
          ${cardsHtml ? `<div class="pr-records-grid">${cardsHtml}</div>` : ''}
        </div>`;
    }

    /**
     * Render Muscle Heatmap with styled activation bars.
     * Parses lines like: "Abdominals: üü™üü™üü™üü™üü™"
     */
    function renderMuscleHeatmapSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());

      const muscles = lines.map(line => {
        const colonIdx = line.indexOf(':');
        if (colonIdx < 0) return null;
        const name = line.substring(0, colonIdx).trim();
        const squares = line.substring(colonIdx + 1).trim();
        // Count filled squares (üü™) out of total squares
        const filled = ([...squares].filter(c => c === 'üü™')).length;
        const total = ([...squares].filter(c => c === 'üü™' || c === '‚¨ú')).length || 5;
        return { name, filled, total };
      }).filter(Boolean);

      if (muscles.length === 0) return renderEnhancedCompactPills(section, idx);

      const barsHtml = muscles.map((m, i) => {
        const pct = (m.filled / m.total) * 100;
        const delay = (idx * 0.1) + (i * 0.04);
        return `<div class="muscle-bar-row" style="animation-delay:${delay}s">
          <span class="muscle-bar-label">${escapeHtml(m.name)}</span>
          <div class="muscle-bar-track">
            <div class="muscle-bar-fill" style="width:${pct}%"></div>
          </div>
          <span class="muscle-bar-level">${m.filled}/${m.total}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="muscle-heatmap-grid">${barsHtml}</div>
        </div>`;
    }


    /**
     * Render Intervals as structured timeline with grouped sprint cards.
     * Classifies each line by its emoji prefix:
     *   üî• = warmup, ‚ùÑÔ∏è = cooldown, üí® + √ó = group header,
     *   leading whitespace = sub-row, üìä/üìà/üìâ = insight
     */
    function renderIntervalsSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());

      // First pass: classify each line
      const classified = lines.map(line => {
        const trimmed = line.trim();
        const isIndented = line.startsWith('  ') || line.startsWith('\t');

        if (/^üî•/.test(trimmed)) return { type: 'warmup', text: trimmed };
        if (/^‚ùÑÔ∏è/.test(trimmed)) return { type: 'cooldown', text: trimmed };
        if (/^üìä/.test(trimmed)) return { type: 'insight-comparison', text: trimmed };
        if (/^üìà/.test(trimmed)) return { type: 'insight-trend', text: trimmed };
        if (/^üìâ/.test(trimmed)) return { type: 'insight-trend', text: trimmed };
        if (/^üí®/.test(trimmed) && /√ó/.test(trimmed) && /intervals/i.test(trimmed)) {
          return { type: 'group-header', text: trimmed };
        }
        if (isIndented || (/^üí®/.test(trimmed) && /Run \d/i.test(trimmed))) {
          return { type: 'sub-row', text: trimmed };
        }
        // Fallback: treat as a generic row
        return { type: 'generic', text: trimmed };
      });

      // Extract workout name: first generic line (e.g. "20min Sprints") becomes a subtitle
      let workoutSubtitle = '';
      if (classified.length > 0 && classified[0].type === 'generic') {
        workoutSubtitle = classified[0].text;
        classified.shift();
      }

      // Second pass: group consecutive group-header + sub-rows into cards
      let html = '';
      let cardIdx = 0;
      let i = 0;

      while (i < classified.length) {
        const item = classified[i];

        if (item.type === 'group-header') {
          // Start a group card: header + all following sub-rows
          const delay = (idx * 0.1) + (cardIdx * 0.08);
          const headerHtml = renderIntervalGroupHeader(item.text, delay);
          const subRows = [];
          let j = i + 1;
          while (j < classified.length && classified[j].type === 'sub-row') {
            subRows.push(classified[j].text);
            j++;
          }

          const subRowsHtml = subRows.map((text, si) => {
            const subDelay = delay + ((si + 1) * 0.04);
            return renderIntervalSubRow(text, subDelay);
          }).join('');

          html += `<div class="interval-group-card" style="animation-delay:${delay}s">
            ${headerHtml}
            ${subRows.length > 0 ? `<div class="interval-sub-rows">${subRowsHtml}</div>` : ''}
          </div>`;
          cardIdx++;
          i = j;
          continue;
        }

        if (item.type === 'warmup' || item.type === 'cooldown') {
          html += renderIntervalStandaloneRow(item.text, item.type, (idx * 0.1) + (cardIdx * 0.08));
          cardIdx++;
          i++;
          continue;
        }

        if (item.type === 'insight-comparison') {
          html += renderIntervalComparisonCard(item.text, (idx * 0.1) + (cardIdx * 0.08));
          cardIdx++;
          i++;
          continue;
        }

        if (item.type === 'insight-trend') {
          html += renderIntervalTrendCard(item.text, (idx * 0.1) + (cardIdx * 0.08));
          cardIdx++;
          i++;
          continue;
        }

        // Generic fallback row
        html += renderIntervalGenericRow(item.text, (idx * 0.1) + (cardIdx * 0.08));
        cardIdx++;
        i++;
      }

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}${workoutSubtitle ? `<span class="intervals-subtitle">‚Äî ${escapeHtml(workoutSubtitle)}</span>` : ''}</h2></div>
          <div class="intervals-timeline">${html}</div>
        </div>`;
    }

    /**
     * Render a warmup or cooldown as a standalone row.
     * Input: "üî• Warmup: 5:00 ‚Ä¢ 5:47/km ‚Ä¢ 862m (124bpm)"
     * Renders: emoji + clean label + stat pills (no duplication)
     */
    function renderIntervalStandaloneRow(text, type, delay) {
      const emojiResult = extractLeadingEmoji(text);
      const rest = emojiResult.rest.trim();

      // Split on colon to get label and stats part
      const colonIdx = rest.indexOf(':');
      let label = type === 'warmup' ? 'Warmup' : 'Cooldown';
      let statsText = rest;
      if (colonIdx > 0) {
        label = rest.substring(0, colonIdx).trim();
        statsText = rest.substring(colonIdx + 1).trim();
      }

      // Parse stats from ‚Ä¢ separated values
      const statsHtml = parseIntervalStatPills(statsText);

      return `<div class="interval-row ${type}" style="animation-delay:${delay}s">
        <span class="interval-emoji">${emojiResult.emoji}</span>
        <span class="interval-label">${escapeHtml(label)}</span>
        ${statsHtml}
      </div>`;
    }

    /**
     * Render a group header (goes inside .interval-group-card).
     * Input: "üí® 3√ó0:40 sprints: avg 3:43/km, peak 170bpm"
     * Renders: emoji + bold label + muted stat badges
     */
    function renderIntervalGroupHeader(text, delay) {
      const emojiResult = extractLeadingEmoji(text);
      const rest = emojiResult.rest.trim();

      // Split at "sprints:" to get the group label vs stats
      const sprintsIdx = rest.search(/sprints?:/i);
      let label, statsText;
      if (sprintsIdx >= 0) {
        const colonAfterSprints = rest.indexOf(':', sprintsIdx);
        label = rest.substring(0, colonAfterSprints + 1).trim();
        statsText = rest.substring(colonAfterSprints + 1).trim();
      } else {
        // Fallback: split at first colon
        const colonIdx = rest.indexOf(':');
        if (colonIdx > 0) {
          label = rest.substring(0, colonIdx).trim();
          statsText = rest.substring(colonIdx + 1).trim();
        } else {
          label = rest;
          statsText = '';
        }
      }

      const statsHtml = statsText ? parseIntervalStatPills(statsText) : '';

      return `<div class="interval-group-header">
        <span class="interval-emoji">${emojiResult.emoji}</span>
        <span class="interval-label">${escapeHtml(label)}</span>
        ${statsHtml}
      </div>`;
    }

    /**
     * Render a sub-row (individual run inside a group card).
     * Input: "üí® Run 1: 0:40 ‚Ä¢ 3:27/km ‚Ä¢ 193m (149bpm)"
     * Renders: clean label (Run 1) + stat pills
     */
    function renderIntervalSubRow(text, delay) {
      const emojiResult = extractLeadingEmoji(text);
      const rest = emojiResult.rest.trim();

      // Label is "Run N", stats are after the colon
      const colonIdx = rest.indexOf(':');
      let label = rest;
      let statsText = '';
      if (colonIdx > 0 && colonIdx < 20) {
        label = rest.substring(0, colonIdx).trim();
        statsText = rest.substring(colonIdx + 1).trim();
      }

      const statsHtml = statsText ? parseIntervalStatPills(statsText) : '';

      return `<div class="interval-sub-row" style="animation-delay:${delay}s">
        <span class="interval-label">${escapeHtml(label)}</span>
        ${statsHtml}
      </div>`;
    }

    /**
     * Render Active vs Recovery comparison card.
     * Input: "üìä Active vs Recovery: 4.42 m/s vs 2.23 m/s (1.98√ó ratio)"
     * Renders: structured comparison with labeled values and ratio badge
     */
    function renderIntervalComparisonCard(text, delay) {
      const emojiResult = extractLeadingEmoji(text);
      const rest = emojiResult.rest.trim();

      const colonIdx = rest.indexOf(':');
      let label = rest;
      let metricsText = '';
      if (colonIdx > 0) {
        label = rest.substring(0, colonIdx).trim();
        metricsText = rest.substring(colonIdx + 1).trim();
      }

      // Try to parse "X m/s vs Y m/s (Z√ó ratio)" format
      const vsMatch = metricsText.match(/([\d.]+)\s*(\S+)\s+vs\s+([\d.]+)\s*(\S+)\s*\(([\d.]+)√ó\s*ratio\)/);

      if (vsMatch) {
        const [, activeVal, activeUnit, recoveryVal, recoveryUnit, ratio] = vsMatch;
        return `<div class="interval-insight-card" style="animation-delay:${delay}s">
          <div class="insight-card-header">
            <span class="interval-emoji">${emojiResult.emoji}</span>
            <span>${escapeHtml(label)}</span>
          </div>
          <div class="insight-comparison">
            <div class="insight-comparison-value active">
              <span class="value">${escapeHtml(activeVal)} ${escapeHtml(activeUnit)}</span>
              <span class="label">Active</span>
            </div>
            <span class="insight-vs-divider">vs</span>
            <div class="insight-comparison-value recovery">
              <span class="value">${escapeHtml(recoveryVal)} ${escapeHtml(recoveryUnit)}</span>
              <span class="label">Recovery</span>
            </div>
            <span class="insight-ratio-badge">${escapeHtml(ratio)}√ó ratio</span>
          </div>
        </div>`;
      }

      // Fallback: render as generic insight with pills
      return renderIntervalInsightFallback(emojiResult.emoji, label, metricsText, delay);
    }

    /**
     * Render Getting faster/slower trend card.
     * Input: "üìà Getting faster: 3:43 ‚Üí 3:26/km (-7%)"
     * Renders: pace values with arrow, percentage badge, and mini bar chart
     */
    function renderIntervalTrendCard(text, delay) {
      const emojiResult = extractLeadingEmoji(text);
      const rest = emojiResult.rest.trim();

      const colonIdx = rest.indexOf(':');
      let label = rest;
      let metricsText = '';
      if (colonIdx > 0) {
        label = rest.substring(0, colonIdx).trim();
        metricsText = rest.substring(colonIdx + 1).trim();
      }

      // Parse "3:43 ‚Üí 3:26/km (-7%)" format
      const trendMatch = metricsText.match(/([\d:]+)\s*‚Üí\s*([\d:]+)\s*(\/\w+)?\s*\(([+-]?[\d.]+)%\)/);
      const isFaster = /faster/i.test(label);
      const trendClass = isFaster ? 'faster' : 'slower';

      if (trendMatch) {
        const [, fromPace, toPace, unit, pctStr] = trendMatch;
        const pct = parseFloat(pctStr);
        const displayUnit = unit || '';

        // Convert paces to seconds for bar chart proportions
        const paceToSecs = (p) => {
          const parts = p.split(':');
          return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
        };
        const fromSecs = paceToSecs(fromPace);
        const toSecs = paceToSecs(toPace);
        const maxSecs = Math.max(fromSecs, toSecs);
        const fromPct = maxSecs > 0 ? (fromSecs / maxSecs) * 100 : 50;
        const toPct = maxSecs > 0 ? (toSecs / maxSecs) * 100 : 50;

        const arrowIcon = isFaster ? '‚Üó' : '‚Üò';

        return `<div class="interval-insight-card" style="animation-delay:${delay}s">
          <div class="insight-card-header">
            <span class="interval-emoji">${emojiResult.emoji}</span>
            <span>${escapeHtml(label)}</span>
          </div>
          <div class="insight-trend">
            <div class="insight-trend-chart">
              <div class="insight-trend-bar ${isFaster ? 'slower' : 'neutral'}" style="height:${fromPct}%">
                <span class="bar-label">${escapeHtml(fromPace)}</span>
              </div>
              <div class="insight-trend-bar ${trendClass}" style="height:${toPct}%">
                <span class="bar-label">${escapeHtml(toPace)}</span>
              </div>
            </div>
            <div class="insight-trend-arrow">
              <span class="arrow ${trendClass}">${arrowIcon}</span>
            </div>
            <span class="insight-trend-pct ${trendClass}">${pct > 0 ? '+' : ''}${pct}%</span>
            <div class="insight-trend-values">
              <span class="from">${escapeHtml(fromPace)}</span>
              <span class="arrow-text">‚Üí</span>
              <span class="to">${escapeHtml(toPace)}${escapeHtml(displayUnit)}</span>
            </div>
          </div>
        </div>`;
      }

      // Fallback: render as generic insight with pills
      return renderIntervalInsightFallback(emojiResult.emoji, label, metricsText, delay);
    }

    /**
     * Fallback insight renderer for unrecognized formats.
     */
    function renderIntervalInsightFallback(emoji, label, metricsText, delay) {
      let metricsHtml = '';
      if (metricsText) {
        const parts = metricsText.split('‚Ä¢').map(p => p.trim()).filter(Boolean);
        metricsHtml = `<div class="interval-insight-metrics">
          ${parts.map(p => `<span class="interval-insight-metric">${escapeHtml(p)}</span>`).join('')}
        </div>`;
      }

      return `<div class="interval-row insight" style="animation-delay:${delay}s">
        <span class="interval-emoji">${emoji}</span>
        <span class="interval-label">${escapeHtml(label)}</span>
        ${metricsHtml}
      </div>`;
    }

    /**
     * Render a generic interval row (fallback).
     */
    function renderIntervalGenericRow(text, delay) {
      const emojiResult = extractLeadingEmoji(text);
      const rest = emojiResult.rest.trim();

      return `<div class="interval-row" style="animation-delay:${delay}s">
        <span class="interval-emoji">${emojiResult.emoji}</span>
        <span class="interval-label">${escapeHtml(rest)}</span>
      </div>`;
    }

    /**
     * Parse stats from a ‚Ä¢ separated or comma-separated string into pill HTML.
     * Handles patterns like "5:00 ‚Ä¢ 5:47/km ‚Ä¢ 862m (124bpm)" and "avg 3:43/km, peak 170bpm"
     */
    function parseIntervalStatPills(text) {
      // Split on ‚Ä¢ first, then try comma for "avg X, peak Y" style
      let parts = text.split('‚Ä¢').map(p => p.trim()).filter(Boolean);
      if (parts.length <= 1 && text.includes(',')) {
        parts = text.split(',').map(p => p.trim()).filter(Boolean);
      }

      const pills = parts.map(part => {
        // Classify the stat for coloring
        let cls = '';
        if (/\/km/.test(part)) cls = 'pace';
        else if (/bpm/i.test(part)) cls = 'hr';
        else if (/\d+\s*m\b/.test(part) || /\d+\.\d+\s*km/.test(part)) cls = 'dist';
        else if (/^\d+:\d{2}$/.test(part.trim())) cls = 'time';

        // Clean up: strip parentheses around HR values like "(124bpm)"
        let display = part.replace(/^\(/, '').replace(/\)$/, '').trim();

        return `<span class="interval-stat ${cls}">${escapeHtml(display)}</span>`;
      }).join('');

      return pills ? `<div class="interval-stats">${pills}</div>` : '';
    }

    /**
     * Render HR Zones as coloured progress bars.
     */
    function renderHRZonesSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      // Find max duration for scaling bars
      const zones = lines.map(l => parseHRZoneLine(l.trim())).filter(Boolean);
      const maxMin = Math.max(...zones.map(z => z.minutes), 1);

      const rowsHtml = zones.map((z, i) => {
        const pct = Math.max((z.minutes / maxMin) * 100, 2);
        const delay = (idx * 0.1) + (i * 0.05);
        return `<div class="hr-zone-row" style="animation-delay:${delay}s">
          <span class="hr-zone-label">${escapeHtml(z.label)}</span>
          <div class="hr-zone-bar">
            <div class="hr-zone-fill zone-${z.zone}" style="width:${pct}%"></div>
          </div>
          <span class="hr-zone-duration">${z.minutes} min</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="hr-zones-list">${rowsHtml}</div>
        </div>`;
    }

    function parseHRZoneLine(line) {
      // "Zone 4 (Threshold): üüßüüßüüßüüß‚¨ú 9 min"
      const match = line.match(/^Zone\s+(\d)\s*\(([^)]+)\).*?(\d+)\s*min/i);
      if (!match) return null;
      return {
        zone: parseInt(match[1]),
        label: `Z${match[1]} ${match[2]}`,
        minutes: parseInt(match[3])
      };
    }

    /**
     * Render Goal Progress with a real progress bar.
     */
    function renderGoalSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let percentage = 0;
      let progressText = '';
      const detailRows = [];

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // Parse progress bar line: [‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 24% 3.5/15 km
        const barMatch = trimmed.match(/\[.*?\]\s*(\d+)%\s*(.+)/);
        if (barMatch) {
          percentage = parseInt(barMatch[1]);
          progressText = barMatch[2];
          continue;
        }
        // Percentage without bar
        const pctMatch = trimmed.match(/(\d+)%/);
        if (pctMatch && !percentage) percentage = parseInt(pctMatch[1]);
        // Collect detail lines
        const emoji = [...trimmed][0] || '‚Ä¢';
        const rest = trimmed.slice(emoji.length).trim();
        detailRows.push({ emoji, text: rest || trimmed });
      }

      const detailsHtml = detailRows.map(d =>
        `<div class="progress-detail-row"><span class="detail-emoji">${d.emoji}</span>${escapeHtml(d.text)}</div>`
      ).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="progress-section-body">
            <div class="progress-bar-container">
              <div class="progress-bar-fill" style="width:${Math.min(percentage, 100)}%">
                ${percentage >= 50 ? `<span class="progress-bar-label">${percentage}%${progressText ? ' ‚Äî ' + escapeHtml(progressText) : ''}</span>` : ''}
              </div>
              ${percentage < 50 ? `<span class="progress-bar-label outside" style="left:${Math.min(percentage, 100)}%;margin-left:8px">${percentage}%${progressText ? ' ‚Äî ' + escapeHtml(progressText) : ''}</span>` : ''}
            </div>
            <div class="progress-details">${detailsHtml}</div>
          </div>
        </div>`;
    }

    /**
     * Render Streak Tracker with a prominent streak number.
     */
    function renderStreakSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let streakNumber = null;
      const badges = [];
      const details = [];

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // Extract streak number: "üèÜüî• 81-day activity streak!"
        const streakMatch = trimmed.match(/(\d+)[- ]day/i);
        if (streakMatch && streakNumber === null) {
          streakNumber = parseInt(streakMatch[1]);
        }
        // Detect achievement badges
        if (/personal best|new.*record/i.test(trimmed)) {
          badges.push(trimmed);
        } else {
          details.push(trimmed);
        }
      }

      const badgesHtml = badges.map(b =>
        `<span class="streak-badge">üèÜ ${escapeHtml(b)}</span>`
      ).join('');

      const detailsHtml = details.filter(d => !/\d+[- ]day/i.test(d) || !streakNumber).map(d => {
        const emoji = [...d][0] || '‚Ä¢';
        const rest = d.slice(emoji.length).trim();
        return `<div class="progress-detail-row"><span class="detail-emoji">${emoji}</span>${escapeHtml(rest || d)}</div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="progress-section-body">
            ${streakNumber !== null ? `<div><span class="streak-number">${streakNumber}</span> <span class="streak-label">day streak üî•</span></div>` : ''}
            ${badgesHtml}
            ${detailsHtml ? `<div class="progress-details">${detailsHtml}</div>` : ''}
          </div>
        </div>`;
    }

    /**
     * Render Lifetime Milestone with progress bar toward next milestone.
     */
    function renderMilestoneSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());

      // Detect milestone-reached mode: content contains "MILESTONE: Xkm reached!"
      const milestoneReachedLine = lines.find(l => /MILESTONE:.*reached/i.test(l));

      if (milestoneReachedLine) {
        // === CELEBRATION MODE ===
        const milestoneMatch = milestoneReachedLine.match(/MILESTONE:\s*([\d,.]+)\s*(km|mi|m)/i);
        const milestoneVal = milestoneMatch ? milestoneMatch[1].replace(',', '') : '?';
        const milestoneUnit = milestoneMatch ? milestoneMatch[2] : 'km';

        // Parse detail bullets
        const detailLines = lines.filter(l => l.trim().startsWith('‚Ä¢'));
        const detailsHtml = detailLines.map(line => {
          const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
          const emojiResult = extractLeadingEmoji(trimmed);
          const emoji = emojiResult.emoji || '‚ú®';
          const rest = emojiResult.rest.trim();
          return `<div class="progress-detail-row"><span class="detail-emoji">${emoji}</span>${escapeHtml(rest || trimmed)}</div>`;
        }).join('');

        return `
          <div class="showcase-section glass-card description-section-card milestone-celebration" style="animation-delay: ${idx * 0.1}s;">
            <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
            <div class="milestone-banner">
              <div class="milestone-confetti">üéâ</div>
              <div class="milestone-value">${escapeHtml(milestoneVal)} ${escapeHtml(milestoneUnit)}</div>
              <div class="milestone-label">Milestone Reached!</div>
              <div class="milestone-confetti">üéâ</div>
            </div>
            <div class="progress-bar-container">
              <div class="progress-bar-fill milestone celebration" style="width:100%">
                <span class="progress-bar-label">${escapeHtml(milestoneVal)} ${escapeHtml(milestoneUnit)} ‚úì</span>
              </div>
            </div>
            <div class="progress-details">${detailsHtml}</div>
          </div>`;
      }

      // === PROGRESS MODE (unchanged) ===
      let total = null;
      let milestone = null;
      let remaining = null;
      const details = [];

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // "475.4 km total"
        const totalMatch = trimmed.match(/([\d,.]+)\s*(km|mi|m)\s*total/i);
        if (totalMatch) total = { value: parseFloat(totalMatch[1].replace(',', '')), unit: totalMatch[2] };
        // "Next milestone: 500 km (24.6 km to go)"
        const mileMatch = trimmed.match(/milestone.*?([\d,.]+)\s*(km|mi|m)/i);
        if (mileMatch) milestone = { value: parseFloat(mileMatch[1].replace(',', '')), unit: mileMatch[2] };
        const remainMatch = trimmed.match(/([\d,.]+)\s*(km|mi|m)\s*to go/i);
        if (remainMatch) remaining = parseFloat(remainMatch[1].replace(',', ''));
        const emojiResult = extractLeadingEmoji(trimmed);
        const emoji = emojiResult.emoji || 'üìä';
        const rest = emojiResult.rest.trim();
        details.push({ emoji, text: rest || trimmed });
      }

      let progressHtml = '';
      if (total && milestone) {
        const pct = Math.min((total.value / milestone.value) * 100, 100);
        progressHtml = `
          <div class="progress-bar-container">
            <div class="progress-bar-fill milestone" style="width:${pct}%">
              ${pct >= 50 ? `<span class="progress-bar-label">${total.value} / ${milestone.value} ${total.unit}</span>` : ''}
            </div>
            ${pct < 50 ? `<span class="progress-bar-label outside" style="left:${pct}%;margin-left:8px">${total.value} / ${milestone.value} ${total.unit}</span>` : ''}
          </div>`;
      }

      const detailsHtml = details.map(d =>
        `<div class="progress-detail-row"><span class="detail-emoji">${d.emoji}</span>${escapeHtml(d.text)}</div>`
      ).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="progress-section-body">
            ${progressHtml}
            <div class="progress-details">${detailsHtml}</div>
          </div>
        </div>`;
    }

    /**
     * Render bullet-list sections as structured stat rows.
     */
    function renderBulletListSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const rowsHtml = lines.map((line, i) => {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        const delay = (idx * 0.1) + (i * 0.04);

        // Extract leading emoji properly (handles multi-codepoint emoji)
        const emojiResult = extractLeadingEmoji(trimmed);
        const emoji = emojiResult.emoji;
        let rest = emojiResult.rest.trim();

        // Handle progress bar lines (keep as-is but styled)
        if (rest.includes('[') && rest.includes(']')) {
          return `<div class="stat-row" style="animation-delay:${delay}s">
            <span class="stat-row-emoji">${emoji}</span>
            <span class="stat-row-value" style="flex:1">${escapeHtml(rest)}</span>
          </div>`;
        }

        const colonIdx = rest.indexOf(':');
        if (colonIdx > 0 && colonIdx < rest.length - 1) {
          const label = rest.substring(0, colonIdx).trim();
          const value = rest.substring(colonIdx + 1).trim();
          return `<div class="stat-row" style="animation-delay:${delay}s">
            <span class="stat-row-emoji">${emoji}</span>
            <span class="stat-row-label">${escapeHtml(label)}</span>
            <span class="stat-row-value">${escapeHtml(value)}</span>
          </div>`;
        }

        return `<div class="stat-row" style="animation-delay:${delay}s">
          <span class="stat-row-emoji">${emoji}</span>
          <span class="stat-row-label">${escapeHtml(rest)}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="stat-rows">${rowsHtml}</div>
        </div>`;
    }

    /**
     * Render single-line sections with ‚Ä¢ separators as stat pills.
     */
    function renderCompactStatPills(section, idx) {
      const parts = section.content.split(' ‚Ä¢ ').map(p => p.trim()).filter(Boolean);
      const pillsHtml = parts.map(part => {
        // Try to split "label value" or just display as value
        // Common patterns: "295W avg", "557W max", "5:26/km avg"
        const labelMatch = part.match(/^(.+?)\s+(avg|max|min|best|total|gain|loss)$/i);
        if (labelMatch) {
          return `<span class="stat-pill"><span class="stat-pill-value">${escapeHtml(labelMatch[1])}</span> <span class="stat-pill-label">${escapeHtml(labelMatch[2])}</span></span>`;
        }
        return `<span class="stat-pill"><span class="stat-pill-value">${escapeHtml(part)}</span></span>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="compact-stat-pills">${pillsHtml}</div>
        </div>`;
    }

    /**
     * Render Parkrun Results with stat rows and PB trophy badges.
     */
    function renderParkrunSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const rowsHtml = lines.map((line, i) => {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        const delay = (idx * 0.1) + (i * 0.05);

        // Split on ' ¬∑ ' to separate value from badges
        const parts = trimmed.split(' ¬∑ ');
        const mainPart = parts[0] || '';
        const badgeParts = parts.slice(1);

        // Parse label: value
        let label = '';
        let value = mainPart;
        const colonIdx = mainPart.indexOf(':');
        if (colonIdx > 0) {
          label = mainPart.substring(0, colonIdx).trim();
          value = mainPart.substring(colonIdx + 1).trim();
        }

        // Render badges
        const badgesHtml = badgeParts.map(b => {
          const bt = b.trim();
          let cls = '';
          if (/all-time/i.test(bt)) cls = 'all-time';
          else if (/this-year/i.test(bt)) cls = 'this-year';
          else if (/first time/i.test(bt)) cls = 'first-visit';
          else cls = 'all-time';
          return `<span class="parkrun-badge ${cls}">${escapeHtml(bt)}</span>`;
        }).join('');

        return `<div class="parkrun-stat-row" style="animation-delay:${delay}s">
          <span class="parkrun-stat-label">${escapeHtml(label)}</span>
          <span class="parkrun-stat-value">${escapeHtml(value)}</span>
          ${badgesHtml ? `<div class="parkrun-badges">${badgesHtml}</div>` : ''}
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="parkrun-results">${rowsHtml}</div>
        </div>`;
    }

    /**
     * Render Effort Score with a circular gauge and factor breakdown.
     */
    function renderEffortScoreSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let score = 0;
      let label = 'Moderate';
      const factors = [];
      let verdict = '';

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // Parse score line: "78/100 (Hard)"
        const scoreMatch = trimmed.match(/(\d+)\/100\s*\(([^)]+)\)/);
        if (scoreMatch) {
          score = parseInt(scoreMatch[1]);
          label = scoreMatch[2];
          continue;
        }
        // Parse factor line: "üèÉ Pace: 1.23√ó avg"
        const factorMatch = trimmed.match(/^(.+?)\s+(.+?):\s+(.+)$/);
        if (factorMatch && factorMatch[1].length <= 4) {
          factors.push({ emoji: factorMatch[1], name: factorMatch[2], value: factorMatch[3] });
          continue;
        }
        // Verdict line: "üìà Harder than usual" / "üìâ Easier than usual"
        if (/harder|easier|typical/i.test(trimmed)) {
          verdict = trimmed;
        }
      }

      // Gauge SVG
      const circumference = 2 * Math.PI * 34;
      const dashoffset = circumference * (1 - score / 100);
      const labelClass = label.toLowerCase().replace(/\s+/g, '-');
      const strokeColor = getEffortColor(label);

      const gaugeHtml = `
        <div class="effort-gauge">
          <div class="effort-gauge-ring">
            <svg viewBox="0 0 80 80">
              <circle class="gauge-bg" cx="40" cy="40" r="34"/>
              <circle class="gauge-fill" cx="40" cy="40" r="34"
                stroke="${strokeColor}"
                stroke-dasharray="${circumference}"
                stroke-dashoffset="${dashoffset}"/>
            </svg>
            <span class="effort-gauge-value">${score}</span>
          </div>
          <div class="effort-gauge-info">
            <span class="effort-label ${labelClass}">${escapeHtml(label)}</span>
            ${verdict ? `<span class="effort-verdict">${escapeHtml(verdict)}</span>` : ''}
          </div>
        </div>`;

      const factorsHtml = factors.map((f, i) => {
        const delay = (idx * 0.1) + ((i + 1) * 0.05);
        return `<div class="effort-factor" style="animation-delay:${delay}s">
          <span class="effort-factor-emoji">${f.emoji}</span>
          <span class="effort-factor-name">${escapeHtml(f.name)}</span>
          <span class="effort-factor-value">${escapeHtml(f.value)}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="effort-score-body">
            ${gaugeHtml}
            ${factorsHtml ? `<div class="effort-factors">${factorsHtml}</div>` : ''}
          </div>
        </div>`;
    }

    function getEffortColor(label) {
      const l = label.toLowerCase();
      if (l === 'easy') return '#4ADE80';
      if (l === 'moderate') return '#FBBF24';
      if (l === 'hard') return '#FB923C';
      if (l.includes('very')) return '#EF4444';
      if (l === 'max') return '#DC2626';
      return '#FBBF24';
    }

    /**
     * Render Workout Summary with headline stats + categorised exercise cards.
     */
    function renderWorkoutSummarySection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let headlineStats = [];
      let heaviestLine = '';
      const exercises = [];

      const stretchNames = ['stretch', 'pigeon', 'yoga', 'foam roll', 'shoulder blade',
        'cool down', 'cooldown', 'warm up', 'hip opener', 'child\'s pose'];

      for (const line of lines) {
        const trimmed = line.trim();
        // Headline stats line: "12 sets ‚Ä¢ 5,000kg volume ‚Ä¢ 48 reps"
        if (!trimmed.startsWith('‚Ä¢') && trimmed.includes(' ‚Ä¢ ')) {
          headlineStats = trimmed.split(' ‚Ä¢ ').map(s => s.trim()).filter(Boolean);
          continue;
        }
        // Heaviest line: "Heaviest: 10kg (Tall Kneeling Curls)"
        if (trimmed.startsWith('Heaviest:') || trimmed.startsWith('‚Ä¢ Heaviest:')) {
          heaviestLine = trimmed.replace(/^‚Ä¢\s*/, '');
          continue;
        }
        // Exercise line: "‚Ä¢ Bench Press: 3 √ó 100.0kg"
        if (trimmed.startsWith('‚Ä¢')) {
          const content = trimmed.slice(1).trim();
          let superset = '';
          let exerciseContent = content;
          const supersetMatch = content.match(/^([1-9]Ô∏è‚É£|üîü|‚¨ú)\s*(.+)$/);
          if (supersetMatch) {
            superset = supersetMatch[1];
            exerciseContent = supersetMatch[2];
          }
          const colonIdx = exerciseContent.indexOf(':');
          if (colonIdx > 0) {
            const name = exerciseContent.substring(0, colonIdx).trim();
            const sets = exerciseContent.substring(colonIdx + 1).trim();
            exercises.push({ superset, name, sets });
          } else {
            exercises.push({ superset, name: exerciseContent, sets: '' });
          }
        }
      }

      // Categorise exercises
      function categorise(ex) {
        const lower = ex.name.toLowerCase();
        const sets = ex.sets.toLowerCase();
        // Check for stretches/warm-up by name first
        if (stretchNames.some(s => lower.includes(s))) return 'stretch';
        // Weighted: has √ókg or xkg
        if (/√ó\s*[\d.]+\s*kg/i.test(sets) || /x\s*[\d.]+\s*kg/i.test(sets)) return 'weighted';
        // Timed: has m:ss pattern like 0:47 or 2:00
        if (/^\d+:\d{2}/.test(sets) || /\d+:\d{2}/.test(ex.sets)) return 'timed';
        // Bodyweight reps
        if (/\d+\s*reps/i.test(sets) || /^\d+$/.test(sets.trim())) return 'bodyweight';
        return 'bodyweight';
      }

      const catIcons = {
        weighted: 'üèãÔ∏è',
        bodyweight: 'üí™',
        timed: '‚è±Ô∏è',
        stretch: 'üßò'
      };

      const statsHtml = headlineStats.map(s =>
        `<span class="stat-pill"><span class="stat-pill-value">${escapeHtml(s)}</span></span>`
      ).join('');

      const heaviestHtml = heaviestLine
        ? `<div class="workout-headline-callout">üèÖ ${escapeHtml(heaviestLine)}</div>`
        : '';

      const exercisesHtml = exercises.map((ex, i) => {
        const cat = categorise(ex);
        const icon = catIcons[cat];
        const delay = (idx * 0.1) + (i * 0.04);
        // Split comma-separated sets into individual sub-rows
        const setItems = ex.sets ? ex.sets.split(',').map(s => s.trim()).filter(Boolean) : [];
        const setRowsHtml = setItems.map((s, si) => {
          const setDelay = delay + ((si + 1) * 0.03);
          return `<div class="workout-ex-set-row" style="animation-delay:${setDelay}s">${escapeHtml(s)}</div>`;
        }).join('');
        return `<div class="workout-exercise-card cat-${cat}" style="animation-delay:${delay}s">
          <div class="workout-ex-header">
            <span class="workout-ex-icon">${icon}</span>
            <span class="workout-ex-name">${escapeHtml(ex.name)}</span>
          </div>
          ${setRowsHtml ? `<div class="workout-ex-set-rows">${setRowsHtml}</div>` : ''}
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="workout-summary-body">
            ${statsHtml ? `<div class="workout-headline-stats">${statsHtml}</div>` : ''}
            ${heaviestHtml}
            ${exercisesHtml ? `<div class="workout-exercises">${exercisesHtml}</div>` : ''}
          </div>
        </div>`;
    }


    /**
     * Render AI Summary as pretty prose inside a magical shimmer card.
     */
    function renderAISummarySection(section, idx) {
      return `
        <div class="showcase-section glass-card description-section-card ai-summary-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header ai-summary-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="ai-summary-prose">${escapeHtml(section.content)}</div>
        </div>`;
    }

    /**
     * Extract leading emoji from a string, handling multi-codepoint emoji
     * (variation selectors, ZWJ sequences, keycaps, flags).
     * Returns { emoji, rest } where rest is the remaining text.
     */
    function extractLeadingEmoji(text) {
      if (!text) return { emoji: 'üìù', rest: '' };
      // Skip if first char is basic ASCII (digits, letters, punctuation) ‚Äî not an emoji
      const firstChar = text.charCodeAt(0);
      if (firstChar < 0x200) {
        return { emoji: '‚Ä¢', rest: text };
      }
      // Match leading emoji: extended pictographic + optional modifiers/ZWJ sequences
      const emojiMatch = text.match(/^(\p{Emoji_Presentation}|\p{Emoji}\uFE0F)(\u200D(\p{Emoji_Presentation}|\p{Emoji}\uFE0F))*/u);
      if (emojiMatch) {
        return { emoji: emojiMatch[0], rest: text.slice(emojiMatch[0].length) };
      }
      // No emoji found ‚Äî return bullet as emoji and full text as rest
      return { emoji: '‚Ä¢', rest: text };
    }

    /**
     * Escape HTML to prevent XSS when inserting user content.
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // --- CHART MODAL ---

    function openChartModal(chartKey, title) {
      const modal = document.getElementById('chart-modal');
      const titleEl = document.getElementById('chart-modal-title');
      const canvas = document.getElementById('chart-modal-canvas');

      if (!chartConfigs[chartKey]) {
        console.warn('No chart config found for:', chartKey);
        return;
      }

      // Set title
      titleEl.textContent = title;

      // Destroy existing modal chart if any
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }

      // Show modal first so canvas has dimensions
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      document.documentElement.style.overflow = 'hidden';

      // Deep clone config to avoid mutating original
      const ctx = canvas.getContext('2d');
      const config = chartConfigs[chartKey];
      const modalConfig = deepCloneConfig(config);

      // Scale up annotation fonts for fullscreen readability
      if (modalConfig.options?.plugins?.annotation?.annotations) {
        Object.values(modalConfig.options.plugins.annotation.annotations).forEach(ann => {
          if (ann.label?.font) {
            ann.label.font.size = 14;
          }
        });
      }

      // Wait a frame for modal dimensions to settle
      requestAnimationFrame(() => {
        modalChart = new Chart(ctx, modalConfig);
      });

      // Close on ESC key
      document.addEventListener('keydown', handleModalEscape);
    }

    // Deep clone chart config, preserving functions
    function deepCloneConfig(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (typeof obj === 'function') return obj;
      if (Array.isArray(obj)) return obj.map(deepCloneConfig);
      const cloned = {};
      for (const key in obj) {
        cloned[key] = deepCloneConfig(obj[key]);
      }
      return cloned;
    }

    function closeChartModal() {
      const modal = document.getElementById('chart-modal');
      modal.style.display = 'none';
      document.body.style.overflow = '';
      document.documentElement.style.overflow = '';

      // Destroy modal chart
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }

      document.removeEventListener('keydown', handleModalEscape);
    }

    function handleModalEscape(e) {
      if (e.key === 'Escape') {
        closeChartModal();
      }
    }

    // Close modal when clicking backdrop
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('chart-modal-backdrop')) {
        closeChartModal();
      }
    });

    // Expose modal functions globally for onclick handlers
    window.openChartModal = openChartModal;
    window.closeChartModal = closeChartModal;

    // --- HELPERS ---

    // Check if URL points to an SVG asset
    function isSvgUrl(url) {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname.toLowerCase();
        return pathname.endsWith('.svg') || pathname.includes('.svg');
      } catch {
        return url.toLowerCase().includes('.svg');
      }
    }

    // Render asset as inline SVG or img based on file type
    function renderAsset(url, alt, className, container) {
      if (isSvgUrl(url)) {
        // Fetch and render SVG inline
        fetch(url)
          .then(res => {
            if (!res.ok) throw new Error('Failed to fetch SVG');
            return res.text();
          })
          .then(text => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'image/svg+xml');
            const svgElement = doc.querySelector('svg');
            if (svgElement) {
              svgElement.removeAttribute('width');
              svgElement.removeAttribute('height');
              svgElement.setAttribute('aria-label', alt);
              svgElement.setAttribute('role', 'img');
              if (className) {
                svgElement.classList.add(...className.split(' '));
              }
              container.innerHTML = svgElement.outerHTML;
            } else {
              // Fallback to img on parse failure
              container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
            }
          })
          .catch(() => {
            // Fallback to img on fetch failure
            container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
          });
      } else {
        // Non-SVG: use img tag
        container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
      }
    }

    function formatActivityType(type) {
      const types = {
        0: 'Workout', 5: 'CrossFit', 12: 'HIIT', 13: 'Hike', 23: 'Ride', 27: 'Run', 37: 'Swim',
        40: 'Trail Run', 45: 'Walk', 46: 'Weight Training', 49: 'Workout', 50: 'Yoga'
      };
      return types[type] || 'Activity';
    }

    function formatSource(source) {
      const sources = { 0: 'Unknown', 1: 'Hevy', 3: 'Fitbit', 4: 'Parkrun', 5: 'FIT Upload', 99: 'Test' };
      return sources[source] || 'Unknown';
    }

    function formatDuration(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      return h > 0 ? `${h}h ${m}m` : `${m}m`;
    }

    function formatDistance(meters) {
      return meters >= 1000 ? `${(meters / 1000).toFixed(1)}km` : `${Math.round(meters)}m`;
    }

    function formatWeight(kg) {
      return kg >= 1000 ? `${(kg / 1000).toFixed(1)}t` : `${Math.round(kg)}kg`;
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.round(seconds % 60);
      return m > 0 ? `${m}:${s.toString().padStart(2, '0')}` : `${s}s`;
    }


    function formatCollapsedSets(sets) {
      if (!sets || sets.length === 0) return "";

      const formattedSets = sets.map(s => formatSingleSet(s));

      // Check if all sets are identical
      const allIdentical = formattedSets.every(s => s === formattedSets[0]);

      if (allIdentical && sets.length > 1) {
        return `<span>üí™ ${sets.length} √ó ${formattedSets[0]}</span>`;
      }

      return formattedSets.map(s => `<span>üí™ ${s}</span>`).join('');
    }

    function formatSingleSet(set) {
      const hasWeight = set.weightKg > 0;
      const hasReps = set.reps > 0;
      const hasDistance = set.distanceMeters > 0;
      const hasTime = set.durationSeconds > 0;

      if (hasDistance || hasTime) {
        const parts = [];
        if (hasDistance) {
          parts.push(formatDistance(set.distanceMeters));
        }
        if (hasTime) {
          const formattedTime = formatTime(set.durationSeconds);
          if (hasDistance) {
            parts.push(`in ${formattedTime}`);
          } else {
            parts.push(formattedTime);
          }
        }
        if (hasWeight) {
          parts.push(`√ó ${Math.round(set.weightKg)}kg`);
        }
        return parts.join(' ');
      }

      // Standard weight lifting
      if (hasWeight && hasReps) {
        return `${set.reps} √ó ${set.weightKg.toFixed(1)}kg`;
      } else if (hasWeight) {
        return `${set.weightKg.toFixed(1)}kg`;
      } else if (hasReps) {
        return `${set.reps} reps`;
      }

      return "Completed";
    }

  })();
</script>

<script src="/assets/js/particles.js"></script>
<script>initParticles('showcase-particles');</script>

{{>footer}}