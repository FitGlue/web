{{>header}}
<style>
  header.header {
    display: none !important;
  }

  footer.footer {
    display: none !important;
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
  }
</style>

<section class="showcase-page">
  <!-- Loading State - Full FitGlue Experience -->
  <div id="showcase-loading" class="showcase-loading">
    <!-- Animated background gradient -->
    <div class="loading-bg-gradient"></div>

    <div class="loading-content">
      <!-- Animated logo -->
      <div class="loading-logo">
        <span class="loading-logo-fit">Fit</span><span class="loading-logo-glue">Glue</span>
      </div>

      <!-- Premium multi-ring spinner -->
      <div class="loading-spinner-container">
        <div class="loading-spinner-ring"></div>
        <div class="loading-spinner-ring loading-spinner-ring-2"></div>
        <div class="loading-spinner-ring loading-spinner-ring-3"></div>
      </div>

      <!-- Rotating funny messages -->
      <p id="loading-message" class="loading-message">Loading activity...</p>
    </div>
  </div>

  <!-- Error State -->
  <div id="showcase-error" class="showcase-error" style="display: none;">
    <div class="error-icon">üèÉüèÉ‚Äç‚ôÇÔ∏èüèÉ‚Äç‚ôÄÔ∏è</div>
    <h1>This Activity Got Away!</h1>
    <p id="error-message">Looks like this showcase sprinted off before we could catch it.</p>
    <p class="error-subtitle">It may have expired, or perhaps the link has a typo.</p>
    <a href="/" class="btn btn-primary">Explore FitGlue</a>
  </div>

  <!-- Fullscreen Chart Modal -->
  <div id="chart-modal" class="chart-modal" style="display: none;">
    <div class="chart-modal-backdrop"></div>
    <div class="chart-modal-content glass-card">
      <div class="chart-modal-header">
        <h2 id="chart-modal-title"></h2>
        <button class="chart-modal-close" onclick="closeChartModal()">‚úï</button>
      </div>
      <div class="chart-modal-body">
        <canvas id="chart-modal-canvas"></canvas>
      </div>
    </div>
  </div>

  <!-- Success State -->
  <div id="showcase-content" class="showcase-content" style="display: none;">

    <!-- Hero Header -->
    <div class="showcase-hero">
      <h1 id="activity-title" class="showcase-title"></h1>
      <div id="owner-attribution" class="owner-attribution" style="display: none;"></div>
      <div class="showcase-meta">
        <span id="activity-type" class="activity-type-badge"></span>
        <span id="activity-source" class="activity-source"></span>
        <span id="activity-date" class="activity-date"></span>
      </div>
      <!-- User-provided description - prominent display -->
      <div id="user-description" class="user-description" style="display: none;"></div>
    </div>

    <!-- Stats Grid - Hero Cards -->
    <div id="stats-section" class="stats-grid" style="display: none;"></div>

    <!-- Hybrid Race Breakdown - PRIORITY POSITION for race activities -->
    <div id="hybrid-race-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üèÅ Race Breakdown</h2>
        <span id="hybrid-race-name" class="section-subtitle"></span>
      </div>
      <div id="hybrid-race-bars" class="hybrid-race-bars"></div>
      <div id="hybrid-race-total" class="hybrid-race-total"></div>
    </div>

    <!-- Map Section -->
    <div id="map-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üó∫Ô∏è Route</h2>
      </div>
      <div id="activity-map" class="activity-map"></div>
    </div>

    <!-- Heart Rate Graph -->
    <div id="hr-graph-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ù§Ô∏è Heart Rate</h2>
        <button class="expand-chart-btn" onclick="openChartModal('hr', '‚ù§Ô∏è Heart Rate')" title="Expand">‚õ∂</button>
      </div>
      <div class="hr-summary" id="hr-summary"></div>
      <div class="chart-container">
        <canvas id="hr-chart"></canvas>
      </div>
    </div>

    <!-- Elevation Graph -->
    <div id="elevation-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚õ∞Ô∏è Elevation</h2>
        <button class="expand-chart-btn" onclick="openChartModal('elevation', '‚õ∞Ô∏è Elevation')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="elevation-chart"></canvas>
      </div>
    </div>

    <!-- Pace Graph -->
    <div id="pace-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ö° Pace</h2>
        <button class="expand-chart-btn" onclick="openChartModal('pace', '‚ö° Pace')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="pace-chart"></canvas>
      </div>
    </div>

    <!-- Power Graph -->
    <div id="power-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>‚ö° Power</h2>
        <button class="expand-chart-btn" onclick="openChartModal('power', '‚ö° Power')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="power-chart"></canvas>
      </div>
    </div>

    <!-- Cadence Graph -->
    <div id="cadence-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>ü¶∂ Cadence</h2>
        <button class="expand-chart-btn" onclick="openChartModal('cadence', 'ü¶∂ Cadence')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="cadence-chart"></canvas>
      </div>
    </div>

    <!-- Speed Graph -->
    <div id="speed-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üöÄ Speed</h2>
        <button class="expand-chart-btn" onclick="openChartModal('speed', 'üöÄ Speed')" title="Expand">‚õ∂</button>
      </div>
      <div class="chart-container">
        <canvas id="speed-chart"></canvas>
      </div>
    </div>

    <!-- Description Sections (parsed from enricher output) -->
    <div id="description-sections-container" style="display: none;"></div>

    <!-- Muscle Activation Heatmap -->
    <div id="muscle-activation-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üî• Muscle Activation</h2>
        <span class="section-subtitle">Visual breakdown of muscle engagement</span>
      </div>
      <div class="muscle-heatmap-container">
        <div id="muscle-heatmap-container" class="muscle-heatmap-inner"></div>
      </div>
    </div>

    <!-- Strength Sets / Exercises -->
    <div id="exercises-section" class="showcase-section glass-card" style="display: none;">
      <div class="section-header">
        <h2>üí™ Exercises</h2>
        <span id="exercise-count" class="section-subtitle"></span>
      </div>
      <div id="exercise-list" class="exercise-list"></div>
    </div>


    <!-- Tags -->
    <div id="tags-section" class="showcase-section" style="display: none;">
      <div id="activity-tags" class="activity-tags"></div>
    </div>

    <!-- Enrichments Applied (Premium Feature) - MOVED TO BOTTOM -->
    <div id="enrichments-section" class="showcase-section" style="display: none;">
      <div class="section-header">
        <h2>üöÄ Boosters Applied</h2>
        <span class="section-subtitle">FitGlue Boosters applied to this activity</span>
      </div>
      <div id="enrichment-badges" class="enrichment-list"></div>
    </div>

    <!-- CTA - MOVED TO BOTTOM -->
    <div id="showcase-cta" class="showcase-cta glass-card">
      <div class="cta-content">
        <h3>Want to enhance your own activities?</h3>
        <p>FitGlue automatically enriches your workouts with muscle heatmaps, heart rate data, and beautiful
          summaries.</p>
      </div>
      <a href="/" class="btn btn-primary btn-lg btn-glow">Try FitGlue Free</a>
    </div>

    <!-- Footer Attribution -->
    <div id="showcase-attribution" class="showcase-attribution">
      <span>Powered by</span>
      <a href="/" class="fitglue-logo">
        <span class="fit">Fit</span><span class="glue">Glue</span>
      </a>
    </div>
  </div>
</section>
</main>

<!-- External Dependencies -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>

<style>
  /* ========================================
     SHOWCASE PAGE - WORLD CLASS DESIGN
     ======================================== */

  .showcase-page {
    min-height: 100vh;
    background: linear-gradient(180deg, #0a0a0a 0%, #1a0a20 50%, #0a0a0a 100%);
    padding: 0;
  }

  .showcase-loading {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0A0A0A;
    z-index: 9999;
    overflow: hidden;
  }

  /* Animated background gradient */
  .loading-bg-gradient {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(ellipse at 20% 20%, rgba(255, 27, 141, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(157, 78, 221, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 50%, rgba(76, 201, 240, 0.03) 0%, transparent 70%);
    animation: loading-bg-pulse 4s ease-in-out infinite;
  }

  @keyframes loading-bg-pulse {

    0%,
    100% {
      opacity: 0.6;
      transform: scale(1);
    }

    50% {
      opacity: 1;
      transform: scale(1.05);
    }
  }

  /* Content container */
  .loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    animation: loading-fade-in 0.6s ease-out;
    z-index: 1;
  }

  @keyframes loading-fade-in {
    from {
      opacity: 0;
      transform: translateY(10px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Logo styling */
  .loading-logo {
    font-size: clamp(2.5rem, 8vw, 4rem);
    font-weight: 900;
    letter-spacing: -0.02em;
    display: flex;
    gap: 0;
  }

  .loading-logo-fit {
    background: linear-gradient(135deg, #FF1B8D 0%, #FF6BB3 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: loading-logo-shimmer 2s ease-in-out infinite;
  }

  .loading-logo-glue {
    background: linear-gradient(135deg, #9D4EDD 0%, #C77DFF 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: loading-logo-shimmer 2s ease-in-out infinite 0.15s;
  }

  @keyframes loading-logo-shimmer {

    0%,
    100% {
      opacity: 0.9;
      filter: brightness(1);
    }

    50% {
      opacity: 1;
      filter: brightness(1.2);
    }
  }

  /* Premium multi-ring spinner */
  .loading-spinner-container {
    position: relative;
    width: 60px;
    height: 60px;
  }

  .loading-spinner-ring {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    border: 3px solid transparent;
    border-top-color: #FF1B8D;
    animation: spin 1.2s cubic-bezier(0.5, 0.1, 0.5, 0.9) infinite;
  }

  .loading-spinner-ring-2 {
    inset: 6px;
    border-top-color: #9D4EDD;
    animation-duration: 1.8s;
    animation-direction: reverse;
  }

  .loading-spinner-ring-3 {
    inset: 12px;
    border-top-color: #4CC9F0;
    animation-duration: 2.4s;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  /* Message styling */
  .loading-message {
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.5);
    font-weight: 500;
    letter-spacing: 0.01em;
    min-height: 1.5em;
    transition: opacity 0.3s ease;
  }

  .loading-message.fade-out {
    opacity: 0;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }

    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes shimmer {
    to {
      background-position: 200% center;
    }
  }

  @keyframes pulse {

    0%,
    100% {
      transform: scale(1);
    }

    50% {
      transform: scale(1.05);
    }
  }

  @keyframes glow {

    0%,
    100% {
      box-shadow: 0 0 20px rgba(255, 27, 141, 0.4);
    }

    50% {
      box-shadow: 0 0 40px rgba(255, 27, 141, 0.8);
    }
  }

  /* Error State */
  .showcase-error {
    text-align: center;
    max-width: 500px;
    margin: 15vh auto 0;
    padding: 2rem;
    background: rgba(30, 30, 40, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
  }

  .error-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
  }

  .showcase-error h1 {
    font-size: clamp(1.5rem, 4vw, 2.2rem);
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .showcase-error p {
    font-size: 1rem;
    color: #aaa;
    margin-bottom: 0.5rem;
  }

  .error-subtitle {
    font-size: 0.875rem !important;
    opacity: 0.7;
    margin-bottom: 1.5rem !important;
  }

  /* Content Container - No bounding box on mobile */
  .showcase-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
    animation: fadeInUp 0.6s ease-out;
  }

  @media (min-width: 768px) {
    .showcase-content {
      padding: 0 2rem;
    }
  }

  /* ========================================
     HERO SECTION
     ======================================== */
  .showcase-hero {
    text-align: center;
    padding: 3rem 1rem 2rem;
    margin-bottom: 1.5rem;
    position: relative;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 24px;
    overflow: hidden;
  }

  /* Dark overlay for text readability when banner is present */
  .showcase-hero.has-banner {
    min-height: 350px;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  .showcase-hero.has-banner::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.4);
    z-index: 0;
  }

  .showcase-hero.has-banner>* {
    position: relative;
    z-index: 1;
  }

  .showcase-title {
    font-size: clamp(2.5rem, 8vw, 4rem);
    font-weight: 900;
    margin-bottom: 1rem;
    background: linear-gradient(90deg,
        #FF1B8D 0%,
        #9D4EDD 25%,
        #fff 50%,
        #9D4EDD 75%,
        #FF1B8D 100%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    line-height: 1.1;
    animation: shimmer 3s linear infinite;
    text-shadow: 0 0 60px rgba(255, 27, 141, 0.3);
  }

  .showcase-meta {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  /* User-provided description - big, bold, beautiful */
  .user-description {
    margin-top: 1.5rem;
    padding: 0 1rem;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    font-size: 1.25rem;
    font-style: italic;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
    line-height: 1.6;
    position: relative;
  }

  .user-description::before {
    content: '"';
    font-size: 3rem;
    font-family: Georgia, serif;
    position: absolute;
    left: -0.5rem;
    top: -0.5rem;
    opacity: 0.3;
    color: #9D4EDD;
  }

  /* Compact sections container - horizontal stacking */
  .compact-sections-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
  }

  .compact-sections-row .description-section-card {
    flex: 1 1 280px;
    max-width: 400px;
    min-width: 250px;
  }

  @media (max-width: 600px) {
    .compact-sections-row .description-section-card {
      flex: 1 1 100%;
      max-width: 100%;
    }
  }

  .owner-attribution {
    font-size: 1.1rem;
    color: #aaa;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }

  .owner-name {
    font-weight: 700;
    color: #fff;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .owner-link {
    text-decoration: none;
    cursor: pointer;
    transition: filter 0.2s ease;
  }

  .owner-link:hover {
    filter: brightness(1.3);
  }

  .activity-type-badge {
    background: linear-gradient(135deg, #4CC9F0, #9D4EDD);
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-weight: 700;
    font-size: 0.875rem;
    color: white;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    box-shadow: 0 4px 15px rgba(76, 201, 240, 0.3);
  }

  .activity-source,
  .activity-date {
    color: #aaa;
    font-size: 0.875rem;
  }

  /* ========================================
     HERO STATS GRID
     ======================================== */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
    padding: 0;
  }

  .stat-card {
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    padding: 1.5rem 1rem;
    text-align: center;
    transition: all 0.3s ease;
    animation: fadeInUp 0.6s ease-out backwards;
  }

  .stat-card:nth-child(1) {
    animation-delay: 0.1s;
  }

  .stat-card:nth-child(2) {
    animation-delay: 0.15s;
  }

  .stat-card:nth-child(3) {
    animation-delay: 0.2s;
  }

  .stat-card:nth-child(4) {
    animation-delay: 0.25s;
  }

  .stat-card:nth-child(5) {
    animation-delay: 0.3s;
  }

  .stat-card:hover {
    transform: translateY(-4px);
    border-color: rgba(255, 27, 141, 0.4);
    box-shadow: 0 10px 40px rgba(255, 27, 141, 0.2);
  }

  .stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
  }

  .stat-value {
    font-size: clamp(1.75rem, 5vw, 2.5rem);
    font-weight: 900;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    line-height: 1.2;
  }

  .stat-label {
    font-size: 0.75rem;
    color: #aaa;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-top: 0.25rem;
  }

  /* ========================================
     GLASS CARDS
     ======================================== */
  .glass-card {
    background: rgba(30, 30, 40, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    animation: fadeInUp 0.6s ease-out backwards;
  }

  .showcase-section {
    margin-bottom: 1.5rem;
  }

  .section-header {
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .section-header h2 {
    font-size: 1.25rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
    color: #fff;
  }

  .section-subtitle {
    font-size: 0.875rem;
    color: #aaa;
  }

  /* Expand Chart Button */
  .expand-chart-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    padding: 0.4rem 0.6rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1rem;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .expand-chart-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  /* Fullscreen Chart Modal */
  .chart-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }

  .chart-modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
  }

  .chart-modal-content {
    position: relative;
    width: calc(100vw - 2rem);
    height: calc(100vh - 2rem);
    max-width: none;
    max-height: none;
    padding: 1.5rem;
    animation: modalSlideIn 0.3s ease;
  }

  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: scale(0.95) translateY(20px);
    }

    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .chart-modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
  }

  .chart-modal-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #fff;
  }

  .chart-modal-close {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.25rem;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .chart-modal-close:hover {
    background: rgba(255, 100, 100, 0.3);
    border-color: rgba(255, 100, 100, 0.5);
  }

  .chart-modal-body {
    height: calc(90vh - 120px);
    min-height: 400px;
  }

  .chart-modal-body canvas {
    width: 100% !important;
    height: 100% !important;
  }

  /* ========================================
     MAP
     ======================================== */
  .activity-map {
    height: 300px;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* Custom Leaflet Theming */
  .leaflet-container {
    background: #1a1a2e;
  }

  .leaflet-tile {
    filter: saturate(0.3) brightness(0.6) hue-rotate(200deg);
  }

  /* Route Thumbnail */
  .route-thumbnail-container {
    position: relative;
    margin-bottom: 1rem;
  }

  .route-thumbnail {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .expand-map-btn {
    display: block;
    width: 100%;
    margin-top: 0.75rem;
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.2), rgba(255, 27, 141, 0.2));
    border: 1px solid rgba(157, 78, 221, 0.4);
    border-radius: 12px;
    color: #fff;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .expand-map-btn:hover {
    border-color: rgba(255, 27, 141, 0.6);
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.3), rgba(255, 27, 141, 0.3));
    transform: translateY(-2px);
  }

  /* ========================================
     ROUTE THUMBNAIL
     ======================================== */
  .route-thumbnail-container {
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .route-thumbnail-image {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(255, 27, 141, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .route-thumbnail-image:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.4);
  }

  .route-thumbnail-hint {
    font-size: 0.875rem;
    color: #aaa;
    margin-top: 0.5rem;
    font-style: italic;
  }

  /* ========================================
     MUSCLE ACTIVATION HEATMAP
     ======================================== */
  .muscle-heatmap-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 16px;
  }

  .muscle-heatmap-inner {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
  }

  .muscle-heatmap-inner svg,
  .muscle-heatmap-image {
    max-width: 100%;
    height: auto;
    max-height: 500px;
    filter: drop-shadow(0 0 20px rgba(255, 27, 141, 0.3));
  }

  @media (min-width: 768px) {

    .muscle-heatmap-inner svg,
    .muscle-heatmap-image {
      max-height: 600px;
    }
  }

  /* Route thumbnail SVG styling */
  .route-thumbnail-container svg.route-thumbnail-image {
    width: 100%;
    height: auto;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(255, 27, 141, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .route-thumbnail-container svg.route-thumbnail-image:hover {
    transform: scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.4);
  }

  /* ========================================
     CHARTS
     ======================================== */
  .chart-container {
    position: relative;
    height: 200px;
    width: 100%;
  }

  .hr-summary {
    display: flex;
    justify-content: space-around;
    margin-bottom: 1rem;
    text-align: center;
  }

  .hr-stat-mini {
    display: flex;
    flex-direction: column;
  }

  .hr-value-mini {
    font-size: 1.5rem;
    font-weight: 800;
    color: #ff6b6b;
  }

  .hr-label-mini {
    font-size: 0.75rem;
    color: #aaa;
    text-transform: uppercase;
  }

  /* ========================================
     DESCRIPTION
     ======================================== */
  .activity-description {
    background: rgba(0, 0, 0, 0.3);
    padding: 1.25rem;
    border-radius: 16px;
    white-space: pre-wrap;
    font-family: inherit;
    font-size: 1rem;
    color: #fff;
    line-height: 1.7;
    overflow-x: auto;
    border: 1px solid rgba(255, 255, 255, 0.05);
    margin: 0;
  }

  /* Description Section Cards (parsed from enricher output) */
  .description-section-card {
    animation: fadeInUp 0.5s ease-out backwards;
  }

  #description-sections-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  /* ========================================
     PERSONAL RECORDS CARDS
     ======================================== */
  .pr-records-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 0.75rem;
  }

  .pr-card {
    background: linear-gradient(145deg, rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.02));
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.1rem 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    transition: all 0.25s ease;
    animation: fadeInUp 0.4s ease-out backwards;
    position: relative;
    overflow: hidden;
  }

  .pr-card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    background: linear-gradient(135deg, var(--pr-accent, rgba(255, 27, 141, 0.08)), transparent 60%);
    pointer-events: none;
  }

  .pr-card:hover {
    transform: translateY(-3px);
    border-color: var(--pr-accent, rgba(255, 27, 141, 0.3));
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3), 0 0 20px var(--pr-accent, rgba(255, 27, 141, 0.1));
  }

  .pr-card.pr-type-1rm {
    --pr-accent: rgba(255, 27, 141, 0.15);
  }

  .pr-card.pr-type-volume {
    --pr-accent: rgba(157, 78, 221, 0.15);
  }

  .pr-card.pr-type-reps {
    --pr-accent: rgba(76, 201, 240, 0.15);
  }

  .pr-card.pr-type-time {
    --pr-accent: rgba(6, 255, 165, 0.15);
  }

  .pr-card.pr-type-distance {
    --pr-accent: rgba(255, 159, 67, 0.15);
  }

  .pr-card-top {
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }

  .pr-emoji {
    font-size: 1.5rem;
    filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.2));
    flex-shrink: 0;
  }

  .pr-name {
    font-size: 0.82rem;
    font-weight: 700;
    color: #fff;
    line-height: 1.25;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }

  .pr-value {
    font-size: 1.5rem;
    font-weight: 900;
    letter-spacing: -0.02em;
    line-height: 1.15;
    position: relative;
    z-index: 1;
  }

  .pr-value.gradient-1rm {
    background: linear-gradient(135deg, #FF1B8D, #FF6BB3);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-volume {
    background: linear-gradient(135deg, #9D4EDD, #C77DFF);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-reps {
    background: linear-gradient(135deg, #4CC9F0, #80DAFF);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-time {
    background: linear-gradient(135deg, #06FFA5, #4ADE80);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-value.gradient-distance {
    background: linear-gradient(135deg, #FF9F43, #FFD93D);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .pr-type-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #888;
    font-weight: 600;
  }

  .pr-improvement {
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.45rem;
    border-radius: 20px;
    width: fit-content;
    position: relative;
    z-index: 1;
  }

  .pr-improvement.positive {
    background: rgba(6, 255, 165, 0.12);
    color: #4ADE80;
    border: 1px solid rgba(6, 255, 165, 0.2);
  }

  .pr-improvement.negative {
    background: rgba(255, 100, 100, 0.12);
    color: #FF6B6B;
    border: 1px solid rgba(255, 100, 100, 0.2);
  }

  @media (max-width: 480px) {
    .pr-records-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }

    .pr-value {
      font-size: 1.2rem;
    }

    .pr-emoji {
      font-size: 1.2rem;
    }

    .pr-name {
      font-size: 0.75rem;
    }
  }

  /* ========================================
     INTERVALS TIMELINE
     ======================================== */
  .intervals-timeline {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  .interval-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 0.5rem 0.7rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--interval-accent, rgba(255, 255, 255, 0.15));
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .interval-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .interval-row.warmup {
    --interval-accent: #4ADE80;
  }

  .interval-row.cooldown {
    --interval-accent: #60A5FA;
  }

  .interval-row.sprint {
    --interval-accent: #FF6BB3;
  }

  .interval-row.group-header {
    --interval-accent: #C77DFF;
    background: rgba(157, 78, 221, 0.06);
  }

  .interval-row.summary {
    --interval-accent: rgba(255, 255, 255, 0.2);
    border-left-style: dashed;
  }

  .interval-emoji {
    font-size: 1.1rem;
    flex-shrink: 0;
  }

  .interval-label {
    flex: 1;
    font-size: 0.82rem;
    color: #ccc;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .interval-stats {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
  }

  .interval-stat {
    font-size: 0.75rem;
    font-weight: 600;
    padding: 0.15rem 0.5rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.06);
    color: #ddd;
    white-space: nowrap;
  }

  .interval-stat.pace {
    color: #FF6BB3;
  }

  .interval-stat.hr {
    color: #FF6B6B;
  }

  .interval-stat.dist {
    color: #4CC9F0;
  }

  .interval-stat.time {
    color: #FFD93D;
  }

  /* ========================================
     HR ZONE BARS
     ======================================== */
  .hr-zones-list {
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }

  .hr-zone-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    animation: fadeInUp 0.3s ease-out backwards;
  }

  .hr-zone-label {
    font-size: 0.72rem;
    font-weight: 600;
    color: #aaa;
    min-width: 110px;
    flex-shrink: 0;
    text-align: right;
  }

  .hr-zone-bar {
    flex: 1;
    height: 22px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    overflow: hidden;
    position: relative;
  }

  .hr-zone-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.8s ease-out;
    min-width: 2px;
  }

  .hr-zone-fill.zone-0 {
    background: linear-gradient(90deg, #6B7280, #9CA3AF);
  }

  .hr-zone-fill.zone-1 {
    background: linear-gradient(90deg, #60A5FA, #93C5FD);
  }

  .hr-zone-fill.zone-2 {
    background: linear-gradient(90deg, #4ADE80, #86EFAC);
  }

  .hr-zone-fill.zone-3 {
    background: linear-gradient(90deg, #FBBF24, #FCD34D);
  }

  .hr-zone-fill.zone-4 {
    background: linear-gradient(90deg, #FB923C, #FDBA74);
  }

  .hr-zone-fill.zone-5 {
    background: linear-gradient(90deg, #EF4444, #FCA5A5);
  }

  .hr-zone-duration {
    font-size: 0.72rem;
    font-weight: 700;
    color: #ddd;
    min-width: 45px;
    text-align: right;
    flex-shrink: 0;
  }

  /* ========================================
     GOAL / STREAK / MILESTONE PROGRESS
     ======================================== */
  .progress-section-body {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .progress-bar-container {
    width: 100%;
    height: 28px;
    background: rgba(255, 255, 255, 0.06);
    border-radius: 14px;
    overflow: hidden;
    position: relative;
  }

  .progress-bar-fill {
    height: 100%;
    border-radius: 14px;
    background: linear-gradient(90deg, #FF1B8D, #9D4EDD);
    transition: width 1s ease-out;
    position: relative;
    min-width: 4px;
  }

  .progress-bar-fill.milestone {
    background: linear-gradient(90deg, #4CC9F0, #9D4EDD);
  }

  .progress-bar-fill.streak {
    background: linear-gradient(90deg, #FB923C, #EF4444);
  }

  .progress-bar-label {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.72rem;
    font-weight: 800;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
  }

  .progress-details {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }

  .progress-detail-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: #bbb;
  }

  .progress-detail-row .detail-emoji {
    flex-shrink: 0;
  }

  .streak-number {
    font-size: 2.5rem;
    font-weight: 900;
    letter-spacing: -0.03em;
    background: linear-gradient(135deg, #FB923C, #EF4444);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    line-height: 1;
  }

  .streak-label {
    font-size: 0.85rem;
    color: #aaa;
    font-weight: 600;
  }

  .streak-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.7rem;
    font-weight: 700;
    padding: 0.2rem 0.6rem;
    border-radius: 20px;
    background: rgba(251, 146, 60, 0.12);
    color: #FB923C;
    border: 1px solid rgba(251, 146, 60, 0.2);
    width: fit-content;
  }

  /* ========================================
     STAT ROWS (bullet-list sections)
     ======================================== */
  .stat-rows {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }

  .stat-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.45rem 0.6rem;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.03);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .stat-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .stat-row-emoji {
    font-size: 1rem;
    flex-shrink: 0;
  }

  .stat-row-label {
    flex: 1;
    font-size: 0.82rem;
    color: #aaa;
    min-width: 0;
  }

  .stat-row-value {
    font-size: 0.88rem;
    font-weight: 700;
    color: #fff;
    text-align: right;
    flex-shrink: 0;
  }

  /* ========================================
     COMPACT STAT PILLS (single-line ‚Ä¢-separated)
     ======================================== */
  .compact-stat-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    align-items: center;
  }

  .stat-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    padding: 0.35rem 0.7rem;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.08);
    font-size: 0.8rem;
    font-weight: 600;
    color: #ddd;
    transition: all 0.2s;
  }

  .stat-pill:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.15);
  }

  .stat-pill-label {
    color: #888;
    font-weight: 500;
  }

  .stat-pill-value {
    color: #fff;
    font-weight: 700;
  }

  @media (max-width: 480px) {
    .hr-zone-label {
      min-width: 80px;
      font-size: 0.65rem;
    }

    .interval-stats {
      gap: 0.25rem;
    }

    .interval-stat {
      font-size: 0.65rem;
      padding: 0.1rem 0.35rem;
    }

    .streak-number {
      font-size: 2rem;
    }
  }

  /* ========================================
     AI SUMMARY PROSE
     ======================================== */
  .ai-summary-prose {
    font-size: 0.9rem;
    line-height: 1.7;
    color: #ccc;
    padding: 0.6rem 0.8rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.02);
    border-left: 3px solid rgba(255, 200, 50, 0.3);
    font-style: italic;
  }

  /* ========================================
     PARKRUN RESULTS
     ======================================== */
  .parkrun-results {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .parkrun-stat-row {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 0.55rem 0.7rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .parkrun-stat-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .parkrun-stat-label {
    font-size: 0.82rem;
    color: #aaa;
    min-width: 90px;
    font-weight: 600;
  }

  .parkrun-stat-value {
    font-size: 0.95rem;
    font-weight: 700;
    color: #fff;
  }

  .parkrun-badges {
    display: flex;
    gap: 0.35rem;
    flex-wrap: wrap;
    margin-left: auto;
  }

  .parkrun-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.2rem;
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.5rem;
    border-radius: 20px;
    white-space: nowrap;
  }

  .parkrun-badge.all-time {
    background: rgba(255, 215, 0, 0.12);
    color: #FFD700;
    border: 1px solid rgba(255, 215, 0, 0.2);
  }

  .parkrun-badge.this-year {
    background: rgba(192, 192, 192, 0.12);
    color: #C0C0C0;
    border: 1px solid rgba(192, 192, 192, 0.2);
  }

  .parkrun-badge.first-visit {
    background: rgba(255, 255, 100, 0.12);
    color: #FFFF64;
    border: 1px solid rgba(255, 255, 100, 0.2);
  }

  /* ========================================
     EFFORT SCORE GAUGE
     ======================================== */
  .effort-score-body {
    display: flex;
    flex-direction: column;
    gap: 0.7rem;
  }

  .effort-gauge {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .effort-gauge-ring {
    position: relative;
    width: 80px;
    height: 80px;
    flex-shrink: 0;
  }

  .effort-gauge-ring svg {
    transform: rotate(-90deg);
    width: 80px;
    height: 80px;
  }

  .effort-gauge-ring .gauge-bg {
    fill: none;
    stroke: rgba(255, 255, 255, 0.08);
    stroke-width: 6;
  }

  .effort-gauge-ring .gauge-fill {
    fill: none;
    stroke-width: 6;
    stroke-linecap: round;
    transition: stroke-dashoffset 1s ease-out;
  }

  .effort-gauge-value {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.3rem;
    font-weight: 900;
    color: #fff;
  }

  .effort-gauge-info {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
  }

  .effort-label {
    font-size: 1.1rem;
    font-weight: 700;
  }

  .effort-label.easy {
    color: #4ADE80;
  }

  .effort-label.moderate {
    color: #FBBF24;
  }

  .effort-label.hard {
    color: #FB923C;
  }

  .effort-label.very-hard {
    color: #EF4444;
  }

  .effort-label.max {
    color: #DC2626;
  }

  .effort-factors {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }

  .effort-factor {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.35rem 0.6rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    font-size: 0.8rem;
    color: #bbb;
    animation: fadeInUp 0.3s ease-out backwards;
  }

  .effort-factor-emoji {
    flex-shrink: 0;
  }

  .effort-factor-name {
    flex: 1;
    color: #aaa;
  }

  .effort-factor-value {
    font-weight: 700;
    color: #fff;
  }

  .effort-verdict {
    font-size: 0.8rem;
    color: #888;
    font-style: italic;
    padding-left: 0.3rem;
  }

  /* ========================================
     WORKOUT SUMMARY
     ======================================== */
  .workout-summary-body {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .workout-headline-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
  }

  .workout-exercises {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }

  .workout-exercise-row {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    padding: 0.4rem 0.6rem;
    border-radius: 10px;
    background: rgba(255, 255, 255, 0.03);
    animation: fadeInUp 0.3s ease-out backwards;
    transition: background 0.2s;
  }

  .workout-exercise-row:hover {
    background: rgba(255, 255, 255, 0.06);
  }

  .workout-superset-marker {
    font-size: 0.85rem;
    flex-shrink: 0;
    min-width: 1.4rem;
    text-align: center;
  }

  .workout-exercise-name {
    font-size: 0.82rem;
    font-weight: 600;
    color: #ddd;
    flex-shrink: 0;
    min-width: 0;
  }

  .workout-exercise-sets {
    font-size: 0.8rem;
    color: #aaa;
    flex: 1;
    text-align: right;
    word-break: break-word;
  }

  @media (max-width: 480px) {
    .effort-gauge-ring {
      width: 64px;
      height: 64px;
    }

    .effort-gauge-ring svg {
      width: 64px;
      height: 64px;
    }

    .effort-gauge-value {
      font-size: 1rem;
    }

    .parkrun-stat-label {
      min-width: 70px;
      font-size: 0.75rem;
    }
  }

  /* ========================================
     EXERCISES
     ======================================== */
  .exercise-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .exercise-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 1rem 1.25rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 16px;
    border-left: 4px solid #4CC9F0;
    transition: all 0.2s ease;
  }

  .exercise-item:hover {
    background: rgba(0, 0, 0, 0.3);
    border-left-color: #FF1B8D;
  }

  .exercise-name {
    font-weight: 700;
    color: #fff;
    font-size: 1rem;
  }

  .exercise-detail {
    display: flex;
    gap: 1rem;
    font-size: 0.875rem;
    color: #aaa;
    flex-wrap: wrap;
  }

  .exercise-detail span {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .exercise-badge {
    background: linear-gradient(135deg, rgba(76, 201, 240, 0.2), rgba(157, 78, 221, 0.2));
    border: 1px solid rgba(76, 201, 240, 0.3);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 600;
  }

  /* ========================================
     TAGS
     ======================================== */
  .activity-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
  }

  .activity-tag {
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 0.5rem 1rem;
    border-radius: 50px;
    font-size: 0.875rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  /* ========================================
     ENRICHMENTS (BOOSTERS)
     ======================================== */
  .enrichment-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1rem;
  }

  .enrichment-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(255, 27, 141, 0.1));
    border: 1px solid rgba(157, 78, 221, 0.3);
    border-radius: 16px;
    transition: all 0.2s ease;
  }

  .enrichment-item:hover {
    border-color: rgba(255, 27, 141, 0.5);
    transform: translateY(-2px);
  }

  .enrichment-icon {
    font-size: 2rem;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.2));
  }

  .enrichment-info {
    flex: 1;
  }

  .enrichment-name {
    font-weight: 700;
    color: #fff;
    margin-bottom: 0.125rem;
  }

  .enrichment-desc {
    font-size: 0.875rem;
    color: #aaa;
  }

  /* ========================================
     CTA SECTION
     ======================================== */
  .showcase-cta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1.5rem;
    margin-top: 3rem;
    background: linear-gradient(135deg, rgba(157, 78, 221, 0.25), rgba(255, 27, 141, 0.25));
    border: 1px solid rgba(157, 78, 221, 0.4);
    padding: 2rem;
  }

  .cta-content h3 {
    margin-bottom: 0.5rem;
    font-size: 1.25rem;
    color: #fff;
  }

  .cta-content p {
    color: #aaa;
    font-size: 0.9rem;
    margin: 0;
  }

  .btn {
    display: inline-block;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 50px;
    font-size: 1rem;
    font-weight: 700;
    cursor: pointer;
    text-decoration: none;
    transition: all 0.2s ease;
  }

  .btn-primary {
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    color: white;
  }

  .btn-lg {
    padding: 1rem 2rem;
    font-size: 1.1rem;
  }

  .btn-glow {
    animation: glow 2s ease-in-out infinite;
  }

  .btn-primary:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 8px 30px rgba(255, 27, 141, 0.5);
  }

  @media (max-width: 640px) {
    .showcase-cta {
      flex-direction: column;
      text-align: center;
    }
  }

  /* ========================================
     ATTRIBUTION
     ======================================== */
  .showcase-attribution {
    text-align: center;
    padding: 3rem 0 2rem;
    color: #aaa;
    font-size: 0.9rem;
  }

  .fitglue-logo {
    text-decoration: none;
    font-weight: 900;
    font-size: 1.25rem;
    margin-left: 0.25rem;
  }

  .fit {
    color: #FF1B8D;
  }

  .glue {
    color: #9D4EDD;
  }

  /* ========================================
     MUSCLE ACTIVATION IMAGE
     ======================================== */
  .muscle-activation-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
  }

  /* ========================================
     HYBRID RACE BAR CHART
     ======================================== */
  .hybrid-race-bars {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .hybrid-race-bar-row {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .hybrid-race-bar-icon {
    font-size: 1.25rem;
    width: 2rem;
    text-align: center;
    flex-shrink: 0;
  }

  .hybrid-race-bar-container {
    flex: 1;
    height: 32px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    overflow: hidden;
    position: relative;
  }

  .hybrid-race-bar {
    height: 100%;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 0.75rem;
    min-width: 60px;
    transition: width 0.6s ease-out;
  }

  /* Run segments - cyan/teal */
  .hybrid-race-bar.bar-run {
    background: linear-gradient(90deg, #4CC9F0 0%, #38B6DC 100%);
  }

  /* Station segments - pink/purple gradient */
  .hybrid-race-bar.bar-station {
    background: linear-gradient(90deg, #FF1B8D 0%, #9D4EDD 100%);
  }

  .hybrid-race-bar-time {
    font-size: 0.875rem;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    white-space: nowrap;
  }

  .hybrid-race-bar-label {
    width: 140px;
    font-size: 0.875rem;
    color: #ddd;
    flex-shrink: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  @media (max-width: 640px) {
    .hybrid-race-bar-label {
      width: 100px;
      font-size: 0.75rem;
    }

    .hybrid-race-bar-time {
      font-size: 0.75rem;
    }
  }

  .hybrid-race-total {
    margin-top: 1rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(255, 27, 141, 0.15), rgba(157, 78, 221, 0.15));
    border: 1px solid rgba(255, 27, 141, 0.3);
    border-radius: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .hybrid-race-total-label {
    font-size: 1rem;
    font-weight: 700;
    color: #fff;
  }

  .hybrid-race-total-value {
    font-size: 1.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #FF1B8D, #9D4EDD);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
</style>

<script>
  // Sims-style rotating jokey fitness messages
  const LOADING_MESSAGES = [
    'Reticulating muscle fibers...',
    'Calibrating sweat glands...',
    'Polishing your running shoes...',
    'Stretching the pixels...',
    'Syncing your chakras...',
    'Buffering endorphins...',
    'Warming up the algorithms...',
    'Hydrating the database...',
    'Massaging the data points...',
    'Doing some light cardio...',
    'Flexing the API...',
    'Counting backwards from 10...',
    'Foam rolling the server...',
    'Adjusting seat to upright position...',
    'Untangling your headphones...',
    'Finding your gym buddy...',
    'Motivating the backend...',
    'Applying anti-chafe cream...',
    'Loading protein shakes...',
    'Activating beast mode...',
  ];

  // Start rotating messages
  let messageIndex = Math.floor(Math.random() * LOADING_MESSAGES.length);
  const loadingMessageEl = document.getElementById('loading-message');

  function rotateMessage() {
    if (loadingMessageEl) {
      loadingMessageEl.classList.add('fade-out');
      setTimeout(() => {
        messageIndex = (messageIndex + 1) % LOADING_MESSAGES.length;
        loadingMessageEl.textContent = LOADING_MESSAGES[messageIndex];
        loadingMessageEl.classList.remove('fade-out');
      }, 300);
    }
  }

  // Set initial message and start rotation
  if (loadingMessageEl) {
    loadingMessageEl.textContent = LOADING_MESSAGES[messageIndex];
  }
  const messageInterval = setInterval(rotateMessage, 2000);

  (async function () {
    // Extract ID from URL path: /showcase/{id}
    const pathParts = window.location.pathname.split('/').filter(Boolean);
    let showcaseId = pathParts[0] === 'showcase' && pathParts[1] ? pathParts[1] : new URLSearchParams(window.location.search).get('id');

    const loadingEl = document.getElementById('showcase-loading');
    const errorEl = document.getElementById('showcase-error');
    const contentEl = document.getElementById('showcase-content');
    const errorMsgEl = document.getElementById('error-message');

    if (!showcaseId) {
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMsgEl.textContent = 'No showcase ID provided.';
      return;
    }

    try {
      const response = await fetch(`/api/showcase/${showcaseId}`);

      if (!response.ok) {
        clearInterval(messageInterval);
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
        errorMsgEl.textContent = response.status === 404 ? "This showcase doesn't exist." :
          response.status === 410 ? 'This showcase has expired.' : 'Failed to load showcase.';
        return;
      }

      const data = await response.json();
      renderShowcase(data);
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      contentEl.style.display = 'block';

    } catch (error) {
      console.error('Error loading showcase:', error);
      clearInterval(messageInterval);
      loadingEl.style.display = 'none';
      errorEl.style.display = 'block';
      errorMsgEl.textContent = 'An error occurred while loading.';
    }

    function renderShowcase(data) {
      // Title & Meta
      document.getElementById('activity-title').textContent = data.title || 'Activity';
      document.getElementById('activity-type').textContent = formatActivityType(data.activityType);
      document.getElementById('activity-source').textContent = 'from ' + formatSource(data.source);

      // Owner attribution
      if (data.ownerDisplayName) {
        const attrEl = document.getElementById('owner-attribution');
        const slug = data.ownerDisplayName.toLowerCase().trim().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
        attrEl.innerHTML = `by <a href="/u/${slug}" class="owner-name owner-link">${data.ownerDisplayName}</a>`;
        attrEl.style.display = 'flex';
      }

      if (data.startTime) {
        document.getElementById('activity-date').textContent = new Date(data.startTime).toLocaleDateString(undefined, {
          weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });
      }

      // Hide FitGlue branding for Athlete users
      if (data.isAthlete) {
        const cta = document.getElementById('showcase-cta');
        const attribution = document.getElementById('showcase-attribution');
        if (cta) cta.style.display = 'none';
        if (attribution) attribution.style.display = 'none';
      }

      // AI Banner background image
      const bannerUrl = data.enrichmentMetadata?.asset_ai_banner;
      if (bannerUrl) {
        const heroEl = document.querySelector('.showcase-hero');
        heroEl.style.backgroundImage = `url(${bannerUrl})`;
        heroEl.classList.add('has-banner');
      }

      // Stats
      const activity = data.activityData;
      if (activity && activity.sessions && activity.sessions.length > 0) {
        const session = activity.sessions[0];
        const statsGrid = document.getElementById('stats-section');
        const stats = [];

        if (session.totalElapsedTime) stats.push({ icon: '‚è±Ô∏è', value: formatDuration(session.totalElapsedTime), label: 'Duration' });
        if (session.totalDistance) stats.push({ icon: 'üìè', value: formatDistance(session.totalDistance), label: 'Distance' });

        // Cardio stats
        const allRecords = session.laps ? session.laps.flatMap(l => l.records || []) : [];
        const hrValues = allRecords.filter(r => r.heartRate > 0).map(r => r.heartRate);
        if (hrValues.length > 0) {
          const avgHr = Math.round(hrValues.reduce((a, b) => a + b, 0) / hrValues.length);
          stats.push({ icon: '‚ù§Ô∏è', value: avgHr, label: 'Avg BPM' });
        }

        // Power stats
        const powerValues = allRecords.filter(r => r.power > 0).map(r => r.power);
        if (powerValues.length > 0) {
          const avgPower = Math.round(powerValues.reduce((a, b) => a + b, 0) / powerValues.length);
          stats.push({ icon: '‚ö°', value: avgPower + 'W', label: 'Avg Power' });
        }

        // Cadence stats
        const cadenceValues = allRecords.filter(r => r.cadence > 0).map(r => r.cadence);
        if (cadenceValues.length > 0) {
          const avgCadence = Math.round(cadenceValues.reduce((a, b) => a + b, 0) / cadenceValues.length);
          stats.push({ icon: 'ü¶∂', value: avgCadence, label: 'Avg Cadence' });
        }

        // Speed/Pace stats
        const speedValues = allRecords.filter(r => r.speed > 0).map(r => r.speed);
        if (speedValues.length > 0) {
          const avgSpeed = speedValues.reduce((a, b) => a + b, 0) / speedValues.length;
          const avgSpeedKmh = (avgSpeed * 3.6).toFixed(1);
          stats.push({ icon: 'üöÄ', value: avgSpeedKmh + ' km/h', label: 'Avg Speed' });
        }

        // Strength stats
        if (session.strengthSets && session.strengthSets.length > 0) {
          const totalSets = session.strengthSets.length;
          const totalReps = session.strengthSets.reduce((sum, s) => sum + (s.reps || 0), 0);
          const totalWeightCalculated = session.strengthSets.reduce((sum, s) => {
            const reps = s.reps || 0;
            const weight = s.weightKg || 0;
            const distance = s.distanceMeters || 0;
            if (weight > 0) {
              if (reps > 0) return sum + (reps * weight);
              if (distance > 0) return sum + (distance * weight);
            }
            return sum;
          }, 0);
          stats.push({ icon: 'üî¢', value: totalSets, label: 'Sets' });
          stats.push({ icon: 'üí™', value: totalReps, label: 'Reps' });
          if (totalWeightCalculated > 0) stats.push({ icon: '‚öñÔ∏è', value: formatWeight(totalWeightCalculated), label: 'Volume' });
        }

        if (stats.length > 0) {
          statsGrid.innerHTML = stats.map(s => `
          <div class="stat-card">
            <div class="stat-icon">${s.icon}</div>
            <div class="stat-value">${s.value}</div>
            <div class="stat-label">${s.label}</div>
          </div>
        `).join('');
          statsGrid.style.display = 'grid';
        }

        // --- MAP / ROUTE THUMBNAIL ---
        const routeThumbnailUrl = data.enrichmentMetadata?.asset_route_thumbnail;
        const gpsRecords = allRecords.filter(r => r.positionLat && r.positionLong);

        if (routeThumbnailUrl || gpsRecords.length > 10) {
          const mapSection = document.getElementById('map-section');
          mapSection.style.display = 'block';

          if (routeThumbnailUrl) {
            // Display route thumbnail (SVG inline or img)
            const thumbnailContainer = document.createElement('div');
            thumbnailContainer.className = 'route-thumbnail-container';
            renderAsset(routeThumbnailUrl, 'Route Map', 'route-thumbnail-image', thumbnailContainer);
            const mapContainer = document.getElementById('activity-map');
            mapContainer.parentNode.insertBefore(thumbnailContainer, mapContainer);

            // If GPS data exists, show expandable interactive map option
            if (gpsRecords.length > 10) {
              mapContainer.style.display = 'none';
              thumbnailContainer.innerHTML += `
                <button class="expand-map-btn" onclick="document.getElementById('activity-map').style.display='block'; this.style.display='none'; initMap(gpsRecords);">
                  üó∫Ô∏è Show Interactive Map
                </button>
              `;
              // Make gpsRecords accessible to onclick handler
              window.gpsRecords = gpsRecords;
            } else {
              mapContainer.style.display = 'none';
            }
          } else {
            // No thumbnail, show interactive map
            setTimeout(() => initMap(gpsRecords), 100);
          }
        }

        // --- HEART RATE GRAPH ---
        if (hrValues.length > 10) {
          const hrSection = document.getElementById('hr-graph-section');
          const avg = Math.round(hrValues.reduce((a, b) => a + b, 0) / hrValues.length);
          const max = Math.max(...hrValues);
          const min = Math.min(...hrValues);

          document.getElementById('hr-summary').innerHTML = `
            <div class="hr-stat-mini"><span class="hr-value-mini">${avg}</span><span class="hr-label-mini">Avg</span></div>
            <div class="hr-stat-mini"><span class="hr-value-mini">${max}</span><span class="hr-label-mini">Max</span></div>
            <div class="hr-stat-mini"><span class="hr-value-mini">${min}</span><span class="hr-label-mini">Min</span></div>
          `;

          hrSection.style.display = 'block';
          setTimeout(() => initHrChart(allRecords, timeMarkers), 100);
        }

        // --- ELEVATION GRAPH ---
        if (allRecords.some(r => r.altitude !== undefined)) {
          document.getElementById('elevation-section').style.display = 'block';
          setTimeout(() => initElevationChart(allRecords, timeMarkers), 100);
        }

        // --- PACE GRAPH (from speed data) ---
        if (allRecords.filter(r => r.speed > 0).length > 10) {
          document.getElementById('pace-section').style.display = 'block';
          setTimeout(() => initPaceChart(allRecords, timeMarkers), 100);
        }

        // --- POWER GRAPH ---
        if (allRecords.filter(r => r.power > 0).length > 10) {
          document.getElementById('power-section').style.display = 'block';
          setTimeout(() => initPowerChart(allRecords, timeMarkers), 100);
        }

        // --- CADENCE GRAPH ---
        if (allRecords.filter(r => r.cadence > 0).length > 10) {
          document.getElementById('cadence-section').style.display = 'block';
          setTimeout(() => initCadenceChart(allRecords, timeMarkers), 100);
        }

        // --- SPEED GRAPH ---
        if (allRecords.filter(r => r.speed > 0).length > 10) {
          document.getElementById('speed-section').style.display = 'block';
          setTimeout(() => initSpeedChart(allRecords, timeMarkers), 100);
        }

        // --- EXERCISES ---
        if (session.strengthSets && session.strengthSets.length > 0) {
          const exercisesSection = document.getElementById('exercises-section');
          const exerciseList = document.getElementById('exercise-list');

          // Group by exercise name (preserving order)
          const blocks = [];
          const blockMap = {};
          session.strengthSets.forEach(set => {
            const name = set.exerciseName || 'Unknown';
            if (!blockMap[name]) {
              const block = { name, sets: [] };
              blocks.push(block);
              blockMap[name] = block;
            }
            blockMap[name].sets.push(set);
          });

          // Superset detection
          const hasSupersets = blocks.some(b => b.sets[0].supersetId);
          const supersetEmojiMap = {};
          const emojiNumbers = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"];
          let supersetCounter = 0;

          if (hasSupersets) {
            blocks.forEach(b => {
              const sid = b.sets[0].supersetId;
              if (sid && !supersetEmojiMap[sid]) {
                if (supersetCounter < emojiNumbers.length) {
                  supersetEmojiMap[sid] = emojiNumbers[supersetCounter++];
                }
              }
            });
          }

          document.getElementById('exercise-count').textContent = `${blocks.length} exercises`;

          exerciseList.innerHTML = blocks.map(b => {
            let marker = "";
            if (hasSupersets) {
              const sid = b.sets[0].supersetId;
              marker = sid ? (supersetEmojiMap[sid] + " ") : "‚¨ú ";
            }

            const formattedSets = formatCollapsedSets(b.sets);

            return `
            <div class="exercise-item">
              <span class="exercise-name">${marker}${b.name}</span>
              <div class="exercise-detail">
                <span>üìä ${b.sets.length} sets</span>
                ${formattedSets}
              </div>
            </div>
          `;
          }).join('');
          exercisesSection.style.display = 'block';
        }

        // --- MUSCLE ACTIVATION HEATMAP ---
        const heatmapUrl = data.enrichmentMetadata?.asset_muscle_heatmap;
        if (heatmapUrl) {
          const heatmapSection = document.getElementById('muscle-activation-section');
          const heatmapContainer = document.getElementById('muscle-heatmap-container');
          renderAsset(heatmapUrl, 'Muscle Activation Heatmap', 'muscle-heatmap-image', heatmapContainer);
          heatmapSection.style.display = 'block';
        }

        // --- HYBRID RACE BAR CHART ---
        // Note: timeMarkers is on the activity level, not session level
        const timeMarkers = activity.timeMarkers || [];
        const activityName = data.activityData?.name || '';
        const activityTags = data.activityData?.tags || [];

        // Detect hybrid race type from name or tags
        const isHybridRace =
          activityName.toLowerCase().includes('hyrox') ||
          activityName.toLowerCase().includes('athx') ||
          activityTags.some(t => t.toLowerCase().includes('hyrox')) ||
          activityTags.some(t => t.toLowerCase().includes('athx'));

        if (isHybridRace && timeMarkers.length > 0) {
          const hybridSection = document.getElementById('hybrid-race-section');
          const hybridBarsContainer = document.getElementById('hybrid-race-bars');
          const hybridTotal = document.getElementById('hybrid-race-total');
          const hybridName = document.getElementById('hybrid-race-name');

          // Determine race type for subtitle
          const raceType = activityName.toLowerCase().includes('hyrox') ? 'HYROX' : 'ATHX';
          hybridName.textContent = raceType + ' Race';

          // Calculate total duration for bar widths
          let totalDuration = 0;
          const segments = [];

          // Get session total elapsed time to calculate the last segment's duration
          const sessionTotalTime = session.totalElapsedTime || 0;

          for (let i = 0; i < timeMarkers.length; i++) {
            const marker = timeMarkers[i];
            const nextMarker = timeMarkers[i + 1];
            const isLastMarker = i === timeMarkers.length - 1;

            // Calculate duration to next marker or use marker's own duration if available
            let duration = 0;
            if (nextMarker && marker.timestamp && nextMarker.timestamp) {
              const startMs = new Date(marker.timestamp).getTime();
              const endMs = new Date(nextMarker.timestamp).getTime();
              duration = (endMs - startMs) / 1000; // seconds
            } else if (isLastMarker && sessionTotalTime > 0 && totalDuration > 0) {
              // For the last marker, calculate remaining time from session total
              duration = sessionTotalTime - totalDuration;
            } else if (marker.durationSeconds) {
              duration = marker.durationSeconds;
            }

            if (duration > 0) {
              totalDuration += duration;
              segments.push({
                label: marker.label || `Station ${i + 1}`,
                icon: marker.icon || getStationIcon(marker.label || ''),
                duration: duration,
                isRun: (marker.markerType === 'run_start' || marker.label?.toLowerCase().includes('run'))
              });
            }
          }

          // Fallback: If no time markers, try to infer from laps
          if (segments.length === 0 && session.laps && session.laps.length > 0) {
            session.laps.forEach((lap, i) => {
              if (lap.totalElapsedTime > 0) {
                const isRun = lap.exerciseName?.toLowerCase().includes('run') || !lap.exerciseName;
                totalDuration += lap.totalElapsedTime;
                segments.push({
                  label: lap.exerciseName || `Lap ${i + 1}`,
                  icon: getStationIcon(lap.exerciseName || ''),
                  duration: lap.totalElapsedTime,
                  isRun: isRun
                });
              }
            });
          }

          if (segments.length > 0) {
            // Find the longest segment for scaling (so longest bar = 100%)
            const maxDuration = Math.max(...segments.map(s => s.duration));

            // Render the bar chart
            hybridBarsContainer.innerHTML = segments.map(seg => {
              // Scale relative to longest segment, minimum 15% to keep readable
              const widthPercent = Math.max(15, (seg.duration / maxDuration) * 100);
              const barClass = seg.isRun ? 'bar-run' : 'bar-station';
              return `
                <div class="hybrid-race-bar-row">
                  <span class="hybrid-race-bar-icon">${seg.icon}</span>
                  <span class="hybrid-race-bar-label">${seg.label}</span>
                  <div class="hybrid-race-bar-container">
                    <div class="hybrid-race-bar ${barClass}" style="width: ${widthPercent}%;">
                      <span class="hybrid-race-bar-time">${formatTime(seg.duration)}</span>
                    </div>
                  </div>
                </div>
              `;
            }).join('');

            // Render total
            hybridTotal.innerHTML = `
              <span class="hybrid-race-total-label">‚è±Ô∏è Total Race Time</span>
              <span class="hybrid-race-total-value">${formatDuration(totalDuration)}</span>
            `;

            hybridSection.style.display = 'block';
          }
        }

        // Helper function for station icons
        function getStationIcon(name) {
          const n = name.toLowerCase();
          if (n.includes('run')) return 'üèÉ';
          if (n.includes('ski')) return '‚õ∑Ô∏è';
          if (n.includes('sled push')) return 'üõ∑';
          if (n.includes('sled pull')) return 'üõ∑';
          if (n.includes('burpee')) return 'üèãÔ∏è';
          if (n.includes('row')) return 'üö£';
          if (n.includes('farmer')) return 'üß≥';
          if (n.includes('sandbag') || n.includes('lunge')) return 'üéí';
          if (n.includes('wall ball')) return 'üèê';
          return 'üèÅ';
        }
      }

      // Enrichments
      if (data.appliedEnrichments && data.appliedEnrichments.length > 0) {
        const enrichSection = document.getElementById('enrichments-section');
        const badgesEl = document.getElementById('enrichment-badges');
        const registry = data.registry || {};

        badgesEl.innerHTML = data.appliedEnrichments.map(e => {
          const info = registry[e] || {
            icon: '‚ö°',
            name: e.replace('ENRICHER_PROVIDER_', '').replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
            description: 'Boosted activity data'
          };
          return `
          <div class="enrichment-item">
            <span class="enrichment-icon">${info.icon}</span>
            <div class="enrichment-info">
              <div class="enrichment-name">${info.name}</div>
              <div class="enrichment-desc">${info.description || info.desc}</div>
            </div>
          </div>
        `;
        }).join('');
        enrichSection.style.display = 'block';
      }

      // Muscle Activation Image
      if (data.enrichmentMetadata && data.enrichmentMetadata.asset_muscle_heatmap) {
        const muscleSection = document.getElementById('muscle-activation-section');
        const muscleContainer = document.getElementById('muscle-heatmap-container');
        // Only render if not already rendered above
        if (!muscleContainer.hasChildNodes()) {
          renderAsset(data.enrichmentMetadata.asset_muscle_heatmap, 'Muscle Activation Heatmap', 'muscle-heatmap-image', muscleContainer);
        }
        muscleSection.style.display = 'block';
      }

      // Description - Parse into sections and render as cards
      if (data.description) {
        renderDescriptionSections(data.description);
      }

      // Tags
      if (data.tags && data.tags.length > 0) {
        document.getElementById('tags-section').style.display = 'block';
        document.getElementById('activity-tags').innerHTML = data.tags.map(t =>
          `<span class="activity-tag">${t}</span>`
        ).join('');
      }
    }

    // --- MAP INITIALIZATION ---
    // Make initMap globally accessible for onclick handlers
    window.initMap = function initMap(records) {
      const map = L.map('activity-map', {
        zoomControl: true,
        scrollWheelZoom: false
      });

      // Dark theme tiles
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap, &copy; CARTO',
        maxZoom: 19
      }).addTo(map);

      // Create route polyline with gradient effect
      const latlngs = records.map(r => [r.positionLat, r.positionLong]);

      const routeLine = L.polyline(latlngs, {
        color: '#FF1B8D',
        weight: 4,
        opacity: 0.9,
        lineCap: 'round',
        lineJoin: 'round'
      }).addTo(map);

      // Add start/end markers
      if (latlngs.length > 0) {
        L.circleMarker(latlngs[0], {
          radius: 8,
          fillColor: '#06FFA5',
          color: '#fff',
          weight: 2,
          fillOpacity: 1
        }).addTo(map).bindPopup('Start');

        L.circleMarker(latlngs[latlngs.length - 1], {
          radius: 8,
          fillColor: '#FF1B8D',
          color: '#fff',
          weight: 2,
          fillOpacity: 1
        }).addTo(map).bindPopup('Finish');
      }

      map.fitBounds(routeLine.getBounds(), { padding: [30, 30] });
    }

    // --- ELAPSED TIME HELPER ---
    // Generates time labels for chart X-axis in MM:SS format
    function generateTimeLabels(records) {
      if (!records || records.length === 0) return [];

      const firstRecord = records.find(r => r.timestamp);
      if (!firstRecord) return records.map((_, i) => i); // Fallback to indices

      const startTime = new Date(firstRecord.timestamp).getTime();

      return records.map(r => {
        if (!r.timestamp) return '';
        const elapsed = (new Date(r.timestamp).getTime() - startTime) / 1000; // seconds
        const mins = Math.floor(elapsed / 60);
        const secs = Math.floor(elapsed % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      });
    }

    // --- TIME MARKER ANNOTATIONS HELPER ---
    // Calculates marker positions based on elapsed time from activity start
    function calculateMarkerAnnotations(records, timeMarkers) {
      if (!timeMarkers || timeMarkers.length === 0 || !records || records.length === 0) {
        return {};
      }

      // Find first and last record timestamps to establish time range
      const recordsWithTime = records.filter(r => r.timestamp);
      if (recordsWithTime.length < 2) return {};

      const firstTime = new Date(recordsWithTime[0].timestamp).getTime();
      const lastTime = new Date(recordsWithTime[recordsWithTime.length - 1].timestamp).getTime();
      const totalDuration = lastTime - firstTime;
      if (totalDuration <= 0) return {};

      const annotations = {};
      const colors = ['#4CC9F0', '#FF1B8D', '#9D4EDD', '#FFD93D', '#6BCB77', '#FF6B6B'];

      // Sort markers by timestamp
      const sortedMarkers = [...timeMarkers]
        .filter(m => m.timestamp)
        .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

      sortedMarkers.forEach((marker, idx) => {
        const markerTime = new Date(marker.timestamp).getTime();

        // Calculate where this marker falls as a proportion of total time
        const elapsed = markerTime - firstTime;
        const proportion = elapsed / totalDuration;

        // Map to chart index (0 to records.length - 1)
        const chartIndex = Math.round(proportion * (records.length - 1));

        // Skip if marker is outside the data range
        if (chartIndex < 0 || chartIndex >= records.length) return;

        // Short label for readability
        const fullLabel = marker.label || `M${idx + 1}`;
        const shortLabel = fullLabel.split(' ')[0].substring(0, 10);

        annotations['marker' + idx] = {
          type: 'line',
          xMin: chartIndex,
          xMax: chartIndex,
          borderColor: colors[idx % colors.length],
          borderWidth: 1,
          borderDash: [4, 4],
          label: {
            display: true,
            content: shortLabel,
            position: 'start',
            yAdjust: -5,
            backgroundColor: 'transparent',
            color: colors[idx % colors.length],
            font: { size: 9, weight: 'bold' },
            padding: 2
          }
        };
      });

      return annotations;
    }

    // --- HEART RATE CHART ---
    function initHrChart(records, timeMarkers) {
      const ctx = document.getElementById('hr-chart').getContext('2d');

      // Interpolate missing HR values for continuous line
      const hrData = records.map((r, i) => {
        if (r.heartRate > 0) return r.heartRate;

        // Find nearest valid HR before and after
        let prevHR = null, nextHR = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].heartRate > 0) { prevHR = records[j].heartRate; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].heartRate > 0) { nextHR = records[j].heartRate; break; }
        }

        // Interpolate or use nearest valid
        if (prevHR !== null && nextHR !== null) return (prevHR + nextHR) / 2;
        return prevHR || nextHR || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Heart Rate',
            data: hrData,
            borderColor: '#ff6b6b',
            backgroundColor: 'rgba(255, 107, 107, 0.1)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            annotation: { annotations }
          },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: {
                color: '#666',
                maxTicksLimit: 8,
                font: { size: 9 }
              }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa' }
            }
          }
        }
      };

      storeChartConfig('hr', config);
      new Chart(ctx, config);
    }

    // --- ELEVATION CHART ---
    function initElevationChart(records, timeMarkers) {
      const ctx = document.getElementById('elevation-chart').getContext('2d');

      // Interpolate missing altitude values
      const elevData = records.map((r, i) => {
        if (r.altitude !== undefined) return r.altitude;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].altitude !== undefined) { prev = records[j].altitude; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].altitude !== undefined) { next = records[j].altitude; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Elevation',
            data: elevData,
            borderColor: '#9D4EDD',
            backgroundColor: 'rgba(157, 78, 221, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + 'm' }
            }
          }
        }
      };

      storeChartConfig('elevation', config);
      new Chart(ctx, config);
    }

    // --- PACE CHART (converts speed m/s to min/km) ---
    function initPaceChart(records, timeMarkers) {
      const ctx = document.getElementById('pace-chart').getContext('2d');

      // Convert speed to pace, interpolate missing values
      const paceData = records.map((r, i) => {
        if (r.speed > 0) {
          const pace = (1000 / r.speed) / 60;
          return pace < 15 ? pace : null; // Cap unreasonable paces
        }

        // Find nearest valid pace
        let prevPace = null, nextPace = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].speed > 0) {
            const p = (1000 / records[j].speed) / 60;
            if (p < 15) { prevPace = p; break; }
          }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].speed > 0) {
            const p = (1000 / records[j].speed) / 60;
            if (p < 15) { nextPace = p; break; }
          }
        }
        if (prevPace !== null && nextPace !== null) return (prevPace + nextPace) / 2;
        return prevPace || nextPace || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Pace',
            data: paceData,
            borderColor: '#FFD93D',
            backgroundColor: 'rgba(255, 217, 61, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              reverse: true, // Lower pace = faster, so reverse axis
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: {
                color: '#aaa',
                callback: v => {
                  const mins = Math.floor(v);
                  const secs = Math.round((v - mins) * 60);
                  return mins + ':' + secs.toString().padStart(2, '0') + '/km';
                }
              }
            }
          }
        }
      };

      storeChartConfig('pace', config);
      new Chart(ctx, config);
    }

    // --- POWER CHART ---
    function initPowerChart(records, timeMarkers) {
      const ctx = document.getElementById('power-chart').getContext('2d');

      // Interpolate missing power values
      const powerData = records.map((r, i) => {
        if (r.power > 0) return r.power;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].power > 0) { prev = records[j].power; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].power > 0) { next = records[j].power; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Power',
            data: powerData,
            borderColor: '#06FFA5',
            backgroundColor: 'rgba(6, 255, 165, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + 'W' }
            }
          }
        }
      };

      storeChartConfig('power', config);
      new Chart(ctx, config);
    }

    // --- CADENCE CHART ---
    function initCadenceChart(records, timeMarkers) {
      const ctx = document.getElementById('cadence-chart').getContext('2d');

      // Interpolate missing cadence values
      const cadenceData = records.map((r, i) => {
        if (r.cadence > 0) return r.cadence;

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].cadence > 0) { prev = records[j].cadence; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].cadence > 0) { next = records[j].cadence; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Cadence',
            data: cadenceData,
            borderColor: '#FF6B9D',
            backgroundColor: 'rgba(255, 107, 157, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v + ' rpm' }
            }
          }
        }
      };

      storeChartConfig('cadence', config);
      new Chart(ctx, config);
    }

    // --- SPEED CHART (converts m/s to km/h) ---
    function initSpeedChart(records, timeMarkers) {
      const ctx = document.getElementById('speed-chart').getContext('2d');

      // Interpolate missing speed values
      const speedData = records.map((r, i) => {
        if (r.speed > 0) return r.speed * 3.6; // m/s to km/h

        let prev = null, next = null;
        for (let j = i - 1; j >= 0; j--) {
          if (records[j].speed > 0) { prev = records[j].speed * 3.6; break; }
        }
        for (let j = i + 1; j < records.length; j++) {
          if (records[j].speed > 0) { next = records[j].speed * 3.6; break; }
        }
        if (prev !== null && next !== null) return (prev + next) / 2;
        return prev || next || null;
      });

      const labels = generateTimeLabels(records);
      const annotations = calculateMarkerAnnotations(records, timeMarkers);

      const config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Speed',
            data: speedData,
            borderColor: '#00D4FF',
            backgroundColor: 'rgba(0, 212, 255, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, annotation: { annotations } },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: { color: '#666', maxTicksLimit: 8, font: { size: 9 } }
            },
            y: {
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { color: '#aaa', callback: v => v.toFixed(1) + ' km/h' }
            }
          }
        }
      };

      storeChartConfig('speed', config);
      new Chart(ctx, config);
    }

    // --- DESCRIPTION SECTION PARSING ---

    /**
     * Parse enriched description into sections based on enricher headers.
     * Headers follow pattern: emoji + text + colon (e.g., "‚ú® AI Summary:")
     * Handles multi-line sections by grouping content until next header.
     */
    function parseDescriptionSections(text) {
      if (!text) return [];

      // Branding footer to strip entirely (showcase has plenty of FitGlue branding)
      const brandingPattern = /\n?\n?Posted via FitGlue\s*üí™/g;

      // Strip branding from description before parsing
      text = text.replace(brandingPattern, '').trim();
      if (!text) return [];

      // Section headers are lines that END with a colon (nothing after the colon on that line)
      // This elegantly distinguishes:
      //   "üèÅ Hyrox - Male Single:" (section header - line ends with colon)
      //   "üèÉ Run 1: 5:54 (1.1km)" (NOT a section header - has content after colon)
      const lines = text.split('\n');
      const sections = [];
      let currentSection = null;
      let preHeaderContent = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        const prevLine = i > 0 ? lines[i - 1].trim() : '';

        // Check if this line is a section header. Two patterns:
        // 1. Line ends with colon (multi-line sections like "üèÅ Hyrox - Male Single:")
        // 2. Line preceded by blank line AND starts with emoji + colon pattern (single-line like "‚ù§Ô∏è Heart Rate: value")
        const endsWithColon = trimmedLine.endsWith(':') && trimmedLine.length > 1;
        // Single-line sections must start with an emoji (not dash, bullet, etc.)
        const startsWithEmoji = /^[\u{1F300}-\u{1FAD6}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{FE00}-\u{FE0F}\u{1F900}-\u{1F9FF}\u{2300}-\u{23FF}]/u.test(trimmedLine);
        const isSingleLineSection = prevLine === '' && i > 0 && startsWithEmoji && trimmedLine.includes(':');

        if (endsWithColon || isSingleLineSection) {
          // Save any pre-header content as "Description"
          if (currentSection === null && preHeaderContent.length > 0) {
            const content = preHeaderContent.join('\n').trim();
            if (content) {
              sections.push({ emoji: 'üìù', title: 'Description', content: content });
            }
            preHeaderContent = [];
          }

          // Save previous section
          if (currentSection !== null) {
            sections.push(currentSection);
          }

          // Extract emoji and title from header
          let emoji, title, sectionContent;

          if (endsWithColon) {
            // Multi-line section: "üèÅ Title:" - content is on subsequent lines
            const headerText = trimmedLine.slice(0, -1).trim();
            const emojiResult = extractLeadingEmoji(headerText);
            emoji = emojiResult.emoji;
            title = emojiResult.rest.trim() || 'Section';
            sectionContent = '';
          } else {
            // Single-line section: "‚ù§Ô∏è Heart Rate: value" - content is after the colon
            const colonIdx = trimmedLine.indexOf(':');
            const headerText = trimmedLine.slice(0, colonIdx).trim();
            const emojiResult = extractLeadingEmoji(headerText);
            emoji = emojiResult.emoji;
            title = emojiResult.rest.trim() || 'Section';
            sectionContent = trimmedLine.slice(colonIdx + 1).trim();
          }

          currentSection = { emoji, title, content: sectionContent };
        } else if (currentSection === null) {
          // Content before any section header (user description)
          preHeaderContent.push(line);
        } else {
          // Content within current section
          currentSection.content += (currentSection.content ? '\n' : '') + line;
        }
      }

      // Save final section
      if (currentSection !== null) {
        currentSection.content = currentSection.content.trim();
        sections.push(currentSection);
      } else if (preHeaderContent.length > 0) {
        // No sections found - treat all as description
        const content = preHeaderContent.join('\n').trim();
        if (content) {
          sections.push({ emoji: 'üìù', title: 'Description', content: content });
        }
      }

      return sections;
    }

    /**
     * Render parsed sections as individual styled cards.
     * - User description goes to hero section (prominent display)
     * - Compact sections (single-line) are grouped horizontally
     * - Normal sections render as full-width cards
     */
    function renderDescriptionSections(text) {
      const container = document.getElementById('description-sections-container');
      const userDescEl = document.getElementById('user-description');
      const sections = parseDescriptionSections(text);

      if (sections.length === 0) {
        container.style.display = 'none';
        userDescEl.style.display = 'none';
        return;
      }

      // Separate user description from enricher sections
      const userDescSection = sections.find(s => s.title === 'Description');
      const enricherSections = sections.filter(s => s.title !== 'Description');

      // Render user description in hero
      if (userDescSection && userDescSection.content) {
        userDescEl.textContent = userDescSection.content;
        userDescEl.style.display = 'block';
      } else {
        userDescEl.style.display = 'none';
      }

      // If no enricher sections, hide container
      if (enricherSections.length === 0) {
        container.style.display = 'none';
        return;
      }

      // Detect compact sections (single-line, short content)
      const isCompact = (section) => {
        const lines = section.content.split('\n').filter(l => l.trim());
        return lines.length <= 1 && section.content.length < 100;
      };

      // Group consecutive compact sections for horizontal layout
      let html = '';
      let compactGroup = [];
      let idx = 0;

      const flushCompactGroup = () => {
        if (compactGroup.length === 0) return;

        // If single compact section, render normally to avoid orphan
        if (compactGroup.length === 1) {
          compactGroup.forEach(section => {
            html += renderSectionCard(section, idx++);
          });
        } else {
          // Wrap in horizontal row
          html += '<div class="compact-sections-row">';
          compactGroup.forEach(section => {
            html += renderSectionCard(section, idx++);
          });
          html += '</div>';
        }
        compactGroup = [];
      };

      enricherSections.forEach((section) => {
        if (isCompact(section)) {
          compactGroup.push(section);
        } else {
          flushCompactGroup();
          html += renderSectionCard(section, idx++);
        }
      });
      flushCompactGroup();

      container.innerHTML = html;
      container.style.display = 'block';
    }

    /**
     * Render a single section card.
     * Delegates to specialised renderers for known enricher sections.
     */
    function renderSectionCard(section, idx) {
      const title = section.title;

      // Route to specialised renderers based on section title
      if (title === 'Personal Records') return renderPRSection(section, idx);
      if (title.startsWith('Intervals')) return renderIntervalsSection(section, idx);
      if (title === 'Heart Rate Zones') return renderHRZonesSection(section, idx);
      if (title.includes('Goal Progress')) return renderGoalSection(section, idx);
      if (title === 'Streak Tracker') return renderStreakSection(section, idx);
      if (title.startsWith('Lifetime')) return renderMilestoneSection(section, idx);
      if (title === 'Parkrun Results') return renderParkrunSection(section, idx);
      if (title.startsWith('Effort Score')) return renderEffortScoreSection(section, idx);
      if (title === 'Workout Summary') return renderWorkoutSummarySection(section, idx);

      // AI Summary gets pretty prose styling
      if (title === 'AI Summary') return renderAISummarySection(section, idx);

      // Bullet-list sections get parsed stat rows
      const lines = section.content.split('\n').filter(l => l.trim());
      const bulletLines = lines.filter(l => l.trim().startsWith('‚Ä¢'));
      if (bulletLines.length > 0 && bulletLines.length === lines.length) {
        return renderBulletListSection(section, idx);
      }

      // Single-line with ‚Ä¢ separators get stat pills
      if (lines.length <= 1 && section.content.includes(' ‚Ä¢ ')) {
        return renderCompactStatPills(section, idx);
      }

      // Single-line compact sections that didn't match above get a clean value display
      if (lines.length <= 1 && section.content.trim()) {
        return `
          <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
            <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
            <div class="compact-stat-pills">
              <span class="stat-pill"><span class="stat-pill-value">${escapeHtml(section.content.trim())}</span></span>
            </div>
          </div>`;
      }

      // Generic fallback
      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header">
            <h2>${section.emoji} ${section.title}</h2>
          </div>
          <pre class="activity-description">${escapeHtml(section.content)}</pre>
        </div>
      `;
    }

    /**
     * Parse a single PR bullet line into structured data.
     * Input:  "üèÜ Bench Press (barbell) 1RM: 53.3kg"
     * Input:  "üí™ Bench Press (barbell) Volume: 1280kg (previous: 1200kg, +6.7%)"
     */
    function parsePRLine(line) {
      // Strip leading bullet
      line = line.replace(/^‚Ä¢\s*/, '').trim();
      if (!line) return null;

      // Extract emoji (first character cluster)
      const chars = [...line];
      const emoji = chars[0] || 'üèÜ';
      let rest = line.slice(emoji.length).trim();

      // Split on the LAST colon that precedes the value
      // Pattern: "Name Type: value (previous: ...)"
      // We need the last TYPE keyword before the colon
      const typePatterns = ['1RM', 'Volume', 'Max Reps', 'Total Time',
        'Fastest 5K', 'Fastest 10K', 'Fastest Half Marathon',
        'Longest Run', 'Longest Ride', 'Highest Elevation Gain'];

      let name = '', recordType = '', value = '', previous = '', improvement = '';

      // Try to match known type suffixes
      let matched = false;
      for (const tp of typePatterns) {
        const idx = rest.lastIndexOf(tp + ':');
        if (idx >= 0) {
          name = rest.substring(0, idx).trim();
          const afterType = rest.substring(idx + tp.length + 1).trim();
          recordType = tp;

          // Extract improvement in parentheses
          const parenMatch = afterType.match(/^(.+?)\s*\(previous:\s*(.+?),\s*([+-]?[\d.]+%)\)$/);
          if (parenMatch) {
            value = parenMatch[1].trim();
            previous = parenMatch[2].trim();
            improvement = parenMatch[3].trim();
          } else {
            value = afterType;
          }
          matched = true;
          break;
        }
      }

      // Fallback: split on first colon
      if (!matched) {
        const colonIdx = rest.indexOf(':');
        if (colonIdx < 0) return null;
        const beforeColon = rest.substring(0, colonIdx).trim();
        const afterColon = rest.substring(colonIdx + 1).trim();

        // Try to separate name from type (last word before colon)
        const words = beforeColon.split(/\s+/);
        if (words.length > 1) {
          recordType = words.pop();
          name = words.join(' ');
        } else {
          name = beforeColon;
          recordType = '';
        }

        const parenMatch = afterColon.match(/^(.+?)\s*\(previous:\s*(.+?),\s*([+-]?[\d.]+%)\)$/);
        if (parenMatch) {
          value = parenMatch[1].trim();
          previous = parenMatch[2].trim();
          improvement = parenMatch[3].trim();
        } else {
          value = afterColon;
        }
      }

      // Determine CSS type class
      const lowerType = recordType.toLowerCase();
      let typeClass = 'time'; // default
      if (lowerType === '1rm') typeClass = '1rm';
      else if (lowerType === 'volume') typeClass = 'volume';
      else if (lowerType.includes('reps')) typeClass = 'reps';
      else if (lowerType.includes('fastest') || lowerType.includes('time')) typeClass = 'time';
      else if (lowerType.includes('longest') || lowerType.includes('distance') || lowerType.includes('elevation')) typeClass = 'distance';

      return { emoji, name, recordType, value, previous, improvement, typeClass };
    }

    /**
     * Render Personal Records as a rich grid of individual PR cards.
     */
    function renderPRSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const records = lines.map(parsePRLine).filter(Boolean);

      if (records.length === 0) {
        // Fallback to generic card
        return `
          <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
            <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
            <pre class="activity-description">${escapeHtml(section.content)}</pre>
          </div>`;
      }

      let cardsHtml = records.map((pr, i) => {
        const delay = (idx * 0.1) + (i * 0.05);
        let improvementHtml = '';
        if (pr.improvement) {
          const isPositive = !pr.improvement.startsWith('-');
          const cls = isPositive ? 'positive' : 'negative';
          const arrow = isPositive ? '‚ñ≤' : '‚ñº';
          improvementHtml = `<span class="pr-improvement ${cls}">${arrow} ${pr.improvement}</span>`;
        }

        const typeLabel = pr.recordType || 'Record';

        return `
          <div class="pr-card pr-type-${pr.typeClass}" style="animation-delay: ${delay}s;">
            <div class="pr-card-top">
              <span class="pr-emoji">${pr.emoji}</span>
              <span class="pr-name">${escapeHtml(pr.name)}</span>
            </div>
            <div class="pr-value gradient-${pr.typeClass}">${escapeHtml(pr.value)}</div>
            <span class="pr-type-label">${escapeHtml(typeLabel)}</span>
            ${improvementHtml}
          </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header">
            <h2>${section.emoji} ${section.title}</h2>
          </div>
          <div class="pr-records-grid">${cardsHtml}</div>
        </div>`;
    }

    /**
     * Render Intervals as a structured timeline.
     */
    function renderIntervalsSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let rowsHtml = lines.map((line, i) => {
        const delay = (idx * 0.1) + (i * 0.03);
        const trimmed = line.trim();

        // Classify the row
        let rowClass = 'sprint';
        let emoji = 'üí®';
        if (/^üî•/.test(trimmed) || /warmup/i.test(trimmed)) { rowClass = 'warmup'; emoji = 'üî•'; }
        else if (/^‚ùÑÔ∏è/.test(trimmed) || /cooldown/i.test(trimmed)) { rowClass = 'cooldown'; emoji = '‚ùÑÔ∏è'; }
        else if (/^üìä|^üìà/.test(trimmed)) { rowClass = 'summary'; emoji = [...trimmed][0]; }
        else if (/^üí®.*sprints:/.test(trimmed)) { rowClass = 'group-header'; }
        else { const e = [...trimmed][0]; if (e) emoji = e; }

        // Extract stats from ‚Ä¢ separated values or parenthetical HR
        const statsHtml = extractIntervalStats(trimmed);
        // Get the label (text before first stat indicator)
        const label = cleanIntervalLabel(trimmed);

        return `<div class="interval-row ${rowClass}" style="animation-delay:${delay}s">
          <span class="interval-emoji">${emoji}</span>
          <span class="interval-label">${escapeHtml(label)}</span>
          ${statsHtml}
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="intervals-timeline">${rowsHtml}</div>
        </div>`;
    }

    function cleanIntervalLabel(text) {
      // Strip leading emoji
      const chars = [...text];
      let rest = text.slice(chars[0].length).trim();
      // For lines like "Run 1: 0:40 ‚Ä¢ 3:27/km ‚Ä¢ 193m (149bpm)", keep just "Run 1"
      // For summary lines, keep full text
      if (/sprints:|Warmup|Cooldown/i.test(rest)) {
        return rest;
      }
      const colonIdx = rest.indexOf(':');
      if (colonIdx > 0 && colonIdx < 20) {
        return rest.substring(0, colonIdx);
      }
      return rest;
    }

    function extractIntervalStats(text) {
      const stats = [];
      // Time patterns like 0:40, 5:00
      const timeMatch = text.match(/:\s*(\d+:\d{2})\s*(?:‚Ä¢|$)/);
      if (timeMatch) stats.push(`<span class="interval-stat time">${timeMatch[1]}</span>`);
      // Pace patterns like 3:27/km, 5:47/km
      const paceMatches = text.match(/\d+:\d{2}\/km/g);
      if (paceMatches) {
        // Take the most relevant pace (last one or avg)
        const paceLabel = text.includes('avg') ? paceMatches[0] : paceMatches[paceMatches.length - 1];
        stats.push(`<span class="interval-stat pace">${paceLabel}</span>`);
      }
      // Distance patterns like 193m, 862m, 1.1km
      const distMatch = text.match(/(\d+(?:\.\d+)?\s*(?:km|m))(?:\s|\(|$)/i);
      if (distMatch) stats.push(`<span class="interval-stat dist">${distMatch[1]}</span>`);
      // HR patterns like (149bpm), peak 170bpm
      const hrMatch = text.match(/(\d+)\s*bpm/i);
      if (hrMatch) stats.push(`<span class="interval-stat hr">${hrMatch[1]}bpm</span>`);
      if (stats.length === 0) return '';
      return `<div class="interval-stats">${stats.join('')}</div>`;
    }

    /**
     * Render HR Zones as coloured progress bars.
     */
    function renderHRZonesSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      // Find max duration for scaling bars
      const zones = lines.map(l => parseHRZoneLine(l.trim())).filter(Boolean);
      const maxMin = Math.max(...zones.map(z => z.minutes), 1);

      const rowsHtml = zones.map((z, i) => {
        const pct = Math.max((z.minutes / maxMin) * 100, 2);
        const delay = (idx * 0.1) + (i * 0.05);
        return `<div class="hr-zone-row" style="animation-delay:${delay}s">
          <span class="hr-zone-label">${escapeHtml(z.label)}</span>
          <div class="hr-zone-bar">
            <div class="hr-zone-fill zone-${z.zone}" style="width:${pct}%"></div>
          </div>
          <span class="hr-zone-duration">${z.minutes} min</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="hr-zones-list">${rowsHtml}</div>
        </div>`;
    }

    function parseHRZoneLine(line) {
      // "Zone 4 (Threshold): üüßüüßüüßüüß‚¨ú 9 min"
      const match = line.match(/^Zone\s+(\d)\s*\(([^)]+)\).*?(\d+)\s*min/i);
      if (!match) return null;
      return {
        zone: parseInt(match[1]),
        label: `Z${match[1]} ${match[2]}`,
        minutes: parseInt(match[3])
      };
    }

    /**
     * Render Goal Progress with a real progress bar.
     */
    function renderGoalSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let percentage = 0;
      let progressText = '';
      const detailRows = [];

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // Parse progress bar line: [‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 24% 3.5/15 km
        const barMatch = trimmed.match(/\[.*?\]\s*(\d+)%\s*(.+)/);
        if (barMatch) {
          percentage = parseInt(barMatch[1]);
          progressText = barMatch[2];
          continue;
        }
        // Percentage without bar
        const pctMatch = trimmed.match(/(\d+)%/);
        if (pctMatch && !percentage) percentage = parseInt(pctMatch[1]);
        // Collect detail lines
        const emoji = [...trimmed][0] || '‚Ä¢';
        const rest = trimmed.slice(emoji.length).trim();
        detailRows.push({ emoji, text: rest || trimmed });
      }

      const detailsHtml = detailRows.map(d =>
        `<div class="progress-detail-row"><span class="detail-emoji">${d.emoji}</span>${escapeHtml(d.text)}</div>`
      ).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="progress-section-body">
            <div class="progress-bar-container">
              <div class="progress-bar-fill" style="width:${Math.min(percentage, 100)}%">
                <span class="progress-bar-label">${percentage}%${progressText ? ' ‚Äî ' + escapeHtml(progressText) : ''}</span>
              </div>
            </div>
            <div class="progress-details">${detailsHtml}</div>
          </div>
        </div>`;
    }

    /**
     * Render Streak Tracker with a prominent streak number.
     */
    function renderStreakSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let streakNumber = null;
      const badges = [];
      const details = [];

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // Extract streak number: "üèÜüî• 81-day activity streak!"
        const streakMatch = trimmed.match(/(\d+)[- ]day/i);
        if (streakMatch && streakNumber === null) {
          streakNumber = parseInt(streakMatch[1]);
        }
        // Detect achievement badges
        if (/personal best|new.*record/i.test(trimmed)) {
          badges.push(trimmed);
        } else {
          details.push(trimmed);
        }
      }

      const badgesHtml = badges.map(b =>
        `<span class="streak-badge">üèÜ ${escapeHtml(b)}</span>`
      ).join('');

      const detailsHtml = details.filter(d => !/\d+[- ]day/i.test(d) || !streakNumber).map(d => {
        const emoji = [...d][0] || '‚Ä¢';
        const rest = d.slice(emoji.length).trim();
        return `<div class="progress-detail-row"><span class="detail-emoji">${emoji}</span>${escapeHtml(rest || d)}</div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="progress-section-body">
            ${streakNumber !== null ? `<div><span class="streak-number">${streakNumber}</span> <span class="streak-label">day streak üî•</span></div>` : ''}
            ${badgesHtml}
            ${detailsHtml ? `<div class="progress-details">${detailsHtml}</div>` : ''}
          </div>
        </div>`;
    }

    /**
     * Render Lifetime Milestone with progress bar toward next milestone.
     */
    function renderMilestoneSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let total = null;
      let milestone = null;
      let remaining = null;
      const details = [];

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // "475.4 km total"
        const totalMatch = trimmed.match(/([\d,.]+)\s*(km|mi|m)\s*total/i);
        if (totalMatch) total = { value: parseFloat(totalMatch[1].replace(',', '')), unit: totalMatch[2] };
        // "Next milestone: 500 km (24.6 km to go)"
        const mileMatch = trimmed.match(/milestone.*?([\d,.]+)\s*(km|mi|m)/i);
        if (mileMatch) milestone = { value: parseFloat(mileMatch[1].replace(',', '')), unit: mileMatch[2] };
        const remainMatch = trimmed.match(/([\d,.]+)\s*(km|mi|m)\s*to go/i);
        if (remainMatch) remaining = parseFloat(remainMatch[1].replace(',', ''));
        const emoji = [...trimmed][0] || 'üìä';
        const rest = trimmed.slice(emoji.length).trim();
        details.push({ emoji, text: rest || trimmed });
      }

      let progressHtml = '';
      if (total && milestone) {
        const pct = Math.min((total.value / milestone.value) * 100, 100);
        progressHtml = `
          <div class="progress-bar-container">
            <div class="progress-bar-fill milestone" style="width:${pct}%">
              <span class="progress-bar-label">${total.value} / ${milestone.value} ${total.unit}</span>
            </div>
          </div>`;
      }

      const detailsHtml = details.map(d =>
        `<div class="progress-detail-row"><span class="detail-emoji">${d.emoji}</span>${escapeHtml(d.text)}</div>`
      ).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="progress-section-body">
            ${progressHtml}
            <div class="progress-details">${detailsHtml}</div>
          </div>
        </div>`;
    }

    /**
     * Render bullet-list sections as structured stat rows.
     */
    function renderBulletListSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const rowsHtml = lines.map((line, i) => {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        const delay = (idx * 0.1) + (i * 0.04);

        // Extract leading emoji properly (handles multi-codepoint emoji)
        const emojiResult = extractLeadingEmoji(trimmed);
        const emoji = emojiResult.emoji;
        let rest = emojiResult.rest.trim();

        // Handle progress bar lines (keep as-is but styled)
        if (rest.includes('[') && rest.includes(']')) {
          return `<div class="stat-row" style="animation-delay:${delay}s">
            <span class="stat-row-emoji">${emoji}</span>
            <span class="stat-row-value" style="flex:1">${escapeHtml(rest)}</span>
          </div>`;
        }

        const colonIdx = rest.indexOf(':');
        if (colonIdx > 0 && colonIdx < rest.length - 1) {
          const label = rest.substring(0, colonIdx).trim();
          const value = rest.substring(colonIdx + 1).trim();
          return `<div class="stat-row" style="animation-delay:${delay}s">
            <span class="stat-row-emoji">${emoji}</span>
            <span class="stat-row-label">${escapeHtml(label)}</span>
            <span class="stat-row-value">${escapeHtml(value)}</span>
          </div>`;
        }

        return `<div class="stat-row" style="animation-delay:${delay}s">
          <span class="stat-row-emoji">${emoji}</span>
          <span class="stat-row-label">${escapeHtml(rest)}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="stat-rows">${rowsHtml}</div>
        </div>`;
    }

    /**
     * Render single-line sections with ‚Ä¢ separators as stat pills.
     */
    function renderCompactStatPills(section, idx) {
      const parts = section.content.split(' ‚Ä¢ ').map(p => p.trim()).filter(Boolean);
      const pillsHtml = parts.map(part => {
        // Try to split "label value" or just display as value
        // Common patterns: "295W avg", "557W max", "5:26/km avg"
        const labelMatch = part.match(/^(.+?)\s+(avg|max|min|best|total|gain|loss)$/i);
        if (labelMatch) {
          return `<span class="stat-pill"><span class="stat-pill-value">${escapeHtml(labelMatch[1])}</span> <span class="stat-pill-label">${escapeHtml(labelMatch[2])}</span></span>`;
        }
        return `<span class="stat-pill"><span class="stat-pill-value">${escapeHtml(part)}</span></span>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="compact-stat-pills">${pillsHtml}</div>
        </div>`;
    }

    /**
     * Render Parkrun Results with stat rows and PB trophy badges.
     */
    function renderParkrunSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      const rowsHtml = lines.map((line, i) => {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        const delay = (idx * 0.1) + (i * 0.05);

        // Split on ' ¬∑ ' to separate value from badges
        const parts = trimmed.split(' ¬∑ ');
        const mainPart = parts[0] || '';
        const badgeParts = parts.slice(1);

        // Parse label: value
        let label = '';
        let value = mainPart;
        const colonIdx = mainPart.indexOf(':');
        if (colonIdx > 0) {
          label = mainPart.substring(0, colonIdx).trim();
          value = mainPart.substring(colonIdx + 1).trim();
        }

        // Render badges
        const badgesHtml = badgeParts.map(b => {
          const bt = b.trim();
          let cls = '';
          if (/all-time/i.test(bt)) cls = 'all-time';
          else if (/this-year/i.test(bt)) cls = 'this-year';
          else if (/first time/i.test(bt)) cls = 'first-visit';
          else cls = 'all-time';
          return `<span class="parkrun-badge ${cls}">${escapeHtml(bt)}</span>`;
        }).join('');

        return `<div class="parkrun-stat-row" style="animation-delay:${delay}s">
          <span class="parkrun-stat-label">${escapeHtml(label)}</span>
          <span class="parkrun-stat-value">${escapeHtml(value)}</span>
          ${badgesHtml ? `<div class="parkrun-badges">${badgesHtml}</div>` : ''}
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="parkrun-results">${rowsHtml}</div>
        </div>`;
    }

    /**
     * Render Effort Score with a circular gauge and factor breakdown.
     */
    function renderEffortScoreSection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let score = 0;
      let label = 'Moderate';
      const factors = [];
      let verdict = '';

      for (const line of lines) {
        const trimmed = line.trim().replace(/^‚Ä¢\s*/, '');
        // Parse score line: "78/100 (Hard)"
        const scoreMatch = trimmed.match(/(\d+)\/100\s*\(([^)]+)\)/);
        if (scoreMatch) {
          score = parseInt(scoreMatch[1]);
          label = scoreMatch[2];
          continue;
        }
        // Parse factor line: "üèÉ Pace: 1.23√ó avg"
        const factorMatch = trimmed.match(/^(.+?)\s+(.+?):\s+(.+)$/);
        if (factorMatch && factorMatch[1].length <= 4) {
          factors.push({ emoji: factorMatch[1], name: factorMatch[2], value: factorMatch[3] });
          continue;
        }
        // Verdict line: "üìà Harder than usual" / "üìâ Easier than usual"
        if (/harder|easier|typical/i.test(trimmed)) {
          verdict = trimmed;
        }
      }

      // Gauge SVG
      const circumference = 2 * Math.PI * 34;
      const dashoffset = circumference * (1 - score / 100);
      const labelClass = label.toLowerCase().replace(/\s+/g, '-');
      const strokeColor = getEffortColor(label);

      const gaugeHtml = `
        <div class="effort-gauge">
          <div class="effort-gauge-ring">
            <svg viewBox="0 0 80 80">
              <circle class="gauge-bg" cx="40" cy="40" r="34"/>
              <circle class="gauge-fill" cx="40" cy="40" r="34"
                stroke="${strokeColor}"
                stroke-dasharray="${circumference}"
                stroke-dashoffset="${dashoffset}"/>
            </svg>
            <span class="effort-gauge-value">${score}</span>
          </div>
          <div class="effort-gauge-info">
            <span class="effort-label ${labelClass}">${escapeHtml(label)}</span>
            ${verdict ? `<span class="effort-verdict">${escapeHtml(verdict)}</span>` : ''}
          </div>
        </div>`;

      const factorsHtml = factors.map((f, i) => {
        const delay = (idx * 0.1) + ((i + 1) * 0.05);
        return `<div class="effort-factor" style="animation-delay:${delay}s">
          <span class="effort-factor-emoji">${f.emoji}</span>
          <span class="effort-factor-name">${escapeHtml(f.name)}</span>
          <span class="effort-factor-value">${escapeHtml(f.value)}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="effort-score-body">
            ${gaugeHtml}
            ${factorsHtml ? `<div class="effort-factors">${factorsHtml}</div>` : ''}
          </div>
        </div>`;
    }

    function getEffortColor(label) {
      const l = label.toLowerCase();
      if (l === 'easy') return '#4ADE80';
      if (l === 'moderate') return '#FBBF24';
      if (l === 'hard') return '#FB923C';
      if (l.includes('very')) return '#EF4444';
      if (l === 'max') return '#DC2626';
      return '#FBBF24';
    }

    /**
     * Render Workout Summary with headline stats + grouped exercise list.
     */
    function renderWorkoutSummarySection(section, idx) {
      const lines = section.content.split('\n').filter(l => l.trim());
      let headlineStats = [];
      const exercises = [];

      for (const line of lines) {
        const trimmed = line.trim();
        // Headline stats line: "12 sets ‚Ä¢ 5,000kg volume ‚Ä¢ 48 reps"
        if (!trimmed.startsWith('‚Ä¢') && trimmed.includes(' ‚Ä¢ ')) {
          headlineStats = trimmed.split(' ‚Ä¢ ').map(s => s.trim()).filter(Boolean);
          continue;
        }
        // Exercise line: "‚Ä¢ Bench Press: 3 √ó 100.0kg"
        if (trimmed.startsWith('‚Ä¢')) {
          const content = trimmed.slice(1).trim();
          // Check for superset marker emoji (1Ô∏è‚É£, 2Ô∏è‚É£, etc.) or ‚¨ú
          let superset = '';
          let exerciseContent = content;
          const supersetMatch = content.match(/^([1-9]Ô∏è‚É£|üîü|‚¨ú)\s*(.+)$/);
          if (supersetMatch) {
            superset = supersetMatch[1];
            exerciseContent = supersetMatch[2];
          }
          // Split name: sets
          const colonIdx = exerciseContent.indexOf(':');
          if (colonIdx > 0) {
            const name = exerciseContent.substring(0, colonIdx).trim();
            const sets = exerciseContent.substring(colonIdx + 1).trim();
            exercises.push({ superset, name, sets });
          } else {
            exercises.push({ superset, name: exerciseContent, sets: '' });
          }
        }
      }

      const statsHtml = headlineStats.map(s =>
        `<span class="stat-pill"><span class="stat-pill-value">${escapeHtml(s)}</span></span>`
      ).join('');

      const exercisesHtml = exercises.map((ex, i) => {
        const delay = (idx * 0.1) + (i * 0.04);
        return `<div class="workout-exercise-row" style="animation-delay:${delay}s">
          ${ex.superset ? `<span class="workout-superset-marker">${ex.superset}</span>` : ''}
          <span class="workout-exercise-name">${escapeHtml(ex.name)}</span>
          <span class="workout-exercise-sets">${escapeHtml(ex.sets)}</span>
        </div>`;
      }).join('');

      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="workout-summary-body">
            ${statsHtml ? `<div class="workout-headline-stats">${statsHtml}</div>` : ''}
            ${exercisesHtml ? `<div class="workout-exercises">${exercisesHtml}</div>` : ''}
          </div>
        </div>`;
    }

    /**
     * Render AI Summary as pretty prose inside a styled card.
     */
    function renderAISummarySection(section, idx) {
      return `
        <div class="showcase-section glass-card description-section-card" style="animation-delay: ${idx * 0.1}s;">
          <div class="section-header"><h2>${section.emoji} ${section.title}</h2></div>
          <div class="ai-summary-prose">${escapeHtml(section.content)}</div>
        </div>`;
    }

    /**
     * Extract leading emoji from a string, handling multi-codepoint emoji
     * (variation selectors, ZWJ sequences, keycaps, flags).
     * Returns { emoji, rest } where rest is the remaining text.
     */
    function extractLeadingEmoji(text) {
      if (!text) return { emoji: 'üìù', rest: '' };
      // Match leading emoji: extended pictographic + optional modifiers/ZWJ sequences
      const emojiMatch = text.match(/^(\p{Emoji_Presentation}|\p{Emoji}\uFE0F)(\u200D(\p{Emoji_Presentation}|\p{Emoji}\uFE0F))*/u);
      if (emojiMatch) {
        return { emoji: emojiMatch[0], rest: text.slice(emojiMatch[0].length) };
      }
      // No emoji found ‚Äî return bullet as emoji and full text as rest
      return { emoji: '‚Ä¢', rest: text };
    }

    /**
     * Escape HTML to prevent XSS when inserting user content.
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // --- CHART MODAL ---

    // Store chart configurations for re-rendering in modal
    const chartConfigs = {};
    let modalChart = null;

    function storeChartConfig(key, config) {
      chartConfigs[key] = config;
    }

    function openChartModal(chartKey, title) {
      const modal = document.getElementById('chart-modal');
      const titleEl = document.getElementById('chart-modal-title');
      const canvas = document.getElementById('chart-modal-canvas');

      if (!chartConfigs[chartKey]) {
        console.warn('No chart config found for:', chartKey);
        return;
      }

      // Set title
      titleEl.textContent = title;

      // Destroy existing modal chart if any
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }

      // Show modal first so canvas has dimensions
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      document.documentElement.style.overflow = 'hidden';

      // Deep clone config to avoid mutating original
      const ctx = canvas.getContext('2d');
      const config = chartConfigs[chartKey];
      const modalConfig = deepCloneConfig(config);

      // Scale up annotation fonts for fullscreen readability
      if (modalConfig.options?.plugins?.annotation?.annotations) {
        Object.values(modalConfig.options.plugins.annotation.annotations).forEach(ann => {
          if (ann.label?.font) {
            ann.label.font.size = 14;
          }
        });
      }

      // Wait a frame for modal dimensions to settle
      requestAnimationFrame(() => {
        modalChart = new Chart(ctx, modalConfig);
      });

      // Close on ESC key
      document.addEventListener('keydown', handleModalEscape);
    }

    // Deep clone chart config, preserving functions
    function deepCloneConfig(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (typeof obj === 'function') return obj;
      if (Array.isArray(obj)) return obj.map(deepCloneConfig);
      const cloned = {};
      for (const key in obj) {
        cloned[key] = deepCloneConfig(obj[key]);
      }
      return cloned;
    }

    function closeChartModal() {
      const modal = document.getElementById('chart-modal');
      modal.style.display = 'none';
      document.body.style.overflow = '';
      document.documentElement.style.overflow = '';

      // Destroy modal chart
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }

      document.removeEventListener('keydown', handleModalEscape);
    }

    function handleModalEscape(e) {
      if (e.key === 'Escape') {
        closeChartModal();
      }
    }

    // Close modal when clicking backdrop
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('chart-modal-backdrop')) {
        closeChartModal();
      }
    });

    // Expose modal functions globally for onclick handlers
    window.openChartModal = openChartModal;
    window.closeChartModal = closeChartModal;

    // --- HELPERS ---

    // Check if URL points to an SVG asset
    function isSvgUrl(url) {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname.toLowerCase();
        return pathname.endsWith('.svg') || pathname.includes('.svg');
      } catch {
        return url.toLowerCase().includes('.svg');
      }
    }

    // Render asset as inline SVG or img based on file type
    function renderAsset(url, alt, className, container) {
      if (isSvgUrl(url)) {
        // Fetch and render SVG inline
        fetch(url)
          .then(res => {
            if (!res.ok) throw new Error('Failed to fetch SVG');
            return res.text();
          })
          .then(text => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'image/svg+xml');
            const svgElement = doc.querySelector('svg');
            if (svgElement) {
              svgElement.removeAttribute('width');
              svgElement.removeAttribute('height');
              svgElement.setAttribute('aria-label', alt);
              svgElement.setAttribute('role', 'img');
              if (className) {
                svgElement.classList.add(...className.split(' '));
              }
              container.innerHTML = svgElement.outerHTML;
            } else {
              // Fallback to img on parse failure
              container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
            }
          })
          .catch(() => {
            // Fallback to img on fetch failure
            container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
          });
      } else {
        // Non-SVG: use img tag
        container.innerHTML = `<img src="${url}" alt="${alt}" class="${className}" loading="lazy" />`;
      }
    }

    function formatActivityType(type) {
      const types = {
        0: 'Workout', 5: 'CrossFit', 12: 'HIIT', 13: 'Hike', 23: 'Ride', 27: 'Run', 37: 'Swim',
        40: 'Trail Run', 45: 'Walk', 46: 'Weight Training', 49: 'Workout', 50: 'Yoga'
      };
      return types[type] || 'Activity';
    }

    function formatSource(source) {
      const sources = { 0: 'Unknown', 1: 'Hevy', 3: 'Fitbit', 4: 'Parkrun', 5: 'FIT Upload', 99: 'Test' };
      return sources[source] || 'Unknown';
    }

    function formatDuration(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      return h > 0 ? `${h}h ${m}m` : `${m}m`;
    }

    function formatDistance(meters) {
      return meters >= 1000 ? `${(meters / 1000).toFixed(1)}km` : `${Math.round(meters)}m`;
    }

    function formatWeight(kg) {
      return kg >= 1000 ? `${(kg / 1000).toFixed(1)}t` : `${Math.round(kg)}kg`;
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.round(seconds % 60);
      return m > 0 ? `${m}:${s.toString().padStart(2, '0')}` : `${s}s`;
    }


    function formatCollapsedSets(sets) {
      if (!sets || sets.length === 0) return "";

      const formattedSets = sets.map(s => formatSingleSet(s));

      // Check if all sets are identical
      const allIdentical = formattedSets.every(s => s === formattedSets[0]);

      if (allIdentical && sets.length > 1) {
        return `<span>üí™ ${sets.length} √ó ${formattedSets[0]}</span>`;
      }

      return formattedSets.map(s => `<span>üí™ ${s}</span>`).join('');
    }

    function formatSingleSet(set) {
      const hasWeight = set.weightKg > 0;
      const hasReps = set.reps > 0;
      const hasDistance = set.distanceMeters > 0;
      const hasTime = set.durationSeconds > 0;

      if (hasDistance || hasTime) {
        const parts = [];
        if (hasDistance) {
          parts.push(formatDistance(set.distanceMeters));
        }
        if (hasTime) {
          const formattedTime = formatTime(set.durationSeconds);
          if (hasDistance) {
            parts.push(`in ${formattedTime}`);
          } else {
            parts.push(formattedTime);
          }
        }
        if (hasWeight) {
          parts.push(`√ó ${Math.round(set.weightKg)}kg`);
        }
        return parts.join(' ');
      }

      // Standard weight lifting
      if (hasWeight && hasReps) {
        return `${set.reps} √ó ${set.weightKg.toFixed(1)}kg`;
      } else if (hasWeight) {
        return `${set.weightKg.toFixed(1)}kg`;
      } else if (hasReps) {
        return `${set.reps} reps`;
      }

      return "Completed";
    }

  })();
</script>

{{>footer}}